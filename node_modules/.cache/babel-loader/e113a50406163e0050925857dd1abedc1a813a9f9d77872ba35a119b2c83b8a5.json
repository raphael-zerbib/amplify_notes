{"ast":null,"code":"import { InternalAPI } from '@aws-amplify/api/internals';\nimport { ConsoleLogger, fetchAuthSession, Hub } from '@aws-amplify/core';\nimport { BackgroundProcessManager, Category, DataStoreAction } from '@aws-amplify/core/internals/utils';\nimport { Observable } from 'rxjs';\nimport { ProcessName } from '../../types.mjs';\nimport { buildSubscriptionGraphQLOperation, getAuthorizationRules, getUserGroupsFromToken, getModelAuthModes, TransformerMutationType, RTFError, generateRTFRemediation, getTokenForCustomAuth, predicateToGraphQLFilter } from '../utils.mjs';\nimport { ModelPredicateCreator } from '../../predicates/index.mjs';\nimport { validatePredicate } from '../../util.mjs';\nimport { getSubscriptionErrorType } from './errorMaps.mjs';\nimport { CONTROL_MSG as CONTROL_MSG$1 } from '@aws-amplify/api-graphql';\nconst logger = new ConsoleLogger('DataStore');\nvar CONTROL_MSG;\n(function (CONTROL_MSG) {\n  CONTROL_MSG[\"CONNECTED\"] = \"CONNECTED\";\n})(CONTROL_MSG || (CONTROL_MSG = {}));\nvar USER_CREDENTIALS;\n(function (USER_CREDENTIALS) {\n  USER_CREDENTIALS[USER_CREDENTIALS[\"none\"] = 0] = \"none\";\n  USER_CREDENTIALS[USER_CREDENTIALS[\"unauth\"] = 1] = \"unauth\";\n  USER_CREDENTIALS[USER_CREDENTIALS[\"auth\"] = 2] = \"auth\";\n})(USER_CREDENTIALS || (USER_CREDENTIALS = {}));\nclass SubscriptionProcessor {\n  constructor(schema, syncPredicates) {\n    let amplifyConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let authModeStrategy = arguments.length > 3 ? arguments[3] : undefined;\n    let errorHandler = arguments.length > 4 ? arguments[4] : undefined;\n    let amplifyContext = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n      InternalAPI\n    };\n    this.schema = schema;\n    this.syncPredicates = syncPredicates;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.errorHandler = errorHandler;\n    this.amplifyContext = amplifyContext;\n    this.typeQuery = new WeakMap();\n    this.buffer = [];\n    this.runningProcesses = new BackgroundProcessManager();\n  }\n  buildSubscription(namespace, model, transformerMutationType, userCredentials, oidcTokenPayload, authMode) {\n    let filterArg = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    const {\n      aws_appsync_authenticationType\n    } = this.amplifyConfig;\n    const {\n      isOwner,\n      ownerField,\n      ownerValue\n    } = this.getAuthorizationInfo(model, userCredentials, aws_appsync_authenticationType, oidcTokenPayload, authMode) || {};\n    const [opType, opName, query] = buildSubscriptionGraphQLOperation(namespace, model, transformerMutationType, isOwner, ownerField, filterArg);\n    return {\n      authMode,\n      opType,\n      opName,\n      query,\n      isOwner,\n      ownerField,\n      ownerValue\n    };\n  }\n  getAuthorizationInfo(model, userCredentials, defaultAuthType, oidcTokenPayload, authMode) {\n    const rules = getAuthorizationRules(model);\n    // Return null if user doesn't have proper credentials for private API with IAM auth\n    const iamPrivateAuth = authMode === 'iam' && rules.find(rule => rule.authStrategy === 'private' && rule.provider === 'iam');\n    if (iamPrivateAuth && userCredentials === USER_CREDENTIALS.unauth) {\n      return null;\n    }\n    // Group auth should take precedence over owner auth, so we are checking\n    // if rule(s) have group authorization as well as if either the Cognito or\n    // OIDC token has a groupClaim. If so, we are returning auth info before\n    // any further owner-based auth checks.\n    const groupAuthRules = rules.filter(rule => rule.authStrategy === 'groups' && ['userPools', 'oidc'].includes(rule.provider));\n    const validGroup = (authMode === 'oidc' || authMode === 'userPool') && groupAuthRules.find(groupAuthRule => {\n      // validate token against groupClaim\n      if (oidcTokenPayload) {\n        const oidcUserGroups = getUserGroupsFromToken(oidcTokenPayload, groupAuthRule);\n        return [...oidcUserGroups].find(userGroup => {\n          return groupAuthRule.groups.find(group => group === userGroup);\n        });\n      }\n    });\n    if (validGroup) {\n      return {\n        authMode,\n        isOwner: false\n      };\n    }\n    let ownerAuthInfo;\n    if (ownerAuthInfo) {\n      return ownerAuthInfo;\n    }\n    // Owner auth needs additional values to be returned in order to create the subscription with\n    // the correct parameters so we are getting the owner value from the OIDC token via the\n    // identityClaim from the auth rule.\n    const oidcOwnerAuthRules = authMode === 'oidc' || authMode === 'userPool' ? rules.filter(rule => rule.authStrategy === 'owner' && (rule.provider === 'oidc' || rule.provider === 'userPools')) : [];\n    oidcOwnerAuthRules.forEach(ownerAuthRule => {\n      var _model$fields$ownerAu;\n      const ownerValue = oidcTokenPayload[ownerAuthRule.identityClaim];\n      const singleOwner = ((_model$fields$ownerAu = model.fields[ownerAuthRule.ownerField]) === null || _model$fields$ownerAu === void 0 ? void 0 : _model$fields$ownerAu.isArray) !== true;\n      const isOwnerArgRequired = singleOwner && !ownerAuthRule.areSubscriptionsPublic;\n      if (ownerValue) {\n        ownerAuthInfo = {\n          authMode,\n          isOwner: isOwnerArgRequired,\n          ownerField: ownerAuthRule.ownerField,\n          ownerValue: String(ownerValue)\n        };\n      }\n    });\n    if (ownerAuthInfo) {\n      return ownerAuthInfo;\n    }\n    // Fallback: return authMode or default auth type\n    return {\n      authMode: authMode || defaultAuthType,\n      isOwner: false\n    };\n  }\n  hubQueryCompletionListener(completed, capsule) {\n    const {\n      payload: {\n        event\n      }\n    } = capsule;\n    if (event === CONTROL_MSG$1.SUBSCRIPTION_ACK) {\n      completed();\n    }\n  }\n  start() {\n    var _this = this;\n    this.runningProcesses = this.runningProcesses || new BackgroundProcessManager();\n    const ctlObservable = new Observable(observer => {\n      const promises = [];\n      // Creating subs for each model/operation combo so they can be unsubscribed\n      // independently, since the auth retry behavior is asynchronous.\n      let subscriptions = {};\n      let oidcTokenPayload;\n      let userCredentials = USER_CREDENTIALS.none;\n      this.runningProcesses.add(async () => {\n        try {\n          var _await$fetchAuthSessi;\n          // retrieving current AWS Credentials\n          const credentials = (_await$fetchAuthSessi = (await fetchAuthSession()).tokens) === null || _await$fetchAuthSessi === void 0 ? void 0 : _await$fetchAuthSessi.accessToken;\n          userCredentials = credentials ? USER_CREDENTIALS.auth : USER_CREDENTIALS.unauth;\n        } catch (err) {\n          // best effort to get AWS credentials\n        }\n        try {\n          var _session$tokens;\n          // retrieving current token info from Cognito UserPools\n          const session = await fetchAuthSession();\n          oidcTokenPayload = (_session$tokens = session.tokens) === null || _session$tokens === void 0 || (_session$tokens = _session$tokens.idToken) === null || _session$tokens === void 0 ? void 0 : _session$tokens.payload;\n        } catch (err) {\n          // best effort to get jwt from Cognito\n        }\n        Object.values(this.schema.namespaces).forEach(namespace => {\n          Object.values(namespace.models).filter(_ref => {\n            let {\n              syncable\n            } = _ref;\n            return syncable;\n          }).forEach(modelDefinition => this.runningProcesses.isOpen && this.runningProcesses.add(async () => {\n            const modelAuthModes = await getModelAuthModes({\n              authModeStrategy: this.authModeStrategy,\n              defaultAuthMode: this.amplifyConfig.aws_appsync_authenticationType,\n              modelName: modelDefinition.name,\n              schema: this.schema\n            });\n            // subscriptions are created only based on the READ auth mode(s)\n            const readAuthModes = modelAuthModes.READ;\n            subscriptions = {\n              ...subscriptions,\n              [modelDefinition.name]: {\n                [TransformerMutationType.CREATE]: [],\n                [TransformerMutationType.UPDATE]: [],\n                [TransformerMutationType.DELETE]: []\n              }\n            };\n            const operations = [TransformerMutationType.CREATE, TransformerMutationType.UPDATE, TransformerMutationType.DELETE];\n            const operationAuthModeAttempts = {\n              [TransformerMutationType.CREATE]: 0,\n              [TransformerMutationType.UPDATE]: 0,\n              [TransformerMutationType.DELETE]: 0\n            };\n            const predicatesGroup = ModelPredicateCreator.getPredicates(this.syncPredicates.get(modelDefinition), false);\n            const addFilterArg = predicatesGroup !== undefined;\n            // Retry subscriptions that failed for one of the following reasons:\n            // 1. unauthorized - retry with next auth mode (if available)\n            // 2. RTF error - retry without sending filter arg. (filtering will fall back to clientside)\n            const subscriptionRetry = async function (operation) {\n              let addFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : addFilterArg;\n              const {\n                opType: transformerMutationType,\n                opName,\n                query,\n                isOwner,\n                ownerField,\n                ownerValue,\n                authMode\n              } = _this.buildSubscription(namespace, modelDefinition, operation, userCredentials, oidcTokenPayload, readAuthModes[operationAuthModeAttempts[operation]], addFilter);\n              const authToken = await getTokenForCustomAuth(authMode, _this.amplifyConfig);\n              const variables = {};\n              const customUserAgentDetails = {\n                category: Category.DataStore,\n                action: DataStoreAction.Subscribe\n              };\n              if (addFilter && predicatesGroup) {\n                variables['filter'] = predicateToGraphQLFilter(predicatesGroup);\n              }\n              if (isOwner) {\n                if (!ownerValue) {\n                  observer.error('Owner field required, sign in is needed in order to perform this operation');\n                  return;\n                }\n                variables[ownerField] = ownerValue;\n              }\n              logger.debug(\"Attempting \".concat(operation, \" subscription with authMode: \").concat(readAuthModes[operationAuthModeAttempts[operation]]));\n              const queryObservable = _this.amplifyContext.InternalAPI.graphql({\n                query,\n                variables,\n                ...{\n                  authMode\n                },\n                authToken\n              }, undefined, customUserAgentDetails);\n              let subscriptionReadyCallback;\n              // TODO: consider onTerminate.then(() => API.cancel(...))\n              subscriptions[modelDefinition.name][transformerMutationType].push(queryObservable.subscribe({\n                next: result => {\n                  const {\n                    data,\n                    errors\n                  } = result;\n                  if (Array.isArray(errors) && errors.length > 0) {\n                    const messages = errors.map(_ref2 => {\n                      let {\n                        message\n                      } = _ref2;\n                      return message;\n                    });\n                    logger.warn(\"Skipping incoming subscription. Messages: \".concat(messages.join('\\n')));\n                    _this.drainBuffer();\n                    return;\n                  }\n                  const predicatesGroup = ModelPredicateCreator.getPredicates(_this.syncPredicates.get(modelDefinition), false);\n                  // @ts-ignore\n                  const {\n                    [opName]: record\n                  } = data;\n                  // checking incoming subscription against syncPredicate.\n                  // once AppSync implements filters on subscriptions, we'll be\n                  // able to set these when establishing the subscription instead.\n                  // Until then, we'll need to filter inbound\n                  if (_this.passesPredicateValidation(record, predicatesGroup)) {\n                    _this.pushToBuffer(transformerMutationType, modelDefinition, record);\n                  }\n                  _this.drainBuffer();\n                },\n                error: async subscriptionError => {\n                  const {\n                    errors: [{\n                      message = ''\n                    } = {}]\n                  } = subscriptionError;\n                  const isRTFError =\n                  // only attempt catch if a filter variable was added to the subscription query\n                  addFilter && _this.catchRTFError(message, modelDefinition, predicatesGroup);\n                  // Catch RTF errors\n                  if (isRTFError) {\n                    // Unsubscribe and clear subscription array for model/operation\n                    subscriptions[modelDefinition.name][transformerMutationType].forEach(subscription => subscription.unsubscribe());\n                    subscriptions[modelDefinition.name][transformerMutationType] = [];\n                    // retry subscription connection without filter\n                    subscriptionRetry(operation, false);\n                    return;\n                  }\n                  if (message.includes(CONTROL_MSG$1.REALTIME_SUBSCRIPTION_INIT_ERROR) || message.includes(CONTROL_MSG$1.CONNECTION_FAILED)) {\n                    // Unsubscribe and clear subscription array for model/operation\n                    subscriptions[modelDefinition.name][transformerMutationType].forEach(subscription => subscription.unsubscribe());\n                    subscriptions[modelDefinition.name][transformerMutationType] = [];\n                    operationAuthModeAttempts[operation]++;\n                    if (operationAuthModeAttempts[operation] >= readAuthModes.length) {\n                      // last auth mode retry. Continue with error\n                      logger.debug(\"\".concat(operation, \" subscription failed with authMode: \").concat(readAuthModes[operationAuthModeAttempts[operation] - 1]));\n                    } else {\n                      // retry with different auth mode. Do not trigger\n                      // observer error or error handler\n                      logger.debug(\"\".concat(operation, \" subscription failed with authMode: \").concat(readAuthModes[operationAuthModeAttempts[operation] - 1], \". Retrying with authMode: \").concat(readAuthModes[operationAuthModeAttempts[operation]]));\n                      subscriptionRetry(operation);\n                      return;\n                    }\n                  }\n                  logger.warn('subscriptionError', message);\n                  try {\n                    await _this.errorHandler({\n                      recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                      localModel: null,\n                      message,\n                      model: modelDefinition.name,\n                      operation,\n                      errorType: getSubscriptionErrorType(subscriptionError),\n                      process: ProcessName.subscribe,\n                      remoteModel: null,\n                      cause: subscriptionError\n                    });\n                  } catch (e) {\n                    logger.error('Subscription error handler failed with:', e);\n                  }\n                  if (typeof subscriptionReadyCallback === 'function') {\n                    subscriptionReadyCallback();\n                  }\n                  if (message.includes('\"errorType\":\"Unauthorized\"') || message.includes('\"errorType\":\"OperationDisabled\"')) {\n                    return;\n                  }\n                  observer.error(message);\n                }\n              }));\n              promises.push((async () => {\n                let boundFunction;\n                let removeBoundFunctionListener;\n                await new Promise(res => {\n                  subscriptionReadyCallback = res;\n                  boundFunction = _this.hubQueryCompletionListener.bind(_this, res);\n                  removeBoundFunctionListener = Hub.listen('api', boundFunction);\n                });\n                removeBoundFunctionListener();\n              })());\n            };\n            operations.forEach(op => subscriptionRetry(op));\n          }));\n        });\n        this.runningProcesses.isOpen && this.runningProcesses.add(() => Promise.all(promises).then(() => {\n          observer.next(CONTROL_MSG.CONNECTED);\n        }));\n      }, 'subscription processor new subscriber');\n      return this.runningProcesses.addCleaner(async () => {\n        Object.keys(subscriptions).forEach(modelName => {\n          subscriptions[modelName][TransformerMutationType.CREATE].forEach(subscription => subscription.unsubscribe());\n          subscriptions[modelName][TransformerMutationType.UPDATE].forEach(subscription => subscription.unsubscribe());\n          subscriptions[modelName][TransformerMutationType.DELETE].forEach(subscription => subscription.unsubscribe());\n        });\n      });\n    });\n    const dataObservable = new Observable(observer => {\n      this.dataObserver = observer;\n      this.drainBuffer();\n      return this.runningProcesses.addCleaner(async () => {\n        this.dataObserver = null;\n      });\n    });\n    return [ctlObservable, dataObservable];\n  }\n  async stop() {\n    await this.runningProcesses.close();\n    await this.runningProcesses.open();\n  }\n  passesPredicateValidation(record, predicatesGroup) {\n    if (!predicatesGroup) {\n      return true;\n    }\n    const {\n      predicates,\n      type\n    } = predicatesGroup;\n    return validatePredicate(record, type, predicates);\n  }\n  pushToBuffer(transformerMutationType, modelDefinition, data) {\n    this.buffer.push([transformerMutationType, modelDefinition, data]);\n  }\n  drainBuffer() {\n    if (this.dataObserver) {\n      this.buffer.forEach(data => this.dataObserver.next(data));\n      this.buffer = [];\n    }\n  }\n  /**\n   * @returns true if the service returned an RTF subscription error\n   * @remarks logs a warning with remediation instructions\n   *\n   */\n  catchRTFError(message, modelDefinition, predicatesGroup) {\n    const header = 'Backend subscriptions filtering error.\\n' + 'Subscriptions filtering will be applied clientside.\\n';\n    const messageErrorTypeMap = {\n      'UnknownArgument: Unknown field argument filter': RTFError.UnknownField,\n      'Filters exceed maximum attributes limit': RTFError.MaxAttributes,\n      'Filters combination exceed maximum limit': RTFError.MaxCombinations,\n      'filter uses same fieldName multiple time': RTFError.RepeatedFieldname,\n      \"The variables input contains a field name 'not'\": RTFError.NotGroup,\n      'The variables input contains a field that is not defined for input object type': RTFError.FieldNotInType\n    };\n    const [_errorMsg, errorType] = Object.entries(messageErrorTypeMap).find(_ref3 => {\n      let [errorMsg] = _ref3;\n      return message.includes(errorMsg);\n    }) || [];\n    if (errorType !== undefined) {\n      const remediationMessage = generateRTFRemediation(errorType, modelDefinition, predicatesGroup);\n      logger.warn(\"\".concat(header, \"\\n\").concat(message, \"\\n\").concat(remediationMessage));\n      return true;\n    }\n    return false;\n  }\n}\nexport { CONTROL_MSG, SubscriptionProcessor, USER_CREDENTIALS };","map":{"version":3,"names":["logger","ConsoleLogger","CONTROL_MSG","USER_CREDENTIALS","SubscriptionProcessor","constructor","schema","syncPredicates","amplifyConfig","arguments","length","undefined","authModeStrategy","errorHandler","amplifyContext","InternalAPI","typeQuery","WeakMap","buffer","runningProcesses","BackgroundProcessManager","buildSubscription","namespace","model","transformerMutationType","userCredentials","oidcTokenPayload","authMode","filterArg","aws_appsync_authenticationType","isOwner","ownerField","ownerValue","getAuthorizationInfo","opType","opName","query","buildSubscriptionGraphQLOperation","defaultAuthType","rules","getAuthorizationRules","iamPrivateAuth","find","rule","authStrategy","provider","unauth","groupAuthRules","filter","includes","validGroup","groupAuthRule","oidcUserGroups","getUserGroupsFromToken","userGroup","groups","group","ownerAuthInfo","oidcOwnerAuthRules","forEach","ownerAuthRule","_model$fields$ownerAu","identityClaim","singleOwner","fields","isArray","isOwnerArgRequired","areSubscriptionsPublic","String","hubQueryCompletionListener","completed","capsule","payload","event","CONTROL_MSG$1","SUBSCRIPTION_ACK","start","_this","ctlObservable","Observable","observer","promises","subscriptions","none","add","_await$fetchAuthSessi","credentials","fetchAuthSession","tokens","accessToken","auth","err","_session$tokens","session","idToken","Object","values","namespaces","models","_ref","syncable","modelDefinition","isOpen","modelAuthModes","getModelAuthModes","defaultAuthMode","modelName","name","readAuthModes","READ","TransformerMutationType","CREATE","UPDATE","DELETE","operations","operationAuthModeAttempts","predicatesGroup","ModelPredicateCreator","getPredicates","get","addFilterArg","subscriptionRetry","operation","addFilter","authToken","getTokenForCustomAuth","variables","customUserAgentDetails","category","Category","DataStore","action","DataStoreAction","Subscribe","predicateToGraphQLFilter","error","debug","concat","queryObservable","graphql","subscriptionReadyCallback","push","subscribe","next","result","data","errors","Array","messages","map","_ref2","message","warn","join","drainBuffer","record","passesPredicateValidation","pushToBuffer","subscriptionError","isRTFError","catchRTFError","subscription","unsubscribe","REALTIME_SUBSCRIPTION_INIT_ERROR","CONNECTION_FAILED","recoverySuggestion","localModel","errorType","getSubscriptionErrorType","process","ProcessName","remoteModel","cause","e","boundFunction","removeBoundFunctionListener","Promise","res","bind","Hub","listen","op","all","then","CONNECTED","addCleaner","keys","dataObservable","dataObserver","stop","close","open","predicates","type","validatePredicate","header","messageErrorTypeMap","RTFError","UnknownField","MaxAttributes","MaxCombinations","RepeatedFieldname","NotGroup","FieldNotInType","_errorMsg","entries","_ref3","errorMsg","remediationMessage","generateRTFRemediation"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/sync/processors/subscription.ts"],"sourcesContent":["import { InternalAPI } from '@aws-amplify/api/internals';\nimport { Hub, fetchAuthSession, ConsoleLogger, } from '@aws-amplify/core';\nimport { Category, DataStoreAction, BackgroundProcessManager, } from '@aws-amplify/core/internals/utils';\nimport { Observable } from 'rxjs';\nimport { ProcessName, } from '../../types';\nimport { buildSubscriptionGraphQLOperation, getAuthorizationRules, getModelAuthModes, getUserGroupsFromToken, TransformerMutationType, getTokenForCustomAuth, predicateToGraphQLFilter, RTFError, generateRTFRemediation, } from '../utils';\nimport { ModelPredicateCreator } from '../../predicates';\nimport { validatePredicate } from '../../util';\nimport { getSubscriptionErrorType } from './errorMaps';\nimport { CONTROL_MSG as PUBSUB_CONTROL_MSG } from '@aws-amplify/api-graphql';\nconst logger = new ConsoleLogger('DataStore');\nexport var CONTROL_MSG;\n(function (CONTROL_MSG) {\n    CONTROL_MSG[\"CONNECTED\"] = \"CONNECTED\";\n})(CONTROL_MSG || (CONTROL_MSG = {}));\nexport var USER_CREDENTIALS;\n(function (USER_CREDENTIALS) {\n    USER_CREDENTIALS[USER_CREDENTIALS[\"none\"] = 0] = \"none\";\n    USER_CREDENTIALS[USER_CREDENTIALS[\"unauth\"] = 1] = \"unauth\";\n    USER_CREDENTIALS[USER_CREDENTIALS[\"auth\"] = 2] = \"auth\";\n})(USER_CREDENTIALS || (USER_CREDENTIALS = {}));\nclass SubscriptionProcessor {\n    constructor(schema, syncPredicates, amplifyConfig = {}, authModeStrategy, errorHandler, amplifyContext = {\n        InternalAPI,\n    }) {\n        this.schema = schema;\n        this.syncPredicates = syncPredicates;\n        this.amplifyConfig = amplifyConfig;\n        this.authModeStrategy = authModeStrategy;\n        this.errorHandler = errorHandler;\n        this.amplifyContext = amplifyContext;\n        this.typeQuery = new WeakMap();\n        this.buffer = [];\n        this.runningProcesses = new BackgroundProcessManager();\n    }\n    buildSubscription(namespace, model, transformerMutationType, userCredentials, oidcTokenPayload, authMode, filterArg = false) {\n        const { aws_appsync_authenticationType } = this.amplifyConfig;\n        const { isOwner, ownerField, ownerValue } = this.getAuthorizationInfo(model, userCredentials, aws_appsync_authenticationType, oidcTokenPayload, authMode) || {};\n        const [opType, opName, query] = buildSubscriptionGraphQLOperation(namespace, model, transformerMutationType, isOwner, ownerField, filterArg);\n        return { authMode, opType, opName, query, isOwner, ownerField, ownerValue };\n    }\n    getAuthorizationInfo(model, userCredentials, defaultAuthType, oidcTokenPayload, authMode) {\n        const rules = getAuthorizationRules(model);\n        // Return null if user doesn't have proper credentials for private API with IAM auth\n        const iamPrivateAuth = authMode === 'iam' &&\n            rules.find(rule => rule.authStrategy === 'private' && rule.provider === 'iam');\n        if (iamPrivateAuth && userCredentials === USER_CREDENTIALS.unauth) {\n            return null;\n        }\n        // Group auth should take precedence over owner auth, so we are checking\n        // if rule(s) have group authorization as well as if either the Cognito or\n        // OIDC token has a groupClaim. If so, we are returning auth info before\n        // any further owner-based auth checks.\n        const groupAuthRules = rules.filter(rule => rule.authStrategy === 'groups' &&\n            ['userPools', 'oidc'].includes(rule.provider));\n        const validGroup = (authMode === 'oidc' || authMode === 'userPool') &&\n            groupAuthRules.find(groupAuthRule => {\n                // validate token against groupClaim\n                if (oidcTokenPayload) {\n                    const oidcUserGroups = getUserGroupsFromToken(oidcTokenPayload, groupAuthRule);\n                    return [...oidcUserGroups].find(userGroup => {\n                        return groupAuthRule.groups.find(group => group === userGroup);\n                    });\n                }\n            });\n        if (validGroup) {\n            return {\n                authMode,\n                isOwner: false,\n            };\n        }\n        let ownerAuthInfo;\n        if (ownerAuthInfo) {\n            return ownerAuthInfo;\n        }\n        // Owner auth needs additional values to be returned in order to create the subscription with\n        // the correct parameters so we are getting the owner value from the OIDC token via the\n        // identityClaim from the auth rule.\n        const oidcOwnerAuthRules = authMode === 'oidc' || authMode === 'userPool'\n            ? rules.filter(rule => rule.authStrategy === 'owner' &&\n                (rule.provider === 'oidc' || rule.provider === 'userPools'))\n            : [];\n        oidcOwnerAuthRules.forEach(ownerAuthRule => {\n            const ownerValue = oidcTokenPayload[ownerAuthRule.identityClaim];\n            const singleOwner = model.fields[ownerAuthRule.ownerField]?.isArray !== true;\n            const isOwnerArgRequired = singleOwner && !ownerAuthRule.areSubscriptionsPublic;\n            if (ownerValue) {\n                ownerAuthInfo = {\n                    authMode,\n                    isOwner: isOwnerArgRequired,\n                    ownerField: ownerAuthRule.ownerField,\n                    ownerValue: String(ownerValue),\n                };\n            }\n        });\n        if (ownerAuthInfo) {\n            return ownerAuthInfo;\n        }\n        // Fallback: return authMode or default auth type\n        return {\n            authMode: authMode || defaultAuthType,\n            isOwner: false,\n        };\n    }\n    hubQueryCompletionListener(completed, capsule) {\n        const { payload: { event }, } = capsule;\n        if (event === PUBSUB_CONTROL_MSG.SUBSCRIPTION_ACK) {\n            completed();\n        }\n    }\n    start() {\n        this.runningProcesses =\n            this.runningProcesses || new BackgroundProcessManager();\n        const ctlObservable = new Observable(observer => {\n            const promises = [];\n            // Creating subs for each model/operation combo so they can be unsubscribed\n            // independently, since the auth retry behavior is asynchronous.\n            let subscriptions = {};\n            let oidcTokenPayload;\n            let userCredentials = USER_CREDENTIALS.none;\n            this.runningProcesses.add(async () => {\n                try {\n                    // retrieving current AWS Credentials\n                    const credentials = (await fetchAuthSession()).tokens?.accessToken;\n                    userCredentials = credentials\n                        ? USER_CREDENTIALS.auth\n                        : USER_CREDENTIALS.unauth;\n                }\n                catch (err) {\n                    // best effort to get AWS credentials\n                }\n                try {\n                    // retrieving current token info from Cognito UserPools\n                    const session = await fetchAuthSession();\n                    oidcTokenPayload = session.tokens?.idToken?.payload;\n                }\n                catch (err) {\n                    // best effort to get jwt from Cognito\n                }\n                Object.values(this.schema.namespaces).forEach(namespace => {\n                    Object.values(namespace.models)\n                        .filter(({ syncable }) => syncable)\n                        .forEach(modelDefinition => this.runningProcesses.isOpen &&\n                        this.runningProcesses.add(async () => {\n                            const modelAuthModes = await getModelAuthModes({\n                                authModeStrategy: this.authModeStrategy,\n                                defaultAuthMode: this.amplifyConfig.aws_appsync_authenticationType,\n                                modelName: modelDefinition.name,\n                                schema: this.schema,\n                            });\n                            // subscriptions are created only based on the READ auth mode(s)\n                            const readAuthModes = modelAuthModes.READ;\n                            subscriptions = {\n                                ...subscriptions,\n                                [modelDefinition.name]: {\n                                    [TransformerMutationType.CREATE]: [],\n                                    [TransformerMutationType.UPDATE]: [],\n                                    [TransformerMutationType.DELETE]: [],\n                                },\n                            };\n                            const operations = [\n                                TransformerMutationType.CREATE,\n                                TransformerMutationType.UPDATE,\n                                TransformerMutationType.DELETE,\n                            ];\n                            const operationAuthModeAttempts = {\n                                [TransformerMutationType.CREATE]: 0,\n                                [TransformerMutationType.UPDATE]: 0,\n                                [TransformerMutationType.DELETE]: 0,\n                            };\n                            const predicatesGroup = ModelPredicateCreator.getPredicates(this.syncPredicates.get(modelDefinition), false);\n                            const addFilterArg = predicatesGroup !== undefined;\n                            // Retry subscriptions that failed for one of the following reasons:\n                            // 1. unauthorized - retry with next auth mode (if available)\n                            // 2. RTF error - retry without sending filter arg. (filtering will fall back to clientside)\n                            const subscriptionRetry = async (operation, addFilter = addFilterArg) => {\n                                const { opType: transformerMutationType, opName, query, isOwner, ownerField, ownerValue, authMode, } = this.buildSubscription(namespace, modelDefinition, operation, userCredentials, oidcTokenPayload, readAuthModes[operationAuthModeAttempts[operation]], addFilter);\n                                const authToken = await getTokenForCustomAuth(authMode, this.amplifyConfig);\n                                const variables = {};\n                                const customUserAgentDetails = {\n                                    category: Category.DataStore,\n                                    action: DataStoreAction.Subscribe,\n                                };\n                                if (addFilter && predicatesGroup) {\n                                    variables['filter'] =\n                                        predicateToGraphQLFilter(predicatesGroup);\n                                }\n                                if (isOwner) {\n                                    if (!ownerValue) {\n                                        observer.error('Owner field required, sign in is needed in order to perform this operation');\n                                        return;\n                                    }\n                                    variables[ownerField] = ownerValue;\n                                }\n                                logger.debug(`Attempting ${operation} subscription with authMode: ${readAuthModes[operationAuthModeAttempts[operation]]}`);\n                                const queryObservable = this.amplifyContext.InternalAPI.graphql({\n                                    query,\n                                    variables,\n                                    ...{ authMode },\n                                    authToken,\n                                }, undefined, customUserAgentDetails);\n                                let subscriptionReadyCallback;\n                                // TODO: consider onTerminate.then(() => API.cancel(...))\n                                subscriptions[modelDefinition.name][transformerMutationType].push(queryObservable.subscribe({\n                                    next: result => {\n                                        const { data, errors } = result;\n                                        if (Array.isArray(errors) && errors.length > 0) {\n                                            const messages = errors.map(({ message }) => message);\n                                            logger.warn(`Skipping incoming subscription. Messages: ${messages.join('\\n')}`);\n                                            this.drainBuffer();\n                                            return;\n                                        }\n                                        const predicatesGroup = ModelPredicateCreator.getPredicates(this.syncPredicates.get(modelDefinition), false);\n                                        // @ts-ignore\n                                        const { [opName]: record } = data;\n                                        // checking incoming subscription against syncPredicate.\n                                        // once AppSync implements filters on subscriptions, we'll be\n                                        // able to set these when establishing the subscription instead.\n                                        // Until then, we'll need to filter inbound\n                                        if (this.passesPredicateValidation(record, predicatesGroup)) {\n                                            this.pushToBuffer(transformerMutationType, modelDefinition, record);\n                                        }\n                                        this.drainBuffer();\n                                    },\n                                    error: async (subscriptionError) => {\n                                        const { errors: [{ message = '' } = {}], } = ({\n                                            errors: [],\n                                        } = subscriptionError);\n                                        const isRTFError = \n                                        // only attempt catch if a filter variable was added to the subscription query\n                                        addFilter &&\n                                            this.catchRTFError(message, modelDefinition, predicatesGroup);\n                                        // Catch RTF errors\n                                        if (isRTFError) {\n                                            // Unsubscribe and clear subscription array for model/operation\n                                            subscriptions[modelDefinition.name][transformerMutationType].forEach(subscription => subscription.unsubscribe());\n                                            subscriptions[modelDefinition.name][transformerMutationType] = [];\n                                            // retry subscription connection without filter\n                                            subscriptionRetry(operation, false);\n                                            return;\n                                        }\n                                        if (message.includes(PUBSUB_CONTROL_MSG.REALTIME_SUBSCRIPTION_INIT_ERROR) ||\n                                            message.includes(PUBSUB_CONTROL_MSG.CONNECTION_FAILED)) {\n                                            // Unsubscribe and clear subscription array for model/operation\n                                            subscriptions[modelDefinition.name][transformerMutationType].forEach(subscription => subscription.unsubscribe());\n                                            subscriptions[modelDefinition.name][transformerMutationType] = [];\n                                            operationAuthModeAttempts[operation]++;\n                                            if (operationAuthModeAttempts[operation] >=\n                                                readAuthModes.length) {\n                                                // last auth mode retry. Continue with error\n                                                logger.debug(`${operation} subscription failed with authMode: ${readAuthModes[operationAuthModeAttempts[operation] - 1]}`);\n                                            }\n                                            else {\n                                                // retry with different auth mode. Do not trigger\n                                                // observer error or error handler\n                                                logger.debug(`${operation} subscription failed with authMode: ${readAuthModes[operationAuthModeAttempts[operation] - 1]}. Retrying with authMode: ${readAuthModes[operationAuthModeAttempts[operation]]}`);\n                                                subscriptionRetry(operation);\n                                                return;\n                                            }\n                                        }\n                                        logger.warn('subscriptionError', message);\n                                        try {\n                                            await this.errorHandler({\n                                                recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                                                localModel: null,\n                                                message,\n                                                model: modelDefinition.name,\n                                                operation,\n                                                errorType: getSubscriptionErrorType(subscriptionError),\n                                                process: ProcessName.subscribe,\n                                                remoteModel: null,\n                                                cause: subscriptionError,\n                                            });\n                                        }\n                                        catch (e) {\n                                            logger.error('Subscription error handler failed with:', e);\n                                        }\n                                        if (typeof subscriptionReadyCallback === 'function') {\n                                            subscriptionReadyCallback();\n                                        }\n                                        if (message.includes('\"errorType\":\"Unauthorized\"') ||\n                                            message.includes('\"errorType\":\"OperationDisabled\"')) {\n                                            return;\n                                        }\n                                        observer.error(message);\n                                    },\n                                }));\n                                promises.push((async () => {\n                                    let boundFunction;\n                                    let removeBoundFunctionListener;\n                                    await new Promise(res => {\n                                        subscriptionReadyCallback = res;\n                                        boundFunction = this.hubQueryCompletionListener.bind(this, res);\n                                        removeBoundFunctionListener = Hub.listen('api', boundFunction);\n                                    });\n                                    removeBoundFunctionListener();\n                                })());\n                            };\n                            operations.forEach(op => subscriptionRetry(op));\n                        }));\n                });\n                this.runningProcesses.isOpen &&\n                    this.runningProcesses.add(() => Promise.all(promises).then(() => {\n                        observer.next(CONTROL_MSG.CONNECTED);\n                    }));\n            }, 'subscription processor new subscriber');\n            return this.runningProcesses.addCleaner(async () => {\n                Object.keys(subscriptions).forEach(modelName => {\n                    subscriptions[modelName][TransformerMutationType.CREATE].forEach(subscription => subscription.unsubscribe());\n                    subscriptions[modelName][TransformerMutationType.UPDATE].forEach(subscription => subscription.unsubscribe());\n                    subscriptions[modelName][TransformerMutationType.DELETE].forEach(subscription => subscription.unsubscribe());\n                });\n            });\n        });\n        const dataObservable = new Observable(observer => {\n            this.dataObserver = observer;\n            this.drainBuffer();\n            return this.runningProcesses.addCleaner(async () => {\n                this.dataObserver = null;\n            });\n        });\n        return [ctlObservable, dataObservable];\n    }\n    async stop() {\n        await this.runningProcesses.close();\n        await this.runningProcesses.open();\n    }\n    passesPredicateValidation(record, predicatesGroup) {\n        if (!predicatesGroup) {\n            return true;\n        }\n        const { predicates, type } = predicatesGroup;\n        return validatePredicate(record, type, predicates);\n    }\n    pushToBuffer(transformerMutationType, modelDefinition, data) {\n        this.buffer.push([transformerMutationType, modelDefinition, data]);\n    }\n    drainBuffer() {\n        if (this.dataObserver) {\n            this.buffer.forEach(data => this.dataObserver.next(data));\n            this.buffer = [];\n        }\n    }\n    /**\n     * @returns true if the service returned an RTF subscription error\n     * @remarks logs a warning with remediation instructions\n     *\n     */\n    catchRTFError(message, modelDefinition, predicatesGroup) {\n        const header = 'Backend subscriptions filtering error.\\n' +\n            'Subscriptions filtering will be applied clientside.\\n';\n        const messageErrorTypeMap = {\n            'UnknownArgument: Unknown field argument filter': RTFError.UnknownField,\n            'Filters exceed maximum attributes limit': RTFError.MaxAttributes,\n            'Filters combination exceed maximum limit': RTFError.MaxCombinations,\n            'filter uses same fieldName multiple time': RTFError.RepeatedFieldname,\n            \"The variables input contains a field name 'not'\": RTFError.NotGroup,\n            'The variables input contains a field that is not defined for input object type': RTFError.FieldNotInType,\n        };\n        const [_errorMsg, errorType] = Object.entries(messageErrorTypeMap).find(([errorMsg]) => message.includes(errorMsg)) || [];\n        if (errorType !== undefined) {\n            const remediationMessage = generateRTFRemediation(errorType, modelDefinition, predicatesGroup);\n            logger.warn(`${header}\\n${message}\\n${remediationMessage}`);\n            return true;\n        }\n        return false;\n    }\n}\nexport { SubscriptionProcessor };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}