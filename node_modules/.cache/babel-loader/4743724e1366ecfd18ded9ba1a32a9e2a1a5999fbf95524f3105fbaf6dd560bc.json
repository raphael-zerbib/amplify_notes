{"ast":null,"code":"import * as React from 'react';\nimport { isFunction } from '@aws-amplify/ui';\nconst getCorrectSteppingValue = _ref => {\n  let {\n    max,\n    min,\n    step,\n    value\n  } = _ref;\n  // Round it to the closest step value\n  // It will be based off min to be consistent with native input[type=\"number\"]\n  // This allows keyboard accessible\n  const remainder = (value - min) % step;\n  value = value - remainder + Math.round(remainder / step) * step;\n  // Make sure new value is not outside the bound\n  value = Math.max(min, value);\n  if (value > max) {\n    value = max - (max - min) % step;\n  }\n  return value;\n};\nconst useStepper = _ref2 => {\n  var _ref3, _ref4;\n  let {\n    defaultValue = 0,\n    value: controlledValue,\n    step = 1,\n    max = Number.MAX_SAFE_INTEGER,\n    min = Number.MIN_SAFE_INTEGER,\n    isDisabled,\n    isReadOnly,\n    onChange,\n    onDecrease,\n    onIncrease,\n    onStepChange\n  } = _ref2;\n  const isControlled = controlledValue !== undefined;\n  // Make sure max value is greater than or equal to min value\n  max = Math.max(min, max);\n  // Maintain an internal state for uncontrolled components\n  // This allows to take over the input value and correct any invalid versus purely relying on the native uncontrolled input\n  const [uncontrolledValue, setUncontrolledValue] = React.useState(() =>\n  // This is required for users could provide any defaultValue\n  getCorrectSteppingValue({\n    min,\n    max,\n    step,\n    value: defaultValue\n  }));\n  // Same for controlled components on the first render because users could provide invalid initial value.\n  // It seems redundant afterwards but necessary for the first render\n  const value = isControlled ? getCorrectSteppingValue({\n    min,\n    max,\n    step,\n    value: controlledValue\n  }) : uncontrolledValue;\n  const shouldDisableIncreaseButton = (_ref3 = isDisabled !== null && isDisabled !== void 0 ? isDisabled : isReadOnly) !== null && _ref3 !== void 0 ? _ref3 : value + step > max;\n  const shouldDisableDecreaseButton = (_ref4 = isDisabled !== null && isDisabled !== void 0 ? isDisabled : isReadOnly) !== null && _ref4 !== void 0 ? _ref4 : value - step < min;\n  // This is the exact value to be rendered on screen\n  // It could be a string, like '-' or empty string when users clear the input\n  const [inputValue, setInputValue] = React.useState(value);\n  const handleOnChange = React.useCallback(event => {\n    setInputValue(event.target.value);\n    if (isFunction(onChange)) {\n      onChange(event);\n    }\n  }, [onChange]);\n  const handleOnBlur = React.useCallback(event => {\n    const parsedValue = parseFloat(event.target.value);\n    // Though input[type='number'] has built-in validation to reject non-numerical entries\n    // The entered value could still be empty string or minus '-'\n    // in these cases, no need to do the following validation\n    if (isNaN(parsedValue)) {\n      return;\n    }\n    const newValue = getCorrectSteppingValue({\n      min,\n      max,\n      step,\n      value: parsedValue\n    });\n    if (!isControlled) {\n      setUncontrolledValue(newValue);\n    }\n    if (isFunction(onStepChange)) {\n      onStepChange(newValue);\n    }\n    setInputValue(newValue);\n  }, [min, max, step, isControlled, onStepChange]);\n  const handleIncrease = React.useCallback(() => {\n    // No need to check if the value will be outside the bounds\n    // The button will be disabled if so\n    if (!isControlled) {\n      setUncontrolledValue(value + step);\n    }\n    if (isFunction(onStepChange)) {\n      onStepChange(value + step);\n    }\n    if (isFunction(onIncrease)) {\n      onIncrease();\n    }\n    setInputValue(value + step);\n  }, [step, value, isControlled, onIncrease, onStepChange]);\n  const handleDecrease = React.useCallback(() => {\n    // No need to check if the value will be outside the bounds\n    // The button will be disabled if so\n    if (!isControlled) {\n      setUncontrolledValue(value - step);\n    }\n    if (isFunction(onStepChange)) {\n      onStepChange(value - step);\n    }\n    if (isFunction(onDecrease)) {\n      onDecrease();\n    }\n    setInputValue(value - step);\n  }, [step, value, isControlled, onDecrease, onStepChange]);\n  // This aims to disable unwanted behaviors on React input[type='number']\n  // When the input gets focused, rotating a wheel will change its value\n  // But the parent container(mostly the entire window) will be scrolling to elsewhere\n  const handleOnWheel = React.useCallback(event => {\n    event.currentTarget.blur();\n  }, []);\n  return {\n    step,\n    value,\n    inputValue,\n    handleDecrease,\n    handleIncrease,\n    handleOnBlur,\n    handleOnChange,\n    handleOnWheel,\n    setInputValue,\n    shouldDisableDecreaseButton,\n    shouldDisableIncreaseButton\n  };\n};\nexport { useStepper };","map":{"version":3,"names":["React","isFunction","getCorrectSteppingValue","_ref","max","min","step","value","remainder","Math","round","useStepper","_ref2","_ref3","_ref4","defaultValue","controlledValue","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","isDisabled","isReadOnly","onChange","onDecrease","onIncrease","onStepChange","isControlled","undefined","uncontrolledValue","setUncontrolledValue","useState","shouldDisableIncreaseButton","shouldDisableDecreaseButton","inputValue","setInputValue","handleOnChange","useCallback","event","target","handleOnBlur","parsedValue","parseFloat","isNaN","newValue","handleIncrease","handleDecrease","handleOnWheel","currentTarget","blur"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/ui-react/dist/esm/primitives/StepperField/useStepper.mjs"],"sourcesContent":["import * as React from 'react';\nimport { isFunction } from '@aws-amplify/ui';\n\nconst getCorrectSteppingValue = ({ max, min, step, value, }) => {\n    // Round it to the closest step value\n    // It will be based off min to be consistent with native input[type=\"number\"]\n    // This allows keyboard accessible\n    const remainder = (value - min) % step;\n    value = value - remainder + Math.round(remainder / step) * step;\n    // Make sure new value is not outside the bound\n    value = Math.max(min, value);\n    if (value > max) {\n        value = max - ((max - min) % step);\n    }\n    return value;\n};\nconst useStepper = ({ defaultValue = 0, value: controlledValue, step = 1, max = Number.MAX_SAFE_INTEGER, min = Number.MIN_SAFE_INTEGER, isDisabled, isReadOnly, onChange, onDecrease, onIncrease, onStepChange, }) => {\n    const isControlled = controlledValue !== undefined;\n    // Make sure max value is greater than or equal to min value\n    max = Math.max(min, max);\n    // Maintain an internal state for uncontrolled components\n    // This allows to take over the input value and correct any invalid versus purely relying on the native uncontrolled input\n    const [uncontrolledValue, setUncontrolledValue] = React.useState(() => \n    // This is required for users could provide any defaultValue\n    getCorrectSteppingValue({ min, max, step, value: defaultValue }));\n    // Same for controlled components on the first render because users could provide invalid initial value.\n    // It seems redundant afterwards but necessary for the first render\n    const value = isControlled\n        ? getCorrectSteppingValue({ min, max, step, value: controlledValue })\n        : uncontrolledValue;\n    const shouldDisableIncreaseButton = isDisabled ?? isReadOnly ?? value + step > max;\n    const shouldDisableDecreaseButton = isDisabled ?? isReadOnly ?? value - step < min;\n    // This is the exact value to be rendered on screen\n    // It could be a string, like '-' or empty string when users clear the input\n    const [inputValue, setInputValue] = React.useState(value);\n    const handleOnChange = React.useCallback((event) => {\n        setInputValue(event.target.value);\n        if (isFunction(onChange)) {\n            onChange(event);\n        }\n    }, [onChange]);\n    const handleOnBlur = React.useCallback((event) => {\n        const parsedValue = parseFloat(event.target.value);\n        // Though input[type='number'] has built-in validation to reject non-numerical entries\n        // The entered value could still be empty string or minus '-'\n        // in these cases, no need to do the following validation\n        if (isNaN(parsedValue)) {\n            return;\n        }\n        const newValue = getCorrectSteppingValue({\n            min,\n            max,\n            step,\n            value: parsedValue,\n        });\n        if (!isControlled) {\n            setUncontrolledValue(newValue);\n        }\n        if (isFunction(onStepChange)) {\n            onStepChange(newValue);\n        }\n        setInputValue(newValue);\n    }, [min, max, step, isControlled, onStepChange]);\n    const handleIncrease = React.useCallback(() => {\n        // No need to check if the value will be outside the bounds\n        // The button will be disabled if so\n        if (!isControlled) {\n            setUncontrolledValue(value + step);\n        }\n        if (isFunction(onStepChange)) {\n            onStepChange(value + step);\n        }\n        if (isFunction(onIncrease)) {\n            onIncrease();\n        }\n        setInputValue(value + step);\n    }, [step, value, isControlled, onIncrease, onStepChange]);\n    const handleDecrease = React.useCallback(() => {\n        // No need to check if the value will be outside the bounds\n        // The button will be disabled if so\n        if (!isControlled) {\n            setUncontrolledValue(value - step);\n        }\n        if (isFunction(onStepChange)) {\n            onStepChange(value - step);\n        }\n        if (isFunction(onDecrease)) {\n            onDecrease();\n        }\n        setInputValue(value - step);\n    }, [step, value, isControlled, onDecrease, onStepChange]);\n    // This aims to disable unwanted behaviors on React input[type='number']\n    // When the input gets focused, rotating a wheel will change its value\n    // But the parent container(mostly the entire window) will be scrolling to elsewhere\n    const handleOnWheel = React.useCallback((event) => {\n        event.currentTarget.blur();\n    }, []);\n    return {\n        step,\n        value,\n        inputValue,\n        handleDecrease,\n        handleIncrease,\n        handleOnBlur,\n        handleOnChange,\n        handleOnWheel,\n        setInputValue,\n        shouldDisableDecreaseButton,\n        shouldDisableIncreaseButton,\n    };\n};\n\nexport { useStepper };\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,UAAU,QAAQ,iBAAiB;AAE5C,MAAMC,uBAAuB,GAAGC,IAAA,IAAgC;EAAA,IAA/B;IAAEC,GAAG;IAAEC,GAAG;IAAEC,IAAI;IAAEC;EAAO,CAAC,GAAAJ,IAAA;EACvD;EACA;EACA;EACA,MAAMK,SAAS,GAAG,CAACD,KAAK,GAAGF,GAAG,IAAIC,IAAI;EACtCC,KAAK,GAAGA,KAAK,GAAGC,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACF,SAAS,GAAGF,IAAI,CAAC,GAAGA,IAAI;EAC/D;EACAC,KAAK,GAAGE,IAAI,CAACL,GAAG,CAACC,GAAG,EAAEE,KAAK,CAAC;EAC5B,IAAIA,KAAK,GAAGH,GAAG,EAAE;IACbG,KAAK,GAAGH,GAAG,GAAI,CAACA,GAAG,GAAGC,GAAG,IAAIC,IAAK;EACtC;EACA,OAAOC,KAAK;AAChB,CAAC;AACD,MAAMI,UAAU,GAAGC,KAAA,IAAmM;EAAA,IAAAC,KAAA,EAAAC,KAAA;EAAA,IAAlM;IAAEC,YAAY,GAAG,CAAC;IAAER,KAAK,EAAES,eAAe;IAAEV,IAAI,GAAG,CAAC;IAAEF,GAAG,GAAGa,MAAM,CAACC,gBAAgB;IAAEb,GAAG,GAAGY,MAAM,CAACE,gBAAgB;IAAEC,UAAU;IAAEC,UAAU;IAAEC,QAAQ;IAAEC,UAAU;IAAEC,UAAU;IAAEC;EAAc,CAAC,GAAAb,KAAA;EAC7M,MAAMc,YAAY,GAAGV,eAAe,KAAKW,SAAS;EAClD;EACAvB,GAAG,GAAGK,IAAI,CAACL,GAAG,CAACC,GAAG,EAAED,GAAG,CAAC;EACxB;EACA;EACA,MAAM,CAACwB,iBAAiB,EAAEC,oBAAoB,CAAC,GAAG7B,KAAK,CAAC8B,QAAQ,CAAC;EACjE;EACA5B,uBAAuB,CAAC;IAAEG,GAAG;IAAED,GAAG;IAAEE,IAAI;IAAEC,KAAK,EAAEQ;EAAa,CAAC,CAAC,CAAC;EACjE;EACA;EACA,MAAMR,KAAK,GAAGmB,YAAY,GACpBxB,uBAAuB,CAAC;IAAEG,GAAG;IAAED,GAAG;IAAEE,IAAI;IAAEC,KAAK,EAAES;EAAgB,CAAC,CAAC,GACnEY,iBAAiB;EACvB,MAAMG,2BAA2B,IAAAlB,KAAA,GAAGO,UAAU,aAAVA,UAAU,cAAVA,UAAU,GAAIC,UAAU,cAAAR,KAAA,cAAAA,KAAA,GAAIN,KAAK,GAAGD,IAAI,GAAGF,GAAG;EAClF,MAAM4B,2BAA2B,IAAAlB,KAAA,GAAGM,UAAU,aAAVA,UAAU,cAAVA,UAAU,GAAIC,UAAU,cAAAP,KAAA,cAAAA,KAAA,GAAIP,KAAK,GAAGD,IAAI,GAAGD,GAAG;EAClF;EACA;EACA,MAAM,CAAC4B,UAAU,EAAEC,aAAa,CAAC,GAAGlC,KAAK,CAAC8B,QAAQ,CAACvB,KAAK,CAAC;EACzD,MAAM4B,cAAc,GAAGnC,KAAK,CAACoC,WAAW,CAAEC,KAAK,IAAK;IAChDH,aAAa,CAACG,KAAK,CAACC,MAAM,CAAC/B,KAAK,CAAC;IACjC,IAAIN,UAAU,CAACqB,QAAQ,CAAC,EAAE;MACtBA,QAAQ,CAACe,KAAK,CAAC;IACnB;EACJ,CAAC,EAAE,CAACf,QAAQ,CAAC,CAAC;EACd,MAAMiB,YAAY,GAAGvC,KAAK,CAACoC,WAAW,CAAEC,KAAK,IAAK;IAC9C,MAAMG,WAAW,GAAGC,UAAU,CAACJ,KAAK,CAACC,MAAM,CAAC/B,KAAK,CAAC;IAClD;IACA;IACA;IACA,IAAImC,KAAK,CAACF,WAAW,CAAC,EAAE;MACpB;IACJ;IACA,MAAMG,QAAQ,GAAGzC,uBAAuB,CAAC;MACrCG,GAAG;MACHD,GAAG;MACHE,IAAI;MACJC,KAAK,EAAEiC;IACX,CAAC,CAAC;IACF,IAAI,CAACd,YAAY,EAAE;MACfG,oBAAoB,CAACc,QAAQ,CAAC;IAClC;IACA,IAAI1C,UAAU,CAACwB,YAAY,CAAC,EAAE;MAC1BA,YAAY,CAACkB,QAAQ,CAAC;IAC1B;IACAT,aAAa,CAACS,QAAQ,CAAC;EAC3B,CAAC,EAAE,CAACtC,GAAG,EAAED,GAAG,EAAEE,IAAI,EAAEoB,YAAY,EAAED,YAAY,CAAC,CAAC;EAChD,MAAMmB,cAAc,GAAG5C,KAAK,CAACoC,WAAW,CAAC,MAAM;IAC3C;IACA;IACA,IAAI,CAACV,YAAY,EAAE;MACfG,oBAAoB,CAACtB,KAAK,GAAGD,IAAI,CAAC;IACtC;IACA,IAAIL,UAAU,CAACwB,YAAY,CAAC,EAAE;MAC1BA,YAAY,CAAClB,KAAK,GAAGD,IAAI,CAAC;IAC9B;IACA,IAAIL,UAAU,CAACuB,UAAU,CAAC,EAAE;MACxBA,UAAU,CAAC,CAAC;IAChB;IACAU,aAAa,CAAC3B,KAAK,GAAGD,IAAI,CAAC;EAC/B,CAAC,EAAE,CAACA,IAAI,EAAEC,KAAK,EAAEmB,YAAY,EAAEF,UAAU,EAAEC,YAAY,CAAC,CAAC;EACzD,MAAMoB,cAAc,GAAG7C,KAAK,CAACoC,WAAW,CAAC,MAAM;IAC3C;IACA;IACA,IAAI,CAACV,YAAY,EAAE;MACfG,oBAAoB,CAACtB,KAAK,GAAGD,IAAI,CAAC;IACtC;IACA,IAAIL,UAAU,CAACwB,YAAY,CAAC,EAAE;MAC1BA,YAAY,CAAClB,KAAK,GAAGD,IAAI,CAAC;IAC9B;IACA,IAAIL,UAAU,CAACsB,UAAU,CAAC,EAAE;MACxBA,UAAU,CAAC,CAAC;IAChB;IACAW,aAAa,CAAC3B,KAAK,GAAGD,IAAI,CAAC;EAC/B,CAAC,EAAE,CAACA,IAAI,EAAEC,KAAK,EAAEmB,YAAY,EAAEH,UAAU,EAAEE,YAAY,CAAC,CAAC;EACzD;EACA;EACA;EACA,MAAMqB,aAAa,GAAG9C,KAAK,CAACoC,WAAW,CAAEC,KAAK,IAAK;IAC/CA,KAAK,CAACU,aAAa,CAACC,IAAI,CAAC,CAAC;EAC9B,CAAC,EAAE,EAAE,CAAC;EACN,OAAO;IACH1C,IAAI;IACJC,KAAK;IACL0B,UAAU;IACVY,cAAc;IACdD,cAAc;IACdL,YAAY;IACZJ,cAAc;IACdW,aAAa;IACbZ,aAAa;IACbF,2BAA2B;IAC3BD;EACJ,CAAC;AACL,CAAC;AAED,SAASpB,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}