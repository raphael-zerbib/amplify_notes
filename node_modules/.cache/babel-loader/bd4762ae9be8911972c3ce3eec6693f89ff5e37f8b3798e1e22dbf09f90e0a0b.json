{"ast":null,"code":"import { resolveServiceErrorStatusCode } from '../utils.mjs';\nconst connectionTimeout = error => /^Connection failed: Connection Timeout/.test(error.message);\nconst serverError = error => resolveServiceErrorStatusCode(error) >= 500;\nconst mutationErrorMap = {\n  BadModel: () => false,\n  BadRecord: error => {\n    const {\n      message\n    } = error;\n    return /^Cannot return \\w+ for [\\w-_]+ type/.test(message) || /^Variable '.+' has coerced Null value for NonNull type/.test(message); // newly required field, out of date client\n  },\n  ConfigError: () => false,\n  Transient: error => connectionTimeout(error) || serverError(error),\n  Unauthorized: error => error.message === 'Unauthorized' || resolveServiceErrorStatusCode(error) === 401\n};\nconst subscriptionErrorMap = {\n  BadModel: () => false,\n  BadRecord: () => false,\n  ConfigError: () => false,\n  Transient: observableError => {\n    const error = unwrapObservableError(observableError);\n    return connectionTimeout(error) || serverError(error);\n  },\n  Unauthorized: observableError => {\n    const error = unwrapObservableError(observableError);\n    return /Connection failed.+Unauthorized/.test(error.message);\n  }\n};\nconst syncErrorMap = {\n  BadModel: () => false,\n  BadRecord: error => /^Cannot return \\w+ for [\\w-_]+ type/.test(error.message),\n  ConfigError: () => false,\n  Transient: error => connectionTimeout(error) || serverError(error),\n  Unauthorized: error => error.errorType === 'Unauthorized'\n};\n/**\n * Get the first error reason of an observable.\n * Allows for error maps to be easily applied to observable errors\n *\n * @param observableError an error from ZenObservable subscribe error callback\n */\nfunction unwrapObservableError(observableError) {\n  const {\n    errors: [error]\n  } = observableError;\n  return error;\n}\nfunction getMutationErrorType(error) {\n  return mapErrorToType(mutationErrorMap, error);\n}\nfunction getSubscriptionErrorType(error) {\n  return mapErrorToType(subscriptionErrorMap, error);\n}\nfunction getSyncErrorType(error) {\n  return mapErrorToType(syncErrorMap, error);\n}\n/**\n * Categorizes an error with a broad error type, intended to make\n * customer error handling code simpler.\n * @param errorMap Error names and a list of patterns that indicate them (each pattern as a regex or function)\n * @param error The underying error to categorize.\n */\nfunction mapErrorToType(errorMap, error) {\n  const errorTypes = [...Object.keys(errorMap)];\n  for (const errorType of errorTypes) {\n    const matcher = errorMap[errorType];\n    if (matcher?.(error)) {\n      return errorType;\n    }\n  }\n  return 'Unknown';\n}\nexport { getMutationErrorType, getSubscriptionErrorType, getSyncErrorType, mapErrorToType, mutationErrorMap, subscriptionErrorMap, syncErrorMap };","map":{"version":3,"names":["connectionTimeout","error","test","message","serverError","resolveServiceErrorStatusCode","mutationErrorMap","BadModel","BadRecord","ConfigError","Transient","Unauthorized","subscriptionErrorMap","observableError","unwrapObservableError","syncErrorMap","errorType","errors","getMutationErrorType","mapErrorToType","getSubscriptionErrorType","getSyncErrorType","errorMap","errorTypes","Object","keys","matcher"],"sources":["/Users/raphaperso/Documents/Hub/FreeCodeCamp/amplify_notes/node_modules/@aws-amplify/datastore/src/sync/processors/errorMaps.ts"],"sourcesContent":["import { resolveServiceErrorStatusCode } from '../utils';\nconst connectionTimeout = error => /^Connection failed: Connection Timeout/.test(error.message);\nconst serverError = error => resolveServiceErrorStatusCode(error) >= 500;\nexport const mutationErrorMap = {\n    BadModel: () => false,\n    BadRecord: error => {\n        const { message } = error;\n        return (/^Cannot return \\w+ for [\\w-_]+ type/.test(message) ||\n            /^Variable '.+' has coerced Null value for NonNull type/.test(message)); // newly required field, out of date client\n    },\n    ConfigError: () => false,\n    Transient: error => connectionTimeout(error) || serverError(error),\n    Unauthorized: error => error.message === 'Unauthorized' ||\n        resolveServiceErrorStatusCode(error) === 401,\n};\nexport const subscriptionErrorMap = {\n    BadModel: () => false,\n    BadRecord: () => false,\n    ConfigError: () => false,\n    Transient: observableError => {\n        const error = unwrapObservableError(observableError);\n        return connectionTimeout(error) || serverError(error);\n    },\n    Unauthorized: observableError => {\n        const error = unwrapObservableError(observableError);\n        return /Connection failed.+Unauthorized/.test(error.message);\n    },\n};\nexport const syncErrorMap = {\n    BadModel: () => false,\n    BadRecord: error => /^Cannot return \\w+ for [\\w-_]+ type/.test(error.message),\n    ConfigError: () => false,\n    Transient: error => connectionTimeout(error) || serverError(error),\n    Unauthorized: error => error.errorType === 'Unauthorized',\n};\n/**\n * Get the first error reason of an observable.\n * Allows for error maps to be easily applied to observable errors\n *\n * @param observableError an error from ZenObservable subscribe error callback\n */\nfunction unwrapObservableError(observableError) {\n    const { errors: [error], } = ({\n        errors: [],\n    } = observableError);\n    return error;\n}\nexport function getMutationErrorType(error) {\n    return mapErrorToType(mutationErrorMap, error);\n}\nexport function getSubscriptionErrorType(error) {\n    return mapErrorToType(subscriptionErrorMap, error);\n}\nexport function getSyncErrorType(error) {\n    return mapErrorToType(syncErrorMap, error);\n}\n/**\n * Categorizes an error with a broad error type, intended to make\n * customer error handling code simpler.\n * @param errorMap Error names and a list of patterns that indicate them (each pattern as a regex or function)\n * @param error The underying error to categorize.\n */\nexport function mapErrorToType(errorMap, error) {\n    const errorTypes = [...Object.keys(errorMap)];\n    for (const errorType of errorTypes) {\n        const matcher = errorMap[errorType];\n        if (matcher?.(error)) {\n            return errorType;\n        }\n    }\n    return 'Unknown';\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}