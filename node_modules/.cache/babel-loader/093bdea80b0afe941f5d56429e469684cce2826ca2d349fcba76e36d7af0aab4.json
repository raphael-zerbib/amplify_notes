{"ast":null,"code":"import { Amplify } from '@aws-amplify/core';\nimport { AuthAction, assertTokenProviderConfig, AmplifyUrl, base64Encoder } from '@aws-amplify/core/internals/utils';\nimport { AuthError } from '../../../errors/AuthError.mjs';\nimport { InitiateAuthException } from '../types/errors.mjs';\nimport { AuthErrorCodes } from '../../../common/AuthErrorStrings.mjs';\nimport { AuthValidationErrorCode } from '../../../errors/types/validation.mjs';\nimport { assertValidationError } from '../../../errors/utils/assertValidationError.mjs';\nimport { USER_ALREADY_AUTHENTICATED_EXCEPTION } from '../../../errors/constants.mjs';\nimport { getCurrentUser } from '../apis/getCurrentUser.mjs';\nimport { getAuthUserAgentValue } from '../../../utils/getAuthUserAgentValue.mjs';\nimport { signInStore } from './signInStore.mjs';\nimport { respondToAuthChallenge, verifySoftwareToken, initiateAuth, associateSoftwareToken, confirmDevice } from './clients/CognitoIdentityProvider/index.mjs';\nimport { getRegion } from './clients/CognitoIdentityProvider/utils.mjs';\nimport { assertDeviceMetadata } from './types.mjs';\nimport { getAuthenticationHelper } from './srp/getAuthenticationHelper.mjs';\nimport { getBytesFromHex } from './srp/getBytesFromHex.mjs';\nimport { getNowString } from './srp/getNowString.mjs';\nimport { getSignatureString } from './srp/getSignatureString.mjs';\nimport BigInteger from './srp/BigInteger/BigInteger.mjs';\nimport { getUserContextData } from './userContextData.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst USER_ATTRIBUTES = 'userAttributes.';\nasync function handleCustomChallenge(_ref) {\n  let {\n    challengeResponse,\n    clientMetadata,\n    session,\n    username,\n    config,\n    tokenOrchestrator\n  } = _ref;\n  const {\n    userPoolId,\n    userPoolClientId\n  } = config;\n  const challengeResponses = {\n    USERNAME: username,\n    ANSWER: challengeResponse\n  };\n  const deviceMetadata = await (tokenOrchestrator === null || tokenOrchestrator === void 0 ? void 0 : tokenOrchestrator.getDeviceMetadata(username));\n  if (deviceMetadata && deviceMetadata.deviceKey) {\n    challengeResponses.DEVICE_KEY = deviceMetadata.deviceKey;\n  }\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    ChallengeName: 'CUSTOM_CHALLENGE',\n    ChallengeResponses: challengeResponses,\n    Session: session,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  const response = await respondToAuthChallenge({\n    region: getRegion(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n  }, jsonReq);\n  if (response.ChallengeName === 'DEVICE_SRP_AUTH') {\n    return handleDeviceSRPAuth({\n      username,\n      config,\n      clientMetadata,\n      session: response.Session,\n      tokenOrchestrator\n    });\n  }\n  return response;\n}\nasync function handleMFASetupChallenge(_ref2) {\n  let {\n    challengeResponse,\n    username,\n    clientMetadata,\n    session,\n    deviceName,\n    config\n  } = _ref2;\n  const {\n    userPoolId,\n    userPoolClientId\n  } = config;\n  const challengeResponses = {\n    USERNAME: username\n  };\n  const {\n    Session\n  } = await verifySoftwareToken({\n    region: getRegion(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n  }, {\n    UserCode: challengeResponse,\n    Session: session,\n    FriendlyDeviceName: deviceName\n  });\n  signInStore.dispatch({\n    type: 'SET_SIGN_IN_SESSION',\n    value: Session\n  });\n  const jsonReq = {\n    ChallengeName: 'MFA_SETUP',\n    ChallengeResponses: challengeResponses,\n    Session,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId\n  };\n  return respondToAuthChallenge({\n    region: getRegion(userPoolId)\n  }, jsonReq);\n}\nasync function handleSelectMFATypeChallenge(_ref3) {\n  let {\n    challengeResponse,\n    username,\n    clientMetadata,\n    session,\n    config\n  } = _ref3;\n  const {\n    userPoolId,\n    userPoolClientId\n  } = config;\n  assertValidationError(challengeResponse === 'TOTP' || challengeResponse === 'SMS', AuthValidationErrorCode.IncorrectMFAMethod);\n  const challengeResponses = {\n    USERNAME: username,\n    ANSWER: mapMfaType(challengeResponse)\n  };\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    ChallengeName: 'SELECT_MFA_TYPE',\n    ChallengeResponses: challengeResponses,\n    Session: session,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  return respondToAuthChallenge({\n    region: getRegion(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n  }, jsonReq);\n}\nasync function handleSMSMFAChallenge(_ref4) {\n  let {\n    challengeResponse,\n    clientMetadata,\n    session,\n    username,\n    config\n  } = _ref4;\n  const {\n    userPoolId,\n    userPoolClientId\n  } = config;\n  const challengeResponses = {\n    USERNAME: username,\n    SMS_MFA_CODE: challengeResponse\n  };\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    ChallengeName: 'SMS_MFA',\n    ChallengeResponses: challengeResponses,\n    Session: session,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  return respondToAuthChallenge({\n    region: getRegion(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n  }, jsonReq);\n}\nasync function handleSoftwareTokenMFAChallenge(_ref5) {\n  let {\n    challengeResponse,\n    clientMetadata,\n    session,\n    username,\n    config\n  } = _ref5;\n  const {\n    userPoolId,\n    userPoolClientId\n  } = config;\n  const challengeResponses = {\n    USERNAME: username,\n    SOFTWARE_TOKEN_MFA_CODE: challengeResponse\n  };\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    ChallengeName: 'SOFTWARE_TOKEN_MFA',\n    ChallengeResponses: challengeResponses,\n    Session: session,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  return respondToAuthChallenge({\n    region: getRegion(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n  }, jsonReq);\n}\nasync function handleCompleteNewPasswordChallenge(_ref6) {\n  let {\n    challengeResponse,\n    clientMetadata,\n    session,\n    username,\n    requiredAttributes,\n    config\n  } = _ref6;\n  const {\n    userPoolId,\n    userPoolClientId\n  } = config;\n  const challengeResponses = {\n    ...createAttributes(requiredAttributes),\n    NEW_PASSWORD: challengeResponse,\n    USERNAME: username\n  };\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    ChallengeName: 'NEW_PASSWORD_REQUIRED',\n    ChallengeResponses: challengeResponses,\n    ClientMetadata: clientMetadata,\n    Session: session,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  return respondToAuthChallenge({\n    region: getRegion(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n  }, jsonReq);\n}\nasync function handleUserPasswordAuthFlow(username, password, clientMetadata, config, tokenOrchestrator) {\n  var _ref7, _response$ChallengePa, _response$ChallengePa2, _response$ChallengePa3;\n  const {\n    userPoolClientId,\n    userPoolId\n  } = config;\n  const authParameters = {\n    USERNAME: username,\n    PASSWORD: password\n  };\n  const deviceMetadata = await tokenOrchestrator.getDeviceMetadata(username);\n  if (deviceMetadata && deviceMetadata.deviceKey) {\n    authParameters.DEVICE_KEY = deviceMetadata.deviceKey;\n  }\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    AuthFlow: 'USER_PASSWORD_AUTH',\n    AuthParameters: authParameters,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  const response = await initiateAuth({\n    region: getRegion(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.SignIn)\n  }, jsonReq);\n  const activeUsername = (_ref7 = (_response$ChallengePa = (_response$ChallengePa2 = response.ChallengeParameters) === null || _response$ChallengePa2 === void 0 ? void 0 : _response$ChallengePa2.USERNAME) !== null && _response$ChallengePa !== void 0 ? _response$ChallengePa : (_response$ChallengePa3 = response.ChallengeParameters) === null || _response$ChallengePa3 === void 0 ? void 0 : _response$ChallengePa3.USER_ID_FOR_SRP) !== null && _ref7 !== void 0 ? _ref7 : username;\n  setActiveSignInUsername(activeUsername);\n  if (response.ChallengeName === 'DEVICE_SRP_AUTH') return handleDeviceSRPAuth({\n    username: activeUsername,\n    config,\n    clientMetadata,\n    session: response.Session,\n    tokenOrchestrator\n  });\n  return response;\n}\nasync function handleUserSRPAuthFlow(username, password, clientMetadata, config, tokenOrchestrator) {\n  var _challengeParameters$;\n  const {\n    userPoolId,\n    userPoolClientId\n  } = config;\n  const userPoolName = (userPoolId === null || userPoolId === void 0 ? void 0 : userPoolId.split('_')[1]) || '';\n  const authenticationHelper = await getAuthenticationHelper(userPoolName);\n  const authParameters = {\n    USERNAME: username,\n    SRP_A: authenticationHelper.A.toString(16)\n  };\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    AuthFlow: 'USER_SRP_AUTH',\n    AuthParameters: authParameters,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  const resp = await initiateAuth({\n    region: getRegion(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.SignIn)\n  }, jsonReq);\n  const {\n    ChallengeParameters: challengeParameters,\n    Session: session\n  } = resp;\n  const activeUsername = (_challengeParameters$ = challengeParameters === null || challengeParameters === void 0 ? void 0 : challengeParameters.USERNAME) !== null && _challengeParameters$ !== void 0 ? _challengeParameters$ : username;\n  setActiveSignInUsername(activeUsername);\n  return retryOnResourceNotFoundException(handlePasswordVerifierChallenge, [password, challengeParameters, clientMetadata, session, authenticationHelper, config, tokenOrchestrator], activeUsername, tokenOrchestrator);\n}\nasync function handleCustomAuthFlowWithoutSRP(username, clientMetadata, config, tokenOrchestrator) {\n  var _response$ChallengePa4, _response$ChallengePa5;\n  const {\n    userPoolClientId,\n    userPoolId\n  } = config;\n  const authParameters = {\n    USERNAME: username\n  };\n  const deviceMetadata = await tokenOrchestrator.getDeviceMetadata(username);\n  if (deviceMetadata && deviceMetadata.deviceKey) {\n    authParameters.DEVICE_KEY = deviceMetadata.deviceKey;\n  }\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    AuthFlow: 'CUSTOM_AUTH',\n    AuthParameters: authParameters,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  const response = await initiateAuth({\n    region: getRegion(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.SignIn)\n  }, jsonReq);\n  const activeUsername = (_response$ChallengePa4 = (_response$ChallengePa5 = response.ChallengeParameters) === null || _response$ChallengePa5 === void 0 ? void 0 : _response$ChallengePa5.USERNAME) !== null && _response$ChallengePa4 !== void 0 ? _response$ChallengePa4 : username;\n  setActiveSignInUsername(activeUsername);\n  if (response.ChallengeName === 'DEVICE_SRP_AUTH') return handleDeviceSRPAuth({\n    username: activeUsername,\n    config,\n    clientMetadata,\n    session: response.Session,\n    tokenOrchestrator\n  });\n  return response;\n}\nasync function handleCustomSRPAuthFlow(username, password, clientMetadata, config, tokenOrchestrator) {\n  var _challengeParameters$2;\n  assertTokenProviderConfig(config);\n  const {\n    userPoolId,\n    userPoolClientId\n  } = config;\n  const userPoolName = (userPoolId === null || userPoolId === void 0 ? void 0 : userPoolId.split('_')[1]) || '';\n  const authenticationHelper = await getAuthenticationHelper(userPoolName);\n  const authParameters = {\n    USERNAME: username,\n    SRP_A: authenticationHelper.A.toString(16),\n    CHALLENGE_NAME: 'SRP_A'\n  };\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    AuthFlow: 'CUSTOM_AUTH',\n    AuthParameters: authParameters,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  const {\n    ChallengeParameters: challengeParameters,\n    Session: session\n  } = await initiateAuth({\n    region: getRegion(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.SignIn)\n  }, jsonReq);\n  const activeUsername = (_challengeParameters$2 = challengeParameters === null || challengeParameters === void 0 ? void 0 : challengeParameters.USERNAME) !== null && _challengeParameters$2 !== void 0 ? _challengeParameters$2 : username;\n  setActiveSignInUsername(activeUsername);\n  return retryOnResourceNotFoundException(handlePasswordVerifierChallenge, [password, challengeParameters, clientMetadata, session, authenticationHelper, config, tokenOrchestrator], activeUsername, tokenOrchestrator);\n}\nasync function handleDeviceSRPAuth(_ref8) {\n  let {\n    username,\n    config,\n    clientMetadata,\n    session,\n    tokenOrchestrator\n  } = _ref8;\n  const {\n    userPoolId\n  } = config;\n  const clientId = config.userPoolClientId;\n  const deviceMetadata = await (tokenOrchestrator === null || tokenOrchestrator === void 0 ? void 0 : tokenOrchestrator.getDeviceMetadata(username));\n  assertDeviceMetadata(deviceMetadata);\n  const authenticationHelper = await getAuthenticationHelper(deviceMetadata.deviceGroupKey);\n  const challengeResponses = {\n    USERNAME: username,\n    SRP_A: authenticationHelper.A.toString(16),\n    DEVICE_KEY: deviceMetadata.deviceKey\n  };\n  const jsonReqResponseChallenge = {\n    ChallengeName: 'DEVICE_SRP_AUTH',\n    ClientId: clientId,\n    ChallengeResponses: challengeResponses,\n    ClientMetadata: clientMetadata,\n    Session: session\n  };\n  const {\n    ChallengeParameters: respondedChallengeParameters,\n    Session\n  } = await respondToAuthChallenge({\n    region: getRegion(userPoolId)\n  }, jsonReqResponseChallenge);\n  return handleDevicePasswordVerifier(username, respondedChallengeParameters, clientMetadata, Session, authenticationHelper, config, tokenOrchestrator);\n}\nasync function handleDevicePasswordVerifier(username, challengeParameters, clientMetadata, session, authenticationHelper, _ref9, tokenOrchestrator) {\n  var _challengeParameters$3;\n  let {\n    userPoolId,\n    userPoolClientId\n  } = _ref9;\n  const deviceMetadata = await (tokenOrchestrator === null || tokenOrchestrator === void 0 ? void 0 : tokenOrchestrator.getDeviceMetadata(username));\n  assertDeviceMetadata(deviceMetadata);\n  const serverBValue = new BigInteger(challengeParameters === null || challengeParameters === void 0 ? void 0 : challengeParameters.SRP_B, 16);\n  const salt = new BigInteger(challengeParameters === null || challengeParameters === void 0 ? void 0 : challengeParameters.SALT, 16);\n  const {\n    deviceKey\n  } = deviceMetadata;\n  const {\n    deviceGroupKey\n  } = deviceMetadata;\n  const hkdf = await authenticationHelper.getPasswordAuthenticationKey({\n    username: deviceMetadata.deviceKey,\n    password: deviceMetadata.randomPassword,\n    serverBValue,\n    salt\n  });\n  const dateNow = getNowString();\n  const challengeResponses = {\n    USERNAME: (_challengeParameters$3 = challengeParameters === null || challengeParameters === void 0 ? void 0 : challengeParameters.USERNAME) !== null && _challengeParameters$3 !== void 0 ? _challengeParameters$3 : username,\n    PASSWORD_CLAIM_SECRET_BLOCK: challengeParameters === null || challengeParameters === void 0 ? void 0 : challengeParameters.SECRET_BLOCK,\n    TIMESTAMP: dateNow,\n    PASSWORD_CLAIM_SIGNATURE: getSignatureString({\n      username: deviceKey,\n      userPoolName: deviceGroupKey,\n      challengeParameters,\n      dateNow,\n      hkdf\n    }),\n    DEVICE_KEY: deviceKey\n  };\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReqResponseChallenge = {\n    ChallengeName: 'DEVICE_PASSWORD_VERIFIER',\n    ClientId: userPoolClientId,\n    ChallengeResponses: challengeResponses,\n    Session: session,\n    ClientMetadata: clientMetadata,\n    UserContextData\n  };\n  return respondToAuthChallenge({\n    region: getRegion(userPoolId)\n  }, jsonReqResponseChallenge);\n}\nasync function handlePasswordVerifierChallenge(password, challengeParameters, clientMetadata, session, authenticationHelper, config, tokenOrchestrator) {\n  const {\n    userPoolId,\n    userPoolClientId\n  } = config;\n  const userPoolName = (userPoolId === null || userPoolId === void 0 ? void 0 : userPoolId.split('_')[1]) || '';\n  const serverBValue = new BigInteger(challengeParameters === null || challengeParameters === void 0 ? void 0 : challengeParameters.SRP_B, 16);\n  const salt = new BigInteger(challengeParameters === null || challengeParameters === void 0 ? void 0 : challengeParameters.SALT, 16);\n  const username = challengeParameters === null || challengeParameters === void 0 ? void 0 : challengeParameters.USER_ID_FOR_SRP;\n  if (!username) throw new AuthError({\n    name: 'EmptyUserIdForSRPException',\n    message: 'USER_ID_FOR_SRP was not found in challengeParameters'\n  });\n  const hkdf = await authenticationHelper.getPasswordAuthenticationKey({\n    username,\n    password,\n    serverBValue,\n    salt\n  });\n  const dateNow = getNowString();\n  const challengeResponses = {\n    USERNAME: username,\n    PASSWORD_CLAIM_SECRET_BLOCK: challengeParameters === null || challengeParameters === void 0 ? void 0 : challengeParameters.SECRET_BLOCK,\n    TIMESTAMP: dateNow,\n    PASSWORD_CLAIM_SIGNATURE: getSignatureString({\n      username,\n      userPoolName,\n      challengeParameters,\n      dateNow,\n      hkdf\n    })\n  };\n  const deviceMetadata = await tokenOrchestrator.getDeviceMetadata(username);\n  if (deviceMetadata && deviceMetadata.deviceKey) {\n    challengeResponses.DEVICE_KEY = deviceMetadata.deviceKey;\n  }\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReqResponseChallenge = {\n    ChallengeName: 'PASSWORD_VERIFIER',\n    ChallengeResponses: challengeResponses,\n    ClientMetadata: clientMetadata,\n    Session: session,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  const response = await respondToAuthChallenge({\n    region: getRegion(userPoolId)\n  }, jsonReqResponseChallenge);\n  if (response.ChallengeName === 'DEVICE_SRP_AUTH') return handleDeviceSRPAuth({\n    username,\n    config,\n    clientMetadata,\n    session: response.Session,\n    tokenOrchestrator\n  });\n  return response;\n}\nasync function getSignInResult(params) {\n  var _Amplify$getConfig$Au;\n  const {\n    challengeName,\n    challengeParameters\n  } = params;\n  const authConfig = (_Amplify$getConfig$Au = Amplify.getConfig().Auth) === null || _Amplify$getConfig$Au === void 0 ? void 0 : _Amplify$getConfig$Au.Cognito;\n  assertTokenProviderConfig(authConfig);\n  switch (challengeName) {\n    case 'CUSTOM_CHALLENGE':\n      return {\n        isSignedIn: false,\n        nextStep: {\n          signInStep: 'CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE',\n          additionalInfo: challengeParameters\n        }\n      };\n    case 'MFA_SETUP':\n      {\n        const {\n          signInSession,\n          username\n        } = signInStore.getState();\n        if (!isMFATypeEnabled(challengeParameters, 'TOTP')) throw new AuthError({\n          name: AuthErrorCodes.SignInException,\n          message: \"Cannot initiate MFA setup from available types: \".concat(getMFATypes(parseMFATypes(challengeParameters.MFAS_CAN_SETUP)))\n        });\n        const {\n          Session,\n          SecretCode: secretCode\n        } = await associateSoftwareToken({\n          region: getRegion(authConfig.userPoolId)\n        }, {\n          Session: signInSession\n        });\n        signInStore.dispatch({\n          type: 'SET_SIGN_IN_SESSION',\n          value: Session\n        });\n        return {\n          isSignedIn: false,\n          nextStep: {\n            signInStep: 'CONTINUE_SIGN_IN_WITH_TOTP_SETUP',\n            totpSetupDetails: getTOTPSetupDetails(secretCode, username)\n          }\n        };\n      }\n    case 'NEW_PASSWORD_REQUIRED':\n      return {\n        isSignedIn: false,\n        nextStep: {\n          signInStep: 'CONFIRM_SIGN_IN_WITH_NEW_PASSWORD_REQUIRED',\n          missingAttributes: parseAttributes(challengeParameters.requiredAttributes)\n        }\n      };\n    case 'SELECT_MFA_TYPE':\n      return {\n        isSignedIn: false,\n        nextStep: {\n          signInStep: 'CONTINUE_SIGN_IN_WITH_MFA_SELECTION',\n          allowedMFATypes: getMFATypes(parseMFATypes(challengeParameters.MFAS_CAN_CHOOSE))\n        }\n      };\n    case 'SMS_MFA':\n      return {\n        isSignedIn: false,\n        nextStep: {\n          signInStep: 'CONFIRM_SIGN_IN_WITH_SMS_CODE',\n          codeDeliveryDetails: {\n            deliveryMedium: challengeParameters.CODE_DELIVERY_DELIVERY_MEDIUM,\n            destination: challengeParameters.CODE_DELIVERY_DESTINATION\n          }\n        }\n      };\n    case 'SOFTWARE_TOKEN_MFA':\n      return {\n        isSignedIn: false,\n        nextStep: {\n          signInStep: 'CONFIRM_SIGN_IN_WITH_TOTP_CODE'\n        }\n      };\n  }\n  // TODO: remove this error message for production apps\n  throw new AuthError({\n    name: AuthErrorCodes.SignInException,\n    message: 'An error occurred during the sign in process. ' + \"\".concat(challengeName, \" challengeName returned by the underlying service was not addressed.\")\n  });\n}\nfunction getTOTPSetupDetails(secretCode, username) {\n  return {\n    sharedSecret: secretCode,\n    getSetupUri: (appName, accountName) => {\n      const totpUri = \"otpauth://totp/\".concat(appName, \":\").concat(accountName !== null && accountName !== void 0 ? accountName : username, \"?secret=\").concat(secretCode, \"&issuer=\").concat(appName);\n      return new AmplifyUrl(totpUri);\n    }\n  };\n}\nfunction getSignInResultFromError(errorName) {\n  if (errorName === InitiateAuthException.PasswordResetRequiredException) {\n    return {\n      isSignedIn: false,\n      nextStep: {\n        signInStep: 'RESET_PASSWORD'\n      }\n    };\n  } else if (errorName === InitiateAuthException.UserNotConfirmedException) {\n    return {\n      isSignedIn: false,\n      nextStep: {\n        signInStep: 'CONFIRM_SIGN_UP'\n      }\n    };\n  }\n}\nfunction parseAttributes(attributes) {\n  if (!attributes) return [];\n  const parsedAttributes = JSON.parse(attributes).map(att => att.includes(USER_ATTRIBUTES) ? att.replace(USER_ATTRIBUTES, '') : att);\n  return parsedAttributes;\n}\nfunction createAttributes(attributes) {\n  if (!attributes) return {};\n  const newAttributes = {};\n  Object.entries(attributes).forEach(_ref10 => {\n    let [key, value] = _ref10;\n    if (value) newAttributes[\"\".concat(USER_ATTRIBUTES).concat(key)] = value;\n  });\n  return newAttributes;\n}\nasync function handleChallengeName(username, challengeName, session, challengeResponse, config, tokenOrchestrator, clientMetadata, options) {\n  const userAttributes = options === null || options === void 0 ? void 0 : options.userAttributes;\n  const deviceName = options === null || options === void 0 ? void 0 : options.friendlyDeviceName;\n  switch (challengeName) {\n    case 'SMS_MFA':\n      return handleSMSMFAChallenge({\n        challengeResponse,\n        clientMetadata,\n        session,\n        username,\n        config\n      });\n    case 'SELECT_MFA_TYPE':\n      return handleSelectMFATypeChallenge({\n        challengeResponse,\n        clientMetadata,\n        session,\n        username,\n        config\n      });\n    case 'MFA_SETUP':\n      return handleMFASetupChallenge({\n        challengeResponse,\n        clientMetadata,\n        session,\n        username,\n        deviceName,\n        config\n      });\n    case 'NEW_PASSWORD_REQUIRED':\n      return handleCompleteNewPasswordChallenge({\n        challengeResponse,\n        clientMetadata,\n        session,\n        username,\n        requiredAttributes: userAttributes,\n        config\n      });\n    case 'CUSTOM_CHALLENGE':\n      return retryOnResourceNotFoundException(handleCustomChallenge, [{\n        challengeResponse,\n        clientMetadata,\n        session,\n        username,\n        config,\n        tokenOrchestrator\n      }], username, tokenOrchestrator);\n    case 'SOFTWARE_TOKEN_MFA':\n      return handleSoftwareTokenMFAChallenge({\n        challengeResponse,\n        clientMetadata,\n        session,\n        username,\n        config\n      });\n  }\n  // TODO: remove this error message for production apps\n  throw new AuthError({\n    name: AuthErrorCodes.SignInException,\n    message: \"An error occurred during the sign in process. \\n\\t\\t\".concat(challengeName, \" challengeName returned by the underlying service was not addressed.\")\n  });\n}\nfunction mapMfaType(mfa) {\n  let mfaType = 'SMS_MFA';\n  if (mfa === 'TOTP') mfaType = 'SOFTWARE_TOKEN_MFA';\n  return mfaType;\n}\nfunction getMFAType(type) {\n  if (type === 'SMS_MFA') return 'SMS';\n  if (type === 'SOFTWARE_TOKEN_MFA') return 'TOTP';\n  // TODO: log warning for unknown MFA type\n}\nfunction getMFATypes(types) {\n  if (!types) return undefined;\n  return types.map(getMFAType).filter(Boolean);\n}\nfunction parseMFATypes(mfa) {\n  if (!mfa) return [];\n  return JSON.parse(mfa);\n}\nfunction isMFATypeEnabled(challengeParams, mfaType) {\n  const {\n    MFAS_CAN_SETUP\n  } = challengeParams;\n  const mfaTypes = getMFATypes(parseMFATypes(MFAS_CAN_SETUP));\n  if (!mfaTypes) return false;\n  return mfaTypes.includes(mfaType);\n}\nasync function assertUserNotAuthenticated() {\n  let authUser;\n  try {\n    authUser = await getCurrentUser();\n  } catch (error) {}\n  if (authUser && authUser.userId && authUser.username) {\n    throw new AuthError({\n      name: USER_ALREADY_AUTHENTICATED_EXCEPTION,\n      message: 'There is already a signed in user.',\n      recoverySuggestion: 'Call signOut before calling signIn again.'\n    });\n  }\n}\n/**\n * This function is used to kick off the device management flow.\n *\n * If an error is thrown while generating a hash device or calling the `ConfirmDevice`\n * client, then this API will ignore the error and return undefined. Otherwise the authentication\n * flow will not complete and the user won't be able to be signed in.\n *\n * @returns DeviceMetadata | undefined\n */\nasync function getNewDeviceMetatada(userPoolId, newDeviceMetadata, accessToken) {\n  if (!newDeviceMetadata) return undefined;\n  const userPoolName = userPoolId.split('_')[1] || '';\n  const authenticationHelper = await getAuthenticationHelper(userPoolName);\n  const deviceKey = newDeviceMetadata === null || newDeviceMetadata === void 0 ? void 0 : newDeviceMetadata.DeviceKey;\n  const deviceGroupKey = newDeviceMetadata === null || newDeviceMetadata === void 0 ? void 0 : newDeviceMetadata.DeviceGroupKey;\n  try {\n    await authenticationHelper.generateHashDevice(deviceGroupKey !== null && deviceGroupKey !== void 0 ? deviceGroupKey : '', deviceKey !== null && deviceKey !== void 0 ? deviceKey : '');\n  } catch (errGenHash) {\n    // TODO: log error here\n    return undefined;\n  }\n  const deviceSecretVerifierConfig = {\n    Salt: base64Encoder.convert(getBytesFromHex(authenticationHelper.getSaltToHashDevices())),\n    PasswordVerifier: base64Encoder.convert(getBytesFromHex(authenticationHelper.getVerifierDevices()))\n  };\n  const randomPassword = authenticationHelper.getRandomPassword();\n  try {\n    await confirmDevice({\n      region: getRegion(userPoolId)\n    }, {\n      AccessToken: accessToken,\n      DeviceKey: newDeviceMetadata === null || newDeviceMetadata === void 0 ? void 0 : newDeviceMetadata.DeviceKey,\n      DeviceSecretVerifierConfig: deviceSecretVerifierConfig\n    });\n    return {\n      deviceKey,\n      deviceGroupKey,\n      randomPassword\n    };\n  } catch (error) {\n    // TODO: log error here\n    return undefined;\n  }\n}\n/**\n * It will retry the function if the error is a `ResourceNotFoundException` and\n * will clean the device keys stored in the storage mechanism.\n *\n */\nasync function retryOnResourceNotFoundException(func, args, username, tokenOrchestrator) {\n  try {\n    return await func(...args);\n  } catch (error) {\n    if (error instanceof AuthError && error.name === 'ResourceNotFoundException' && error.message.includes('Device does not exist.')) {\n      await tokenOrchestrator.clearDeviceMetadata(username);\n      return func(...args);\n    }\n    throw error;\n  }\n}\nfunction setActiveSignInUsername(username) {\n  const {\n    dispatch\n  } = signInStore;\n  dispatch({\n    type: 'SET_USERNAME',\n    value: username\n  });\n}\nfunction getActiveSignInUsername(username) {\n  var _state$username;\n  const state = signInStore.getState();\n  return (_state$username = state.username) !== null && _state$username !== void 0 ? _state$username : username;\n}\nexport { assertUserNotAuthenticated, createAttributes, getActiveSignInUsername, getMFAType, getMFATypes, getNewDeviceMetatada, getSignInResult, getSignInResultFromError, getTOTPSetupDetails, handleChallengeName, handleCompleteNewPasswordChallenge, handleCustomAuthFlowWithoutSRP, handleCustomChallenge, handleCustomSRPAuthFlow, handleMFASetupChallenge, handlePasswordVerifierChallenge, handleSMSMFAChallenge, handleSelectMFATypeChallenge, handleSoftwareTokenMFAChallenge, handleUserPasswordAuthFlow, handleUserSRPAuthFlow, isMFATypeEnabled, mapMfaType, parseAttributes, parseMFATypes, retryOnResourceNotFoundException, setActiveSignInUsername };","map":{"version":3,"names":["USER_ATTRIBUTES","handleCustomChallenge","_ref","challengeResponse","clientMetadata","session","username","config","tokenOrchestrator","userPoolId","userPoolClientId","challengeResponses","USERNAME","ANSWER","deviceMetadata","getDeviceMetadata","deviceKey","DEVICE_KEY","UserContextData","getUserContextData","jsonReq","ChallengeName","ChallengeResponses","Session","ClientMetadata","ClientId","response","respondToAuthChallenge","region","getRegion","userAgentValue","getAuthUserAgentValue","AuthAction","ConfirmSignIn","handleDeviceSRPAuth","handleMFASetupChallenge","_ref2","deviceName","verifySoftwareToken","UserCode","FriendlyDeviceName","signInStore","dispatch","type","value","handleSelectMFATypeChallenge","_ref3","assertValidationError","AuthValidationErrorCode","IncorrectMFAMethod","mapMfaType","handleSMSMFAChallenge","_ref4","SMS_MFA_CODE","handleSoftwareTokenMFAChallenge","_ref5","SOFTWARE_TOKEN_MFA_CODE","handleCompleteNewPasswordChallenge","_ref6","requiredAttributes","createAttributes","NEW_PASSWORD","handleUserPasswordAuthFlow","password","_ref7","_response$ChallengePa","_response$ChallengePa2","_response$ChallengePa3","authParameters","PASSWORD","AuthFlow","AuthParameters","initiateAuth","SignIn","activeUsername","ChallengeParameters","USER_ID_FOR_SRP","setActiveSignInUsername","handleUserSRPAuthFlow","_challengeParameters$","userPoolName","split","authenticationHelper","getAuthenticationHelper","SRP_A","A","toString","resp","challengeParameters","retryOnResourceNotFoundException","handlePasswordVerifierChallenge","handleCustomAuthFlowWithoutSRP","_response$ChallengePa4","_response$ChallengePa5","handleCustomSRPAuthFlow","_challengeParameters$2","assertTokenProviderConfig","CHALLENGE_NAME","_ref8","clientId","assertDeviceMetadata","deviceGroupKey","jsonReqResponseChallenge","respondedChallengeParameters","handleDevicePasswordVerifier","_ref9","_challengeParameters$3","serverBValue","BigInteger","SRP_B","salt","SALT","hkdf","getPasswordAuthenticationKey","randomPassword","dateNow","getNowString","PASSWORD_CLAIM_SECRET_BLOCK","SECRET_BLOCK","TIMESTAMP","PASSWORD_CLAIM_SIGNATURE","getSignatureString","AuthError","name","message","getSignInResult","params","_Amplify$getConfig$Au","challengeName","authConfig","Amplify","getConfig","Auth","Cognito","isSignedIn","nextStep","signInStep","additionalInfo","signInSession","getState","isMFATypeEnabled","AuthErrorCodes","SignInException","concat","getMFATypes","parseMFATypes","MFAS_CAN_SETUP","SecretCode","secretCode","associateSoftwareToken","totpSetupDetails","getTOTPSetupDetails","missingAttributes","parseAttributes","allowedMFATypes","MFAS_CAN_CHOOSE","codeDeliveryDetails","deliveryMedium","CODE_DELIVERY_DELIVERY_MEDIUM","destination","CODE_DELIVERY_DESTINATION","sharedSecret","getSetupUri","appName","accountName","totpUri","AmplifyUrl","getSignInResultFromError","errorName","InitiateAuthException","PasswordResetRequiredException","UserNotConfirmedException","attributes","parsedAttributes","JSON","parse","map","att","includes","replace","newAttributes","Object","entries","forEach","_ref10","key","handleChallengeName","options","userAttributes","friendlyDeviceName","mfa","mfaType","getMFAType","types","undefined","filter","Boolean","challengeParams","mfaTypes","assertUserNotAuthenticated","authUser","getCurrentUser","error","userId","USER_ALREADY_AUTHENTICATED_EXCEPTION","recoverySuggestion","getNewDeviceMetatada","newDeviceMetadata","accessToken","DeviceKey","DeviceGroupKey","generateHashDevice","errGenHash","deviceSecretVerifierConfig","Salt","base64Encoder","convert","getBytesFromHex","getSaltToHashDevices","PasswordVerifier","getVerifierDevices","getRandomPassword","confirmDevice","AccessToken","DeviceSecretVerifierConfig","func","args","clearDeviceMetadata","getActiveSignInUsername","_state$username","state"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/auth/src/providers/cognito/utils/signInHelpers.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Amplify } from '@aws-amplify/core';\nimport { AmplifyUrl, AuthAction, assertTokenProviderConfig, base64Encoder, } from '@aws-amplify/core/internals/utils';\nimport { AuthError } from '../../../errors/AuthError';\nimport { InitiateAuthException } from '../types/errors';\nimport { AuthErrorCodes } from '../../../common/AuthErrorStrings';\nimport { AuthValidationErrorCode } from '../../../errors/types/validation';\nimport { assertValidationError } from '../../../errors/utils/assertValidationError';\nimport { USER_ALREADY_AUTHENTICATED_EXCEPTION } from '../../../errors/constants';\nimport { getCurrentUser } from '../apis/getCurrentUser';\nimport { getAuthUserAgentValue } from '../../../utils';\nimport { signInStore } from './signInStore';\nimport { associateSoftwareToken, confirmDevice, initiateAuth, respondToAuthChallenge, verifySoftwareToken, } from './clients/CognitoIdentityProvider';\nimport { getRegion } from './clients/CognitoIdentityProvider/utils';\nimport { assertDeviceMetadata } from './types';\nimport { getAuthenticationHelper, getBytesFromHex, getNowString, getSignatureString, } from './srp';\nimport { BigInteger } from './srp/BigInteger';\nimport { getUserContextData } from './userContextData';\nconst USER_ATTRIBUTES = 'userAttributes.';\nexport async function handleCustomChallenge({ challengeResponse, clientMetadata, session, username, config, tokenOrchestrator, }) {\n    const { userPoolId, userPoolClientId } = config;\n    const challengeResponses = {\n        USERNAME: username,\n        ANSWER: challengeResponse,\n    };\n    const deviceMetadata = await tokenOrchestrator?.getDeviceMetadata(username);\n    if (deviceMetadata && deviceMetadata.deviceKey) {\n        challengeResponses.DEVICE_KEY = deviceMetadata.deviceKey;\n    }\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        ChallengeName: 'CUSTOM_CHALLENGE',\n        ChallengeResponses: challengeResponses,\n        Session: session,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    const response = await respondToAuthChallenge({\n        region: getRegion(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn),\n    }, jsonReq);\n    if (response.ChallengeName === 'DEVICE_SRP_AUTH') {\n        return handleDeviceSRPAuth({\n            username,\n            config,\n            clientMetadata,\n            session: response.Session,\n            tokenOrchestrator,\n        });\n    }\n    return response;\n}\nexport async function handleMFASetupChallenge({ challengeResponse, username, clientMetadata, session, deviceName, config, }) {\n    const { userPoolId, userPoolClientId } = config;\n    const challengeResponses = {\n        USERNAME: username,\n    };\n    const { Session } = await verifySoftwareToken({\n        region: getRegion(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn),\n    }, {\n        UserCode: challengeResponse,\n        Session: session,\n        FriendlyDeviceName: deviceName,\n    });\n    signInStore.dispatch({\n        type: 'SET_SIGN_IN_SESSION',\n        value: Session,\n    });\n    const jsonReq = {\n        ChallengeName: 'MFA_SETUP',\n        ChallengeResponses: challengeResponses,\n        Session,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n    };\n    return respondToAuthChallenge({ region: getRegion(userPoolId) }, jsonReq);\n}\nexport async function handleSelectMFATypeChallenge({ challengeResponse, username, clientMetadata, session, config, }) {\n    const { userPoolId, userPoolClientId } = config;\n    assertValidationError(challengeResponse === 'TOTP' || challengeResponse === 'SMS', AuthValidationErrorCode.IncorrectMFAMethod);\n    const challengeResponses = {\n        USERNAME: username,\n        ANSWER: mapMfaType(challengeResponse),\n    };\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        ChallengeName: 'SELECT_MFA_TYPE',\n        ChallengeResponses: challengeResponses,\n        Session: session,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    return respondToAuthChallenge({\n        region: getRegion(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn),\n    }, jsonReq);\n}\nexport async function handleSMSMFAChallenge({ challengeResponse, clientMetadata, session, username, config, }) {\n    const { userPoolId, userPoolClientId } = config;\n    const challengeResponses = {\n        USERNAME: username,\n        SMS_MFA_CODE: challengeResponse,\n    };\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        ChallengeName: 'SMS_MFA',\n        ChallengeResponses: challengeResponses,\n        Session: session,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    return respondToAuthChallenge({\n        region: getRegion(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn),\n    }, jsonReq);\n}\nexport async function handleSoftwareTokenMFAChallenge({ challengeResponse, clientMetadata, session, username, config, }) {\n    const { userPoolId, userPoolClientId } = config;\n    const challengeResponses = {\n        USERNAME: username,\n        SOFTWARE_TOKEN_MFA_CODE: challengeResponse,\n    };\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        ChallengeName: 'SOFTWARE_TOKEN_MFA',\n        ChallengeResponses: challengeResponses,\n        Session: session,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    return respondToAuthChallenge({\n        region: getRegion(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn),\n    }, jsonReq);\n}\nexport async function handleCompleteNewPasswordChallenge({ challengeResponse, clientMetadata, session, username, requiredAttributes, config, }) {\n    const { userPoolId, userPoolClientId } = config;\n    const challengeResponses = {\n        ...createAttributes(requiredAttributes),\n        NEW_PASSWORD: challengeResponse,\n        USERNAME: username,\n    };\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        ChallengeName: 'NEW_PASSWORD_REQUIRED',\n        ChallengeResponses: challengeResponses,\n        ClientMetadata: clientMetadata,\n        Session: session,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    return respondToAuthChallenge({\n        region: getRegion(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn),\n    }, jsonReq);\n}\nexport async function handleUserPasswordAuthFlow(username, password, clientMetadata, config, tokenOrchestrator) {\n    const { userPoolClientId, userPoolId } = config;\n    const authParameters = {\n        USERNAME: username,\n        PASSWORD: password,\n    };\n    const deviceMetadata = await tokenOrchestrator.getDeviceMetadata(username);\n    if (deviceMetadata && deviceMetadata.deviceKey) {\n        authParameters.DEVICE_KEY = deviceMetadata.deviceKey;\n    }\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        AuthFlow: 'USER_PASSWORD_AUTH',\n        AuthParameters: authParameters,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    const response = await initiateAuth({\n        region: getRegion(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.SignIn),\n    }, jsonReq);\n    const activeUsername = response.ChallengeParameters?.USERNAME ??\n        response.ChallengeParameters?.USER_ID_FOR_SRP ??\n        username;\n    setActiveSignInUsername(activeUsername);\n    if (response.ChallengeName === 'DEVICE_SRP_AUTH')\n        return handleDeviceSRPAuth({\n            username: activeUsername,\n            config,\n            clientMetadata,\n            session: response.Session,\n            tokenOrchestrator,\n        });\n    return response;\n}\nexport async function handleUserSRPAuthFlow(username, password, clientMetadata, config, tokenOrchestrator) {\n    const { userPoolId, userPoolClientId } = config;\n    const userPoolName = userPoolId?.split('_')[1] || '';\n    const authenticationHelper = await getAuthenticationHelper(userPoolName);\n    const authParameters = {\n        USERNAME: username,\n        SRP_A: authenticationHelper.A.toString(16),\n    };\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        AuthFlow: 'USER_SRP_AUTH',\n        AuthParameters: authParameters,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    const resp = await initiateAuth({\n        region: getRegion(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.SignIn),\n    }, jsonReq);\n    const { ChallengeParameters: challengeParameters, Session: session } = resp;\n    const activeUsername = challengeParameters?.USERNAME ?? username;\n    setActiveSignInUsername(activeUsername);\n    return retryOnResourceNotFoundException(handlePasswordVerifierChallenge, [\n        password,\n        challengeParameters,\n        clientMetadata,\n        session,\n        authenticationHelper,\n        config,\n        tokenOrchestrator,\n    ], activeUsername, tokenOrchestrator);\n}\nexport async function handleCustomAuthFlowWithoutSRP(username, clientMetadata, config, tokenOrchestrator) {\n    const { userPoolClientId, userPoolId } = config;\n    const authParameters = {\n        USERNAME: username,\n    };\n    const deviceMetadata = await tokenOrchestrator.getDeviceMetadata(username);\n    if (deviceMetadata && deviceMetadata.deviceKey) {\n        authParameters.DEVICE_KEY = deviceMetadata.deviceKey;\n    }\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        AuthFlow: 'CUSTOM_AUTH',\n        AuthParameters: authParameters,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    const response = await initiateAuth({\n        region: getRegion(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.SignIn),\n    }, jsonReq);\n    const activeUsername = response.ChallengeParameters?.USERNAME ?? username;\n    setActiveSignInUsername(activeUsername);\n    if (response.ChallengeName === 'DEVICE_SRP_AUTH')\n        return handleDeviceSRPAuth({\n            username: activeUsername,\n            config,\n            clientMetadata,\n            session: response.Session,\n            tokenOrchestrator,\n        });\n    return response;\n}\nexport async function handleCustomSRPAuthFlow(username, password, clientMetadata, config, tokenOrchestrator) {\n    assertTokenProviderConfig(config);\n    const { userPoolId, userPoolClientId } = config;\n    const userPoolName = userPoolId?.split('_')[1] || '';\n    const authenticationHelper = await getAuthenticationHelper(userPoolName);\n    const authParameters = {\n        USERNAME: username,\n        SRP_A: authenticationHelper.A.toString(16),\n        CHALLENGE_NAME: 'SRP_A',\n    };\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        AuthFlow: 'CUSTOM_AUTH',\n        AuthParameters: authParameters,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    const { ChallengeParameters: challengeParameters, Session: session } = await initiateAuth({\n        region: getRegion(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.SignIn),\n    }, jsonReq);\n    const activeUsername = challengeParameters?.USERNAME ?? username;\n    setActiveSignInUsername(activeUsername);\n    return retryOnResourceNotFoundException(handlePasswordVerifierChallenge, [\n        password,\n        challengeParameters,\n        clientMetadata,\n        session,\n        authenticationHelper,\n        config,\n        tokenOrchestrator,\n    ], activeUsername, tokenOrchestrator);\n}\nasync function handleDeviceSRPAuth({ username, config, clientMetadata, session, tokenOrchestrator, }) {\n    const { userPoolId } = config;\n    const clientId = config.userPoolClientId;\n    const deviceMetadata = await tokenOrchestrator?.getDeviceMetadata(username);\n    assertDeviceMetadata(deviceMetadata);\n    const authenticationHelper = await getAuthenticationHelper(deviceMetadata.deviceGroupKey);\n    const challengeResponses = {\n        USERNAME: username,\n        SRP_A: authenticationHelper.A.toString(16),\n        DEVICE_KEY: deviceMetadata.deviceKey,\n    };\n    const jsonReqResponseChallenge = {\n        ChallengeName: 'DEVICE_SRP_AUTH',\n        ClientId: clientId,\n        ChallengeResponses: challengeResponses,\n        ClientMetadata: clientMetadata,\n        Session: session,\n    };\n    const { ChallengeParameters: respondedChallengeParameters, Session } = await respondToAuthChallenge({ region: getRegion(userPoolId) }, jsonReqResponseChallenge);\n    return handleDevicePasswordVerifier(username, respondedChallengeParameters, clientMetadata, Session, authenticationHelper, config, tokenOrchestrator);\n}\nasync function handleDevicePasswordVerifier(username, challengeParameters, clientMetadata, session, authenticationHelper, { userPoolId, userPoolClientId }, tokenOrchestrator) {\n    const deviceMetadata = await tokenOrchestrator?.getDeviceMetadata(username);\n    assertDeviceMetadata(deviceMetadata);\n    const serverBValue = new BigInteger(challengeParameters?.SRP_B, 16);\n    const salt = new BigInteger(challengeParameters?.SALT, 16);\n    const { deviceKey } = deviceMetadata;\n    const { deviceGroupKey } = deviceMetadata;\n    const hkdf = await authenticationHelper.getPasswordAuthenticationKey({\n        username: deviceMetadata.deviceKey,\n        password: deviceMetadata.randomPassword,\n        serverBValue,\n        salt,\n    });\n    const dateNow = getNowString();\n    const challengeResponses = {\n        USERNAME: challengeParameters?.USERNAME ?? username,\n        PASSWORD_CLAIM_SECRET_BLOCK: challengeParameters?.SECRET_BLOCK,\n        TIMESTAMP: dateNow,\n        PASSWORD_CLAIM_SIGNATURE: getSignatureString({\n            username: deviceKey,\n            userPoolName: deviceGroupKey,\n            challengeParameters,\n            dateNow,\n            hkdf,\n        }),\n        DEVICE_KEY: deviceKey,\n    };\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReqResponseChallenge = {\n        ChallengeName: 'DEVICE_PASSWORD_VERIFIER',\n        ClientId: userPoolClientId,\n        ChallengeResponses: challengeResponses,\n        Session: session,\n        ClientMetadata: clientMetadata,\n        UserContextData,\n    };\n    return respondToAuthChallenge({ region: getRegion(userPoolId) }, jsonReqResponseChallenge);\n}\nexport async function handlePasswordVerifierChallenge(password, challengeParameters, clientMetadata, session, authenticationHelper, config, tokenOrchestrator) {\n    const { userPoolId, userPoolClientId } = config;\n    const userPoolName = userPoolId?.split('_')[1] || '';\n    const serverBValue = new BigInteger(challengeParameters?.SRP_B, 16);\n    const salt = new BigInteger(challengeParameters?.SALT, 16);\n    const username = challengeParameters?.USER_ID_FOR_SRP;\n    if (!username)\n        throw new AuthError({\n            name: 'EmptyUserIdForSRPException',\n            message: 'USER_ID_FOR_SRP was not found in challengeParameters',\n        });\n    const hkdf = await authenticationHelper.getPasswordAuthenticationKey({\n        username,\n        password,\n        serverBValue,\n        salt,\n    });\n    const dateNow = getNowString();\n    const challengeResponses = {\n        USERNAME: username,\n        PASSWORD_CLAIM_SECRET_BLOCK: challengeParameters?.SECRET_BLOCK,\n        TIMESTAMP: dateNow,\n        PASSWORD_CLAIM_SIGNATURE: getSignatureString({\n            username,\n            userPoolName,\n            challengeParameters,\n            dateNow,\n            hkdf,\n        }),\n    };\n    const deviceMetadata = await tokenOrchestrator.getDeviceMetadata(username);\n    if (deviceMetadata && deviceMetadata.deviceKey) {\n        challengeResponses.DEVICE_KEY = deviceMetadata.deviceKey;\n    }\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReqResponseChallenge = {\n        ChallengeName: 'PASSWORD_VERIFIER',\n        ChallengeResponses: challengeResponses,\n        ClientMetadata: clientMetadata,\n        Session: session,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    const response = await respondToAuthChallenge({ region: getRegion(userPoolId) }, jsonReqResponseChallenge);\n    if (response.ChallengeName === 'DEVICE_SRP_AUTH')\n        return handleDeviceSRPAuth({\n            username,\n            config,\n            clientMetadata,\n            session: response.Session,\n            tokenOrchestrator,\n        });\n    return response;\n}\nexport async function getSignInResult(params) {\n    const { challengeName, challengeParameters } = params;\n    const authConfig = Amplify.getConfig().Auth?.Cognito;\n    assertTokenProviderConfig(authConfig);\n    switch (challengeName) {\n        case 'CUSTOM_CHALLENGE':\n            return {\n                isSignedIn: false,\n                nextStep: {\n                    signInStep: 'CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE',\n                    additionalInfo: challengeParameters,\n                },\n            };\n        case 'MFA_SETUP': {\n            const { signInSession, username } = signInStore.getState();\n            if (!isMFATypeEnabled(challengeParameters, 'TOTP'))\n                throw new AuthError({\n                    name: AuthErrorCodes.SignInException,\n                    message: `Cannot initiate MFA setup from available types: ${getMFATypes(parseMFATypes(challengeParameters.MFAS_CAN_SETUP))}`,\n                });\n            const { Session, SecretCode: secretCode } = await associateSoftwareToken({ region: getRegion(authConfig.userPoolId) }, {\n                Session: signInSession,\n            });\n            signInStore.dispatch({\n                type: 'SET_SIGN_IN_SESSION',\n                value: Session,\n            });\n            return {\n                isSignedIn: false,\n                nextStep: {\n                    signInStep: 'CONTINUE_SIGN_IN_WITH_TOTP_SETUP',\n                    totpSetupDetails: getTOTPSetupDetails(secretCode, username),\n                },\n            };\n        }\n        case 'NEW_PASSWORD_REQUIRED':\n            return {\n                isSignedIn: false,\n                nextStep: {\n                    signInStep: 'CONFIRM_SIGN_IN_WITH_NEW_PASSWORD_REQUIRED',\n                    missingAttributes: parseAttributes(challengeParameters.requiredAttributes),\n                },\n            };\n        case 'SELECT_MFA_TYPE':\n            return {\n                isSignedIn: false,\n                nextStep: {\n                    signInStep: 'CONTINUE_SIGN_IN_WITH_MFA_SELECTION',\n                    allowedMFATypes: getMFATypes(parseMFATypes(challengeParameters.MFAS_CAN_CHOOSE)),\n                },\n            };\n        case 'SMS_MFA':\n            return {\n                isSignedIn: false,\n                nextStep: {\n                    signInStep: 'CONFIRM_SIGN_IN_WITH_SMS_CODE',\n                    codeDeliveryDetails: {\n                        deliveryMedium: challengeParameters.CODE_DELIVERY_DELIVERY_MEDIUM,\n                        destination: challengeParameters.CODE_DELIVERY_DESTINATION,\n                    },\n                },\n            };\n        case 'SOFTWARE_TOKEN_MFA':\n            return {\n                isSignedIn: false,\n                nextStep: {\n                    signInStep: 'CONFIRM_SIGN_IN_WITH_TOTP_CODE',\n                },\n            };\n        case 'ADMIN_NO_SRP_AUTH':\n            break;\n        case 'DEVICE_PASSWORD_VERIFIER':\n            break;\n        case 'DEVICE_SRP_AUTH':\n            break;\n        case 'PASSWORD_VERIFIER':\n            break;\n    }\n    // TODO: remove this error message for production apps\n    throw new AuthError({\n        name: AuthErrorCodes.SignInException,\n        message: 'An error occurred during the sign in process. ' +\n            `${challengeName} challengeName returned by the underlying service was not addressed.`,\n    });\n}\nexport function getTOTPSetupDetails(secretCode, username) {\n    return {\n        sharedSecret: secretCode,\n        getSetupUri: (appName, accountName) => {\n            const totpUri = `otpauth://totp/${appName}:${accountName ?? username}?secret=${secretCode}&issuer=${appName}`;\n            return new AmplifyUrl(totpUri);\n        },\n    };\n}\nexport function getSignInResultFromError(errorName) {\n    if (errorName === InitiateAuthException.PasswordResetRequiredException) {\n        return {\n            isSignedIn: false,\n            nextStep: { signInStep: 'RESET_PASSWORD' },\n        };\n    }\n    else if (errorName === InitiateAuthException.UserNotConfirmedException) {\n        return {\n            isSignedIn: false,\n            nextStep: { signInStep: 'CONFIRM_SIGN_UP' },\n        };\n    }\n}\nexport function parseAttributes(attributes) {\n    if (!attributes)\n        return [];\n    const parsedAttributes = JSON.parse(attributes).map(att => att.includes(USER_ATTRIBUTES) ? att.replace(USER_ATTRIBUTES, '') : att);\n    return parsedAttributes;\n}\nexport function createAttributes(attributes) {\n    if (!attributes)\n        return {};\n    const newAttributes = {};\n    Object.entries(attributes).forEach(([key, value]) => {\n        if (value)\n            newAttributes[`${USER_ATTRIBUTES}${key}`] = value;\n    });\n    return newAttributes;\n}\nexport async function handleChallengeName(username, challengeName, session, challengeResponse, config, tokenOrchestrator, clientMetadata, options) {\n    const userAttributes = options?.userAttributes;\n    const deviceName = options?.friendlyDeviceName;\n    switch (challengeName) {\n        case 'SMS_MFA':\n            return handleSMSMFAChallenge({\n                challengeResponse,\n                clientMetadata,\n                session,\n                username,\n                config,\n            });\n        case 'SELECT_MFA_TYPE':\n            return handleSelectMFATypeChallenge({\n                challengeResponse,\n                clientMetadata,\n                session,\n                username,\n                config,\n            });\n        case 'MFA_SETUP':\n            return handleMFASetupChallenge({\n                challengeResponse,\n                clientMetadata,\n                session,\n                username,\n                deviceName,\n                config,\n            });\n        case 'NEW_PASSWORD_REQUIRED':\n            return handleCompleteNewPasswordChallenge({\n                challengeResponse,\n                clientMetadata,\n                session,\n                username,\n                requiredAttributes: userAttributes,\n                config,\n            });\n        case 'CUSTOM_CHALLENGE':\n            return retryOnResourceNotFoundException(handleCustomChallenge, [\n                {\n                    challengeResponse,\n                    clientMetadata,\n                    session,\n                    username,\n                    config,\n                    tokenOrchestrator,\n                },\n            ], username, tokenOrchestrator);\n        case 'SOFTWARE_TOKEN_MFA':\n            return handleSoftwareTokenMFAChallenge({\n                challengeResponse,\n                clientMetadata,\n                session,\n                username,\n                config,\n            });\n    }\n    // TODO: remove this error message for production apps\n    throw new AuthError({\n        name: AuthErrorCodes.SignInException,\n        message: `An error occurred during the sign in process. \n\t\t${challengeName} challengeName returned by the underlying service was not addressed.`,\n    });\n}\nexport function mapMfaType(mfa) {\n    let mfaType = 'SMS_MFA';\n    if (mfa === 'TOTP')\n        mfaType = 'SOFTWARE_TOKEN_MFA';\n    return mfaType;\n}\nexport function getMFAType(type) {\n    if (type === 'SMS_MFA')\n        return 'SMS';\n    if (type === 'SOFTWARE_TOKEN_MFA')\n        return 'TOTP';\n    // TODO: log warning for unknown MFA type\n}\nexport function getMFATypes(types) {\n    if (!types)\n        return undefined;\n    return types.map(getMFAType).filter(Boolean);\n}\nexport function parseMFATypes(mfa) {\n    if (!mfa)\n        return [];\n    return JSON.parse(mfa);\n}\nexport function isMFATypeEnabled(challengeParams, mfaType) {\n    const { MFAS_CAN_SETUP } = challengeParams;\n    const mfaTypes = getMFATypes(parseMFATypes(MFAS_CAN_SETUP));\n    if (!mfaTypes)\n        return false;\n    return mfaTypes.includes(mfaType);\n}\nexport async function assertUserNotAuthenticated() {\n    let authUser;\n    try {\n        authUser = await getCurrentUser();\n    }\n    catch (error) { }\n    if (authUser && authUser.userId && authUser.username) {\n        throw new AuthError({\n            name: USER_ALREADY_AUTHENTICATED_EXCEPTION,\n            message: 'There is already a signed in user.',\n            recoverySuggestion: 'Call signOut before calling signIn again.',\n        });\n    }\n}\n/**\n * This function is used to kick off the device management flow.\n *\n * If an error is thrown while generating a hash device or calling the `ConfirmDevice`\n * client, then this API will ignore the error and return undefined. Otherwise the authentication\n * flow will not complete and the user won't be able to be signed in.\n *\n * @returns DeviceMetadata | undefined\n */\nexport async function getNewDeviceMetatada(userPoolId, newDeviceMetadata, accessToken) {\n    if (!newDeviceMetadata)\n        return undefined;\n    const userPoolName = userPoolId.split('_')[1] || '';\n    const authenticationHelper = await getAuthenticationHelper(userPoolName);\n    const deviceKey = newDeviceMetadata?.DeviceKey;\n    const deviceGroupKey = newDeviceMetadata?.DeviceGroupKey;\n    try {\n        await authenticationHelper.generateHashDevice(deviceGroupKey ?? '', deviceKey ?? '');\n    }\n    catch (errGenHash) {\n        // TODO: log error here\n        return undefined;\n    }\n    const deviceSecretVerifierConfig = {\n        Salt: base64Encoder.convert(getBytesFromHex(authenticationHelper.getSaltToHashDevices())),\n        PasswordVerifier: base64Encoder.convert(getBytesFromHex(authenticationHelper.getVerifierDevices())),\n    };\n    const randomPassword = authenticationHelper.getRandomPassword();\n    try {\n        await confirmDevice({ region: getRegion(userPoolId) }, {\n            AccessToken: accessToken,\n            DeviceKey: newDeviceMetadata?.DeviceKey,\n            DeviceSecretVerifierConfig: deviceSecretVerifierConfig,\n        });\n        return {\n            deviceKey,\n            deviceGroupKey,\n            randomPassword,\n        };\n    }\n    catch (error) {\n        // TODO: log error here\n        return undefined;\n    }\n}\n/**\n * It will retry the function if the error is a `ResourceNotFoundException` and\n * will clean the device keys stored in the storage mechanism.\n *\n */\nexport async function retryOnResourceNotFoundException(func, args, username, tokenOrchestrator) {\n    try {\n        return await func(...args);\n    }\n    catch (error) {\n        if (error instanceof AuthError &&\n            error.name === 'ResourceNotFoundException' &&\n            error.message.includes('Device does not exist.')) {\n            await tokenOrchestrator.clearDeviceMetadata(username);\n            return func(...args);\n        }\n        throw error;\n    }\n}\nexport function setActiveSignInUsername(username) {\n    const { dispatch } = signInStore;\n    dispatch({ type: 'SET_USERNAME', value: username });\n}\nexport function getActiveSignInUsername(username) {\n    const state = signInStore.getState();\n    return state.username ?? username;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}