{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst DEFAULT_RETRY_ATTEMPTS = 3;\n/**\n * Retry middleware\n */\nconst retryMiddlewareFactory = _ref => {\n  let {\n    maxAttempts = DEFAULT_RETRY_ATTEMPTS,\n    retryDecider,\n    computeDelay,\n    abortSignal\n  } = _ref;\n  if (maxAttempts < 1) {\n    throw new Error('maxAttempts must be greater than 0');\n  }\n  return (next, context) => async function retryMiddleware(request) {\n    var _context$attemptsCoun;\n    let error;\n    let attemptsCount = (_context$attemptsCoun = context.attemptsCount) !== null && _context$attemptsCoun !== void 0 ? _context$attemptsCoun : 0;\n    let response;\n    // When retry is not needed or max attempts is reached, either error or response will be set. This function handles either cases.\n    const handleTerminalErrorOrResponse = () => {\n      if (response) {\n        addOrIncrementMetadataAttempts(response, attemptsCount);\n        return response;\n      } else {\n        addOrIncrementMetadataAttempts(error, attemptsCount);\n        throw error;\n      }\n    };\n    while (!(abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted) && attemptsCount < maxAttempts) {\n      var _context$attemptsCoun2, _context$attemptsCoun3;\n      try {\n        response = await next(request);\n        error = undefined;\n      } catch (e) {\n        error = e;\n        response = undefined;\n      }\n      // context.attemptsCount may be updated after calling next handler which may retry the request by itself.\n      attemptsCount = ((_context$attemptsCoun2 = context.attemptsCount) !== null && _context$attemptsCoun2 !== void 0 ? _context$attemptsCoun2 : 0) > attemptsCount ? (_context$attemptsCoun3 = context.attemptsCount) !== null && _context$attemptsCoun3 !== void 0 ? _context$attemptsCoun3 : 0 : attemptsCount + 1;\n      context.attemptsCount = attemptsCount;\n      if (await retryDecider(response, error)) {\n        if (!(abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted) && attemptsCount < maxAttempts) {\n          // prevent sleep for last attempt or cancelled request;\n          const delay = computeDelay(attemptsCount);\n          await cancellableSleep(delay, abortSignal);\n        }\n        continue;\n      } else {\n        return handleTerminalErrorOrResponse();\n      }\n    }\n    if (abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted) {\n      throw new Error('Request aborted.');\n    } else {\n      return handleTerminalErrorOrResponse();\n    }\n  };\n};\nconst cancellableSleep = (timeoutMs, abortSignal) => {\n  if (abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted) {\n    return Promise.resolve();\n  }\n  let timeoutId;\n  let sleepPromiseResolveFn;\n  const sleepPromise = new Promise(resolve => {\n    sleepPromiseResolveFn = resolve;\n    timeoutId = setTimeout(resolve, timeoutMs);\n  });\n  abortSignal === null || abortSignal === void 0 || abortSignal.addEventListener('abort', function cancelSleep(_) {\n    clearTimeout(timeoutId);\n    abortSignal === null || abortSignal === void 0 || abortSignal.removeEventListener('abort', cancelSleep);\n    sleepPromiseResolveFn();\n  });\n  return sleepPromise;\n};\nconst addOrIncrementMetadataAttempts = (nextHandlerOutput, attempts) => {\n  var _nextHandlerOutput$$m;\n  if (Object.prototype.toString.call(nextHandlerOutput) !== '[object Object]') {\n    return;\n  }\n  nextHandlerOutput.$metadata = {\n    ...((_nextHandlerOutput$$m = nextHandlerOutput.$metadata) !== null && _nextHandlerOutput$$m !== void 0 ? _nextHandlerOutput$$m : {}),\n    attempts\n  };\n};\nexport { retryMiddlewareFactory };","map":{"version":3,"names":["DEFAULT_RETRY_ATTEMPTS","retryMiddlewareFactory","_ref","maxAttempts","retryDecider","computeDelay","abortSignal","Error","next","context","retryMiddleware","request","_context$attemptsCoun","error","attemptsCount","response","handleTerminalErrorOrResponse","addOrIncrementMetadataAttempts","aborted","_context$attemptsCoun2","_context$attemptsCoun3","undefined","e","delay","cancellableSleep","timeoutMs","Promise","resolve","timeoutId","sleepPromiseResolveFn","sleepPromise","setTimeout","addEventListener","cancelSleep","_","clearTimeout","removeEventListener","nextHandlerOutput","attempts","_nextHandlerOutput$$m","Object","prototype","toString","call","$metadata"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/core/src/clients/middleware/retry/middleware.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst DEFAULT_RETRY_ATTEMPTS = 3;\n/**\n * Retry middleware\n */\nexport const retryMiddlewareFactory = ({ maxAttempts = DEFAULT_RETRY_ATTEMPTS, retryDecider, computeDelay, abortSignal, }) => {\n    if (maxAttempts < 1) {\n        throw new Error('maxAttempts must be greater than 0');\n    }\n    return (next, context) => async function retryMiddleware(request) {\n        let error;\n        let attemptsCount = context.attemptsCount ?? 0;\n        let response;\n        // When retry is not needed or max attempts is reached, either error or response will be set. This function handles either cases.\n        const handleTerminalErrorOrResponse = () => {\n            if (response) {\n                addOrIncrementMetadataAttempts(response, attemptsCount);\n                return response;\n            }\n            else {\n                addOrIncrementMetadataAttempts(error, attemptsCount);\n                throw error;\n            }\n        };\n        while (!abortSignal?.aborted && attemptsCount < maxAttempts) {\n            try {\n                response = await next(request);\n                error = undefined;\n            }\n            catch (e) {\n                error = e;\n                response = undefined;\n            }\n            // context.attemptsCount may be updated after calling next handler which may retry the request by itself.\n            attemptsCount =\n                (context.attemptsCount ?? 0) > attemptsCount\n                    ? context.attemptsCount ?? 0\n                    : attemptsCount + 1;\n            context.attemptsCount = attemptsCount;\n            if (await retryDecider(response, error)) {\n                if (!abortSignal?.aborted && attemptsCount < maxAttempts) {\n                    // prevent sleep for last attempt or cancelled request;\n                    const delay = computeDelay(attemptsCount);\n                    await cancellableSleep(delay, abortSignal);\n                }\n                continue;\n            }\n            else {\n                return handleTerminalErrorOrResponse();\n            }\n        }\n        if (abortSignal?.aborted) {\n            throw new Error('Request aborted.');\n        }\n        else {\n            return handleTerminalErrorOrResponse();\n        }\n    };\n};\nconst cancellableSleep = (timeoutMs, abortSignal) => {\n    if (abortSignal?.aborted) {\n        return Promise.resolve();\n    }\n    let timeoutId;\n    let sleepPromiseResolveFn;\n    const sleepPromise = new Promise(resolve => {\n        sleepPromiseResolveFn = resolve;\n        timeoutId = setTimeout(resolve, timeoutMs);\n    });\n    abortSignal?.addEventListener('abort', function cancelSleep(_) {\n        clearTimeout(timeoutId);\n        abortSignal?.removeEventListener('abort', cancelSleep);\n        sleepPromiseResolveFn();\n    });\n    return sleepPromise;\n};\nconst addOrIncrementMetadataAttempts = (nextHandlerOutput, attempts) => {\n    if (Object.prototype.toString.call(nextHandlerOutput) !== '[object Object]') {\n        return;\n    }\n    nextHandlerOutput.$metadata = {\n        ...(nextHandlerOutput.$metadata ?? {}),\n        attempts,\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}