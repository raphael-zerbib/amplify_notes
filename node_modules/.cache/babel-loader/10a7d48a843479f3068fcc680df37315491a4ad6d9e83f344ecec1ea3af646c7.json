{"ast":null,"code":"import { BackgroundProcessManager } from '@aws-amplify/core/internals/utils';\nimport { ConsoleLogger, Hub } from '@aws-amplify/core';\nimport { Observable, filter, of } from 'rxjs';\nimport { ModelPredicateCreator } from '../predicates/index.mjs';\nimport { OpType } from '../types.mjs';\nimport { getNow, USER, SYNC } from '../util.mjs';\nimport DataStoreConnectivity from './datastoreConnectivity.mjs';\nimport { ModelMerger } from './merger.mjs';\nimport { MutationEventOutbox } from './outbox.mjs';\nimport { MutationProcessor } from './processors/mutation.mjs';\nimport { SubscriptionProcessor, CONTROL_MSG } from './processors/subscription.mjs';\nimport { SyncProcessor } from './processors/sync.mjs';\nimport { predicateToGraphQLCondition, createMutationInstanceFromModelOperation, getIdentifierValue } from './utils.mjs';\nimport { CONTROL_MSG as CONTROL_MSG$1, CONNECTION_STATE_CHANGE, ConnectionState } from '@aws-amplify/api-graphql';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('DataStore');\nconst ownSymbol = Symbol('sync');\nvar ControlMessage;\n(function (ControlMessage) {\n  ControlMessage[\"SYNC_ENGINE_STORAGE_SUBSCRIBED\"] = \"storageSubscribed\";\n  ControlMessage[\"SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\"] = \"subscriptionsEstablished\";\n  ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_STARTED\"] = \"syncQueriesStarted\";\n  ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_READY\"] = \"syncQueriesReady\";\n  ControlMessage[\"SYNC_ENGINE_MODEL_SYNCED\"] = \"modelSynced\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED\"] = \"outboxMutationEnqueued\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED\"] = \"outboxMutationProcessed\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_STATUS\"] = \"outboxStatus\";\n  ControlMessage[\"SYNC_ENGINE_NETWORK_STATUS\"] = \"networkStatus\";\n  ControlMessage[\"SYNC_ENGINE_READY\"] = \"ready\";\n})(ControlMessage || (ControlMessage = {}));\nclass SyncEngine {\n  getModelSyncedStatus(modelConstructor) {\n    return this.modelSyncedStatus.get(modelConstructor);\n  }\n  constructor(schema, namespaceResolver, modelClasses, userModelClasses, storage, modelInstanceCreator, conflictHandler, errorHandler, syncPredicates, amplifyConfig = {}, authModeStrategy, amplifyContext, connectivityMonitor) {\n    this.schema = schema;\n    this.namespaceResolver = namespaceResolver;\n    this.modelClasses = modelClasses;\n    this.userModelClasses = userModelClasses;\n    this.storage = storage;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.syncPredicates = syncPredicates;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.amplifyContext = amplifyContext;\n    this.connectivityMonitor = connectivityMonitor;\n    this.online = false;\n    this.modelSyncedStatus = new WeakMap();\n    this.connectionDisrupted = false;\n    this.runningProcesses = new BackgroundProcessManager();\n    this.waitForSleepState = new Promise(resolve => {\n      this.syncQueriesObservableStartSleeping = resolve;\n    });\n    const MutationEvent = this.modelClasses['MutationEvent'];\n    this.outbox = new MutationEventOutbox(this.schema, MutationEvent, modelInstanceCreator, ownSymbol);\n    this.modelMerger = new ModelMerger(this.outbox, ownSymbol);\n    this.syncQueriesProcessor = new SyncProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n    this.subscriptionsProcessor = new SubscriptionProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n    this.mutationsProcessor = new MutationProcessor(this.schema, this.storage, this.userModelClasses, this.outbox, this.modelInstanceCreator, MutationEvent, this.amplifyConfig, this.authModeStrategy, errorHandler, conflictHandler, this.amplifyContext);\n    this.datastoreConnectivity = this.connectivityMonitor || new DataStoreConnectivity();\n  }\n  start(params) {\n    return new Observable(observer => {\n      logger.log('starting sync engine...');\n      let subscriptions = [];\n      this.runningProcesses.add(async () => {\n        try {\n          await this.setupModels(params);\n        } catch (err) {\n          observer.error(err);\n          return;\n        }\n        // this is awaited at the bottom. so, we don't need to register\n        // this explicitly with the context. it's already contained.\n        const startPromise = new Promise((doneStarting, failedStarting) => {\n          this.datastoreConnectivity.status().subscribe(async ({\n            online\n          }) => this.runningProcesses.isOpen && this.runningProcesses.add(async onTerminate => {\n            // From offline to online\n            if (online && !this.online) {\n              this.online = online;\n              observer.next({\n                type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                data: {\n                  active: this.online\n                }\n              });\n              let ctlSubsObservable;\n              let dataSubsObservable;\n              this.stopDisruptionListener = this.startDisruptionListener();\n              //#region GraphQL Subscriptions\n              [ctlSubsObservable, dataSubsObservable] = this.subscriptionsProcessor.start();\n              try {\n                await new Promise((resolve, reject) => {\n                  onTerminate.then(reject);\n                  const ctlSubsSubscription = ctlSubsObservable.subscribe({\n                    next: msg => {\n                      if (msg === CONTROL_MSG.CONNECTED) {\n                        resolve();\n                      }\n                    },\n                    error: err => {\n                      reject(err);\n                      const handleDisconnect = this.disconnectionHandler();\n                      handleDisconnect(err);\n                    }\n                  });\n                  subscriptions.push(ctlSubsSubscription);\n                });\n              } catch (err) {\n                observer.error(err);\n                failedStarting();\n                return;\n              }\n              logger.log('Realtime ready');\n              observer.next({\n                type: ControlMessage.SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\n              });\n              //#endregion\n              //#region Base & Sync queries\n              try {\n                await new Promise((resolve, reject) => {\n                  const syncQuerySubscription = this.syncQueriesObservable().subscribe({\n                    next: message => {\n                      const {\n                        type\n                      } = message;\n                      if (type === ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY) {\n                        resolve();\n                      }\n                      observer.next(message);\n                    },\n                    complete: () => {\n                      resolve();\n                    },\n                    error: error => {\n                      reject(error);\n                    }\n                  });\n                  if (syncQuerySubscription) {\n                    subscriptions.push(syncQuerySubscription);\n                  }\n                });\n              } catch (error) {\n                observer.error(error);\n                failedStarting();\n                return;\n              }\n              //#endregion\n              //#region process mutations (outbox)\n              subscriptions.push(this.mutationsProcessor.start().subscribe(({\n                modelDefinition,\n                model: item,\n                hasMore\n              }) => this.runningProcesses.add(async () => {\n                const modelConstructor = this.userModelClasses[modelDefinition.name];\n                const model = this.modelInstanceCreator(modelConstructor, item);\n                await this.storage.runExclusive(storage => this.modelMerger.merge(storage, model, modelDefinition));\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED,\n                  data: {\n                    model: modelConstructor,\n                    element: model\n                  }\n                });\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                  data: {\n                    isEmpty: !hasMore\n                  }\n                });\n              }, 'mutation processor event')));\n              //#endregion\n              //#region Merge subscriptions buffer\n              subscriptions.push(dataSubsObservable.subscribe(([_transformerMutationType, modelDefinition, item]) => this.runningProcesses.add(async () => {\n                const modelConstructor = this.userModelClasses[modelDefinition.name];\n                const model = this.modelInstanceCreator(modelConstructor, item);\n                await this.storage.runExclusive(storage => this.modelMerger.merge(storage, model, modelDefinition));\n              }, 'subscription dataSubsObservable event')));\n              //#endregion\n            } else if (!online) {\n              this.online = online;\n              observer.next({\n                type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                data: {\n                  active: this.online\n                }\n              });\n              subscriptions.forEach(sub => sub.unsubscribe());\n              subscriptions = [];\n            }\n            doneStarting();\n          }, 'datastore connectivity event'));\n        });\n        this.storage.observe(null, null, ownSymbol).pipe(filter(({\n          model\n        }) => {\n          const modelDefinition = this.getModelDefinition(model);\n          return modelDefinition.syncable === true;\n        })).subscribe({\n          next: async ({\n            opType,\n            model,\n            element,\n            condition\n          }) => this.runningProcesses.add(async () => {\n            const namespace = this.schema.namespaces[this.namespaceResolver(model)];\n            const MutationEventConstructor = this.modelClasses['MutationEvent'];\n            const modelDefinition = this.getModelDefinition(model);\n            const graphQLCondition = predicateToGraphQLCondition(condition, modelDefinition);\n            const mutationEvent = createMutationInstanceFromModelOperation(namespace.relationships, this.getModelDefinition(model), opType, model, element, graphQLCondition, MutationEventConstructor, this.modelInstanceCreator);\n            await this.outbox.enqueue(this.storage, mutationEvent);\n            observer.next({\n              type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED,\n              data: {\n                model,\n                element\n              }\n            });\n            observer.next({\n              type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n              data: {\n                isEmpty: false\n              }\n            });\n            await startPromise;\n            // Set by the this.datastoreConnectivity.status().subscribe() loop\n            if (this.online) {\n              this.mutationsProcessor.resume();\n            }\n          }, 'storage event')\n        });\n        observer.next({\n          type: ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED\n        });\n        const hasMutationsInOutbox = (await this.outbox.peek(this.storage)) === undefined;\n        observer.next({\n          type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n          data: {\n            isEmpty: hasMutationsInOutbox\n          }\n        });\n        await startPromise;\n        observer.next({\n          type: ControlMessage.SYNC_ENGINE_READY\n        });\n      }, 'sync start');\n    });\n  }\n  async getModelsMetadataWithNextFullSync(currentTimeStamp) {\n    const modelLastSync = new Map((await this.runningProcesses.add(() => this.getModelsMetadata(), 'sync/index getModelsMetadataWithNextFullSync')).map(({\n      namespace,\n      model,\n      lastSync,\n      lastFullSync,\n      fullSyncInterval,\n      lastSyncPredicate\n    }) => {\n      const nextFullSync = lastFullSync + fullSyncInterval;\n      const syncFrom = !lastFullSync || nextFullSync < currentTimeStamp ? 0 // perform full sync if expired\n      : lastSync; // perform delta sync\n      return [this.schema.namespaces[namespace].models[model], [namespace, syncFrom]];\n    }));\n    return modelLastSync;\n  }\n  syncQueriesObservable() {\n    if (!this.online) {\n      return of({}); // TODO(v6): fix this\n    }\n    return new Observable(observer => {\n      let syncQueriesSubscription;\n      this.runningProcesses.isOpen && this.runningProcesses.add(async onTerminate => {\n        let terminated = false;\n        while (!observer.closed && !terminated) {\n          const count = new WeakMap();\n          const modelLastSync = await this.getModelsMetadataWithNextFullSync(Date.now());\n          const paginatingModels = new Set(modelLastSync.keys());\n          let lastFullSyncStartedAt;\n          let syncInterval;\n          let start;\n          let syncDuration;\n          let lastStartedAt;\n          await new Promise((resolve, reject) => {\n            if (!this.runningProcesses.isOpen) resolve();\n            onTerminate.then(() => resolve());\n            syncQueriesSubscription = this.syncQueriesProcessor.start(modelLastSync).subscribe({\n              next: async ({\n                namespace,\n                modelDefinition,\n                items,\n                done,\n                startedAt,\n                isFullSync\n              }) => {\n                const modelConstructor = this.userModelClasses[modelDefinition.name];\n                if (!count.has(modelConstructor)) {\n                  count.set(modelConstructor, {\n                    new: 0,\n                    updated: 0,\n                    deleted: 0\n                  });\n                  start = getNow();\n                  lastStartedAt = lastStartedAt === undefined ? startedAt : Math.max(lastStartedAt, startedAt);\n                }\n                /**\n                 * If there are mutations in the outbox for a given id, those need to be\n                 * merged individually. Otherwise, we can merge them in batches.\n                 */\n                await this.storage.runExclusive(async storage => {\n                  const idsInOutbox = await this.outbox.getModelIds(storage);\n                  const oneByOne = [];\n                  const page = items.filter(item => {\n                    const itemId = getIdentifierValue(modelDefinition, item);\n                    if (!idsInOutbox.has(itemId)) {\n                      return true;\n                    }\n                    oneByOne.push(item);\n                    return false;\n                  });\n                  const opTypeCount = [];\n                  for (const item of oneByOne) {\n                    const opType = await this.modelMerger.merge(storage, item, modelDefinition);\n                    if (opType !== undefined) {\n                      opTypeCount.push([item, opType]);\n                    }\n                  }\n                  opTypeCount.push(...(await this.modelMerger.mergePage(storage, modelConstructor, page, modelDefinition)));\n                  const counts = count.get(modelConstructor);\n                  opTypeCount.forEach(([, opType]) => {\n                    switch (opType) {\n                      case OpType.INSERT:\n                        counts.new++;\n                        break;\n                      case OpType.UPDATE:\n                        counts.updated++;\n                        break;\n                      case OpType.DELETE:\n                        counts.deleted++;\n                        break;\n                      default:\n                        throw new Error(`Invalid opType ${opType}`);\n                    }\n                  });\n                });\n                if (done) {\n                  const {\n                    name: modelName\n                  } = modelDefinition;\n                  //#region update last sync for type\n                  let modelMetadata = await this.getModelMetadata(namespace, modelName);\n                  const {\n                    lastFullSync,\n                    fullSyncInterval\n                  } = modelMetadata;\n                  syncInterval = fullSyncInterval;\n                  lastFullSyncStartedAt = lastFullSyncStartedAt === undefined ? lastFullSync : Math.max(lastFullSyncStartedAt, isFullSync ? startedAt : lastFullSync);\n                  modelMetadata = this.modelClasses.ModelMetadata.copyOf(modelMetadata, draft => {\n                    draft.lastSync = startedAt;\n                    draft.lastFullSync = isFullSync ? startedAt : modelMetadata.lastFullSync;\n                  });\n                  await this.storage.save(modelMetadata, undefined, ownSymbol);\n                  //#endregion\n                  const counts = count.get(modelConstructor);\n                  this.modelSyncedStatus.set(modelConstructor, true);\n                  observer.next({\n                    type: ControlMessage.SYNC_ENGINE_MODEL_SYNCED,\n                    data: {\n                      model: modelConstructor,\n                      isFullSync,\n                      isDeltaSync: !isFullSync,\n                      counts\n                    }\n                  });\n                  paginatingModels.delete(modelDefinition);\n                  if (paginatingModels.size === 0) {\n                    syncDuration = getNow() - start;\n                    resolve();\n                    observer.next({\n                      type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY\n                    });\n                    syncQueriesSubscription.unsubscribe();\n                  }\n                }\n              },\n              error: error => {\n                observer.error(error);\n              }\n            });\n            observer.next({\n              type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_STARTED,\n              data: {\n                models: Array.from(paginatingModels).map(({\n                  name\n                }) => name)\n              }\n            });\n          });\n          // null is cast to 0 resulting in unexpected behavior.\n          // undefined in arithmetic operations results in NaN also resulting in unexpected behavior.\n          // If lastFullSyncStartedAt is null this is the first sync.\n          // Assume lastStartedAt is is also newest full sync.\n          let msNextFullSync;\n          if (!lastFullSyncStartedAt) {\n            msNextFullSync = syncInterval - syncDuration;\n          } else {\n            msNextFullSync = lastFullSyncStartedAt + syncInterval - (lastStartedAt + syncDuration);\n          }\n          logger.debug(`Next fullSync in ${msNextFullSync / 1000} seconds. (${new Date(Date.now() + msNextFullSync)})`);\n          // TODO: create `BackgroundProcessManager.sleep()` ... but, need to put\n          // a lot of thought into what that contract looks like to\n          //  support possible use-cases:\n          //\n          //  1. non-cancelable\n          //  2. cancelable, unsleep on exit()\n          //  3. cancelable, throw Error on exit()\n          //  4. cancelable, callback first on exit()?\n          //  5. ... etc. ? ...\n          //\n          // TLDR; this is a lot of complexity here for a sleep(),\n          // but, it's not clear to me yet how to support an\n          // extensible, centralized cancelable `sleep()` elegantly.\n          await this.runningProcesses.add(async onTerminate => {\n            let unsleep;\n            const sleep = new Promise(_unsleep => {\n              unsleep = _unsleep;\n              setTimeout(unsleep, msNextFullSync);\n            });\n            onTerminate.then(() => {\n              terminated = true;\n              this.syncQueriesObservableStartSleeping();\n              unsleep();\n            });\n            this.unsleepSyncQueriesObservable = unsleep;\n            this.syncQueriesObservableStartSleeping();\n            return sleep;\n          }, 'syncQueriesObservable sleep');\n          this.unsleepSyncQueriesObservable = null;\n          this.waitForSleepState = new Promise(resolve => {\n            this.syncQueriesObservableStartSleeping = resolve;\n          });\n        }\n      }, 'syncQueriesObservable main');\n    });\n  }\n  disconnectionHandler() {\n    return msg => {\n      // This implementation is tied to AWSAppSyncRealTimeProvider 'Connection closed', 'Timeout disconnect' msg\n      if (CONTROL_MSG$1.CONNECTION_CLOSED === msg || CONTROL_MSG$1.TIMEOUT_DISCONNECT === msg) {\n        this.datastoreConnectivity.socketDisconnected();\n      }\n    };\n  }\n  unsubscribeConnectivity() {\n    this.datastoreConnectivity.unsubscribe();\n  }\n  /**\n   * Stops all subscription activities and resolves when all activies report\n   * that they're disconnected, done retrying, etc..\n   */\n  async stop() {\n    logger.debug('stopping sync engine');\n    /**\n     * Gracefully disconnecting subscribers first just prevents *more* work\n     * from entering the pipelines.\n     */\n    this.unsubscribeConnectivity();\n    /**\n     * Stop listening for websocket connection disruption\n     */\n    this.stopDisruptionListener && this.stopDisruptionListener();\n    /**\n     * aggressively shut down any lingering background processes.\n     * some of this might be semi-redundant with unsubscribing. however,\n     * unsubscribing doesn't allow us to wait for settling.\n     * (Whereas `stop()` does.)\n     */\n    await this.mutationsProcessor.stop();\n    await this.subscriptionsProcessor.stop();\n    await this.datastoreConnectivity.stop();\n    await this.syncQueriesProcessor.stop();\n    await this.runningProcesses.close();\n    await this.runningProcesses.open();\n    logger.debug('sync engine stopped and ready to restart');\n  }\n  async setupModels(params) {\n    const {\n      fullSyncInterval\n    } = params;\n    const ModelMetadataConstructor = this.modelClasses.ModelMetadata;\n    const models = [];\n    let savedModel;\n    Object.values(this.schema.namespaces).forEach(namespace => {\n      Object.values(namespace.models).filter(({\n        syncable\n      }) => syncable).forEach(model => {\n        models.push([namespace.name, model]);\n        if (namespace.name === USER) {\n          const modelConstructor = this.userModelClasses[model.name];\n          this.modelSyncedStatus.set(modelConstructor, false);\n        }\n      });\n    });\n    const promises = models.map(async ([namespace, model]) => {\n      const modelMetadata = await this.getModelMetadata(namespace, model.name);\n      const syncPredicate = ModelPredicateCreator.getPredicates(this.syncPredicates.get(model), false);\n      const lastSyncPredicate = syncPredicate ? JSON.stringify(syncPredicate) : null;\n      if (modelMetadata === undefined) {\n        [[savedModel]] = await this.storage.save(this.modelInstanceCreator(ModelMetadataConstructor, {\n          model: model.name,\n          namespace,\n          lastSync: null,\n          fullSyncInterval,\n          lastFullSync: null,\n          lastSyncPredicate\n        }), undefined, ownSymbol);\n      } else {\n        const prevSyncPredicate = modelMetadata.lastSyncPredicate ? modelMetadata.lastSyncPredicate : null;\n        const syncPredicateUpdated = prevSyncPredicate !== lastSyncPredicate;\n        [[savedModel]] = await this.storage.save(ModelMetadataConstructor.copyOf(modelMetadata, draft => {\n          draft.fullSyncInterval = fullSyncInterval;\n          // perform a base sync if the syncPredicate changed in between calls to DataStore.start\n          // ensures that the local store contains all the data specified by the syncExpression\n          if (syncPredicateUpdated) {\n            draft.lastSync = null;\n            draft.lastFullSync = null;\n            draft.lastSyncPredicate = lastSyncPredicate;\n          }\n        }));\n      }\n      return savedModel;\n    });\n    const result = {};\n    for (const modelMetadata of await Promise.all(promises)) {\n      const {\n        model: modelName\n      } = modelMetadata;\n      result[modelName] = modelMetadata;\n    }\n    return result;\n  }\n  async getModelsMetadata() {\n    const ModelMetadata = this.modelClasses.ModelMetadata;\n    const modelsMetadata = await this.storage.query(ModelMetadata);\n    return modelsMetadata;\n  }\n  async getModelMetadata(namespace, model) {\n    const ModelMetadata = this.modelClasses.ModelMetadata;\n    const predicate = ModelPredicateCreator.createFromAST(this.schema.namespaces[SYNC].models[ModelMetadata.name], {\n      and: [{\n        namespace: {\n          eq: namespace\n        }\n      }, {\n        model: {\n          eq: model\n        }\n      }]\n    });\n    const [modelMetadata] = await this.storage.query(ModelMetadata, predicate, {\n      page: 0,\n      limit: 1\n    });\n    return modelMetadata;\n  }\n  getModelDefinition(modelConstructor) {\n    const namespaceName = this.namespaceResolver(modelConstructor);\n    const modelDefinition = this.schema.namespaces[namespaceName].models[modelConstructor.name];\n    return modelDefinition;\n  }\n  static getNamespace() {\n    const namespace = {\n      name: SYNC,\n      relationships: {},\n      enums: {\n        OperationType: {\n          name: 'OperationType',\n          values: ['CREATE', 'UPDATE', 'DELETE']\n        }\n      },\n      nonModels: {},\n      models: {\n        MutationEvent: {\n          name: 'MutationEvent',\n          pluralName: 'MutationEvents',\n          syncable: false,\n          fields: {\n            id: {\n              name: 'id',\n              type: 'ID',\n              isRequired: true,\n              isArray: false\n            },\n            model: {\n              name: 'model',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            data: {\n              name: 'data',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            modelId: {\n              name: 'modelId',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            operation: {\n              name: 'operation',\n              type: {\n                enum: 'Operationtype'\n              },\n              isArray: false,\n              isRequired: true\n            },\n            condition: {\n              name: 'condition',\n              type: 'String',\n              isArray: false,\n              isRequired: true\n            }\n          }\n        },\n        ModelMetadata: {\n          name: 'ModelMetadata',\n          pluralName: 'ModelsMetadata',\n          syncable: false,\n          fields: {\n            id: {\n              name: 'id',\n              type: 'ID',\n              isRequired: true,\n              isArray: false\n            },\n            namespace: {\n              name: 'namespace',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            model: {\n              name: 'model',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            lastSync: {\n              name: 'lastSync',\n              type: 'Int',\n              isRequired: false,\n              isArray: false\n            },\n            lastFullSync: {\n              name: 'lastFullSync',\n              type: 'Int',\n              isRequired: false,\n              isArray: false\n            },\n            fullSyncInterval: {\n              name: 'fullSyncInterval',\n              type: 'Int',\n              isRequired: true,\n              isArray: false\n            },\n            lastSyncPredicate: {\n              name: 'lastSyncPredicate',\n              type: 'String',\n              isRequired: false,\n              isArray: false\n            }\n          }\n        }\n      }\n    };\n    return namespace;\n  }\n  /**\n   * listen for websocket connection disruption\n   *\n   * May indicate there was a period of time where messages\n   * from AppSync were missed. A sync needs to be triggered to\n   * retrieve the missed data.\n   */\n  startDisruptionListener() {\n    return Hub.listen('api', data => {\n      if (data.source === 'PubSub' && data.payload.event === CONNECTION_STATE_CHANGE) {\n        const connectionState = data.payload.data.connectionState;\n        switch (connectionState) {\n          // Do not need to listen for ConnectionDisruptedPendingNetwork\n          // Normal network reconnection logic will handle the sync\n          case ConnectionState.ConnectionDisrupted:\n            this.connectionDisrupted = true;\n            break;\n          case ConnectionState.Connected:\n            if (this.connectionDisrupted) {\n              this.scheduleSync();\n            }\n            this.connectionDisrupted = false;\n            break;\n        }\n      }\n    });\n  }\n  /*\n   * Schedule a sync to start when syncQueriesObservable enters sleep state\n   * Start sync immediately if syncQueriesObservable is already in sleep state\n   */\n  scheduleSync() {\n    return this.runningProcesses.isOpen && this.runningProcesses.add(() => this.waitForSleepState.then(() => {\n      // unsleepSyncQueriesObservable will be set if waitForSleepState has resolved\n      this.unsleepSyncQueriesObservable();\n    }));\n  }\n}\nexport { ControlMessage, SyncEngine };","map":{"version":3,"names":["logger","ConsoleLogger","ownSymbol","Symbol","ControlMessage","SyncEngine","getModelSyncedStatus","modelConstructor","modelSyncedStatus","get","constructor","schema","namespaceResolver","modelClasses","userModelClasses","storage","modelInstanceCreator","conflictHandler","errorHandler","syncPredicates","amplifyConfig","authModeStrategy","amplifyContext","connectivityMonitor","online","WeakMap","connectionDisrupted","runningProcesses","BackgroundProcessManager","waitForSleepState","Promise","resolve","syncQueriesObservableStartSleeping","MutationEvent","outbox","MutationEventOutbox","modelMerger","ModelMerger","syncQueriesProcessor","SyncProcessor","subscriptionsProcessor","SubscriptionProcessor","mutationsProcessor","MutationProcessor","datastoreConnectivity","DataStoreConnectivity","start","params","Observable","observer","log","subscriptions","add","setupModels","err","error","startPromise","doneStarting","failedStarting","status","subscribe","isOpen","onTerminate","next","type","SYNC_ENGINE_NETWORK_STATUS","data","active","ctlSubsObservable","dataSubsObservable","stopDisruptionListener","startDisruptionListener","reject","then","ctlSubsSubscription","msg","CONTROL_MSG","CONNECTED","handleDisconnect","disconnectionHandler","push","SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED","syncQuerySubscription","syncQueriesObservable","message","SYNC_ENGINE_SYNC_QUERIES_READY","complete","modelDefinition","model","item","hasMore","name","runExclusive","merge","SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED","element","SYNC_ENGINE_OUTBOX_STATUS","isEmpty","_transformerMutationType","forEach","sub","unsubscribe","observe","pipe","filter","getModelDefinition","syncable","opType","condition","namespace","namespaces","MutationEventConstructor","graphQLCondition","predicateToGraphQLCondition","mutationEvent","createMutationInstanceFromModelOperation","relationships","enqueue","SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED","resume","SYNC_ENGINE_STORAGE_SUBSCRIBED","hasMutationsInOutbox","peek","undefined","SYNC_ENGINE_READY","getModelsMetadataWithNextFullSync","currentTimeStamp","modelLastSync","Map","getModelsMetadata","map","lastSync","lastFullSync","fullSyncInterval","lastSyncPredicate","nextFullSync","syncFrom","models","of","syncQueriesSubscription","terminated","closed","count","Date","now","paginatingModels","Set","keys","lastFullSyncStartedAt","syncInterval","syncDuration","lastStartedAt","items","done","startedAt","isFullSync","has","set","new","updated","deleted","getNow","Math","max","idsInOutbox","getModelIds","oneByOne","page","itemId","getIdentifierValue","opTypeCount","mergePage","counts","OpType","INSERT","UPDATE","DELETE","Error","modelName","modelMetadata","getModelMetadata","ModelMetadata","copyOf","draft","save","SYNC_ENGINE_MODEL_SYNCED","isDeltaSync","delete","size","SYNC_ENGINE_SYNC_QUERIES_STARTED","Array","from","msNextFullSync","debug","unsleep","sleep","_unsleep","setTimeout","unsleepSyncQueriesObservable","CONTROL_MSG$1","CONNECTION_CLOSED","TIMEOUT_DISCONNECT","socketDisconnected","unsubscribeConnectivity","stop","close","open","ModelMetadataConstructor","savedModel","Object","values","USER","promises","syncPredicate","ModelPredicateCreator","getPredicates","JSON","stringify","prevSyncPredicate","syncPredicateUpdated","result","all","modelsMetadata","query","predicate","createFromAST","SYNC","and","eq","limit","namespaceName","getNamespace","enums","OperationType","nonModels","pluralName","fields","id","isRequired","isArray","modelId","operation","enum","Hub","listen","source","payload","event","CONNECTION_STATE_CHANGE","connectionState","ConnectionState","ConnectionDisrupted","Connected","scheduleSync"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/sync/index.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { BackgroundProcessManager } from '@aws-amplify/core/internals/utils';\nimport { Hub, ConsoleLogger } from '@aws-amplify/core';\nimport { filter, Observable, of } from 'rxjs';\nimport { ModelPredicateCreator } from '../predicates';\nimport { OpType, } from '../types';\nimport { getNow, SYNC, USER } from '../util';\nimport DataStoreConnectivity from './datastoreConnectivity';\nimport { ModelMerger } from './merger';\nimport { MutationEventOutbox } from './outbox';\nimport { MutationProcessor } from './processors/mutation';\nimport { CONTROL_MSG, SubscriptionProcessor } from './processors/subscription';\nimport { SyncProcessor } from './processors/sync';\nimport { createMutationInstanceFromModelOperation, getIdentifierValue, predicateToGraphQLCondition, } from './utils';\nimport { CONTROL_MSG as PUBSUB_CONTROL_MSG, ConnectionState, CONNECTION_STATE_CHANGE as PUBSUB_CONNECTION_STATE_CHANGE, } from '@aws-amplify/api-graphql';\nconst logger = new ConsoleLogger('DataStore');\nconst ownSymbol = Symbol('sync');\nexport var ControlMessage;\n(function (ControlMessage) {\n    ControlMessage[\"SYNC_ENGINE_STORAGE_SUBSCRIBED\"] = \"storageSubscribed\";\n    ControlMessage[\"SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\"] = \"subscriptionsEstablished\";\n    ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_STARTED\"] = \"syncQueriesStarted\";\n    ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_READY\"] = \"syncQueriesReady\";\n    ControlMessage[\"SYNC_ENGINE_MODEL_SYNCED\"] = \"modelSynced\";\n    ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED\"] = \"outboxMutationEnqueued\";\n    ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED\"] = \"outboxMutationProcessed\";\n    ControlMessage[\"SYNC_ENGINE_OUTBOX_STATUS\"] = \"outboxStatus\";\n    ControlMessage[\"SYNC_ENGINE_NETWORK_STATUS\"] = \"networkStatus\";\n    ControlMessage[\"SYNC_ENGINE_READY\"] = \"ready\";\n})(ControlMessage || (ControlMessage = {}));\nexport class SyncEngine {\n    getModelSyncedStatus(modelConstructor) {\n        return this.modelSyncedStatus.get(modelConstructor);\n    }\n    constructor(schema, namespaceResolver, modelClasses, userModelClasses, storage, modelInstanceCreator, conflictHandler, errorHandler, syncPredicates, amplifyConfig = {}, authModeStrategy, amplifyContext, connectivityMonitor) {\n        this.schema = schema;\n        this.namespaceResolver = namespaceResolver;\n        this.modelClasses = modelClasses;\n        this.userModelClasses = userModelClasses;\n        this.storage = storage;\n        this.modelInstanceCreator = modelInstanceCreator;\n        this.syncPredicates = syncPredicates;\n        this.amplifyConfig = amplifyConfig;\n        this.authModeStrategy = authModeStrategy;\n        this.amplifyContext = amplifyContext;\n        this.connectivityMonitor = connectivityMonitor;\n        this.online = false;\n        this.modelSyncedStatus = new WeakMap();\n        this.connectionDisrupted = false;\n        this.runningProcesses = new BackgroundProcessManager();\n        this.waitForSleepState = new Promise(resolve => {\n            this.syncQueriesObservableStartSleeping = resolve;\n        });\n        const MutationEvent = this.modelClasses['MutationEvent'];\n        this.outbox = new MutationEventOutbox(this.schema, MutationEvent, modelInstanceCreator, ownSymbol);\n        this.modelMerger = new ModelMerger(this.outbox, ownSymbol);\n        this.syncQueriesProcessor = new SyncProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n        this.subscriptionsProcessor = new SubscriptionProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n        this.mutationsProcessor = new MutationProcessor(this.schema, this.storage, this.userModelClasses, this.outbox, this.modelInstanceCreator, MutationEvent, this.amplifyConfig, this.authModeStrategy, errorHandler, conflictHandler, this.amplifyContext);\n        this.datastoreConnectivity =\n            this.connectivityMonitor || new DataStoreConnectivity();\n    }\n    start(params) {\n        return new Observable(observer => {\n            logger.log('starting sync engine...');\n            let subscriptions = [];\n            this.runningProcesses.add(async () => {\n                try {\n                    await this.setupModels(params);\n                }\n                catch (err) {\n                    observer.error(err);\n                    return;\n                }\n                // this is awaited at the bottom. so, we don't need to register\n                // this explicitly with the context. it's already contained.\n                const startPromise = new Promise((doneStarting, failedStarting) => {\n                    this.datastoreConnectivity.status().subscribe(async ({ online }) => this.runningProcesses.isOpen &&\n                        this.runningProcesses.add(async (onTerminate) => {\n                            // From offline to online\n                            if (online && !this.online) {\n                                this.online = online;\n                                observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                                    data: {\n                                        active: this.online,\n                                    },\n                                });\n                                let ctlSubsObservable;\n                                let dataSubsObservable;\n                                this.stopDisruptionListener =\n                                    this.startDisruptionListener();\n                                //#region GraphQL Subscriptions\n                                [ctlSubsObservable, dataSubsObservable] =\n                                    this.subscriptionsProcessor.start();\n                                try {\n                                    await new Promise((resolve, reject) => {\n                                        onTerminate.then(reject);\n                                        const ctlSubsSubscription = ctlSubsObservable.subscribe({\n                                            next: msg => {\n                                                if (msg === CONTROL_MSG.CONNECTED) {\n                                                    resolve();\n                                                }\n                                            },\n                                            error: err => {\n                                                reject(err);\n                                                const handleDisconnect = this.disconnectionHandler();\n                                                handleDisconnect(err);\n                                            },\n                                        });\n                                        subscriptions.push(ctlSubsSubscription);\n                                    });\n                                }\n                                catch (err) {\n                                    observer.error(err);\n                                    failedStarting();\n                                    return;\n                                }\n                                logger.log('Realtime ready');\n                                observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED,\n                                });\n                                //#endregion\n                                //#region Base & Sync queries\n                                try {\n                                    await new Promise((resolve, reject) => {\n                                        const syncQuerySubscription = this.syncQueriesObservable().subscribe({\n                                            next: message => {\n                                                const { type } = message;\n                                                if (type ===\n                                                    ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY) {\n                                                    resolve();\n                                                }\n                                                observer.next(message);\n                                            },\n                                            complete: () => {\n                                                resolve();\n                                            },\n                                            error: error => {\n                                                reject(error);\n                                            },\n                                        });\n                                        if (syncQuerySubscription) {\n                                            subscriptions.push(syncQuerySubscription);\n                                        }\n                                    });\n                                }\n                                catch (error) {\n                                    observer.error(error);\n                                    failedStarting();\n                                    return;\n                                }\n                                //#endregion\n                                //#region process mutations (outbox)\n                                subscriptions.push(this.mutationsProcessor\n                                    .start()\n                                    .subscribe(({ modelDefinition, model: item, hasMore }) => this.runningProcesses.add(async () => {\n                                    const modelConstructor = this.userModelClasses[modelDefinition.name];\n                                    const model = this.modelInstanceCreator(modelConstructor, item);\n                                    await this.storage.runExclusive(storage => this.modelMerger.merge(storage, model, modelDefinition));\n                                    observer.next({\n                                        type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED,\n                                        data: {\n                                            model: modelConstructor,\n                                            element: model,\n                                        },\n                                    });\n                                    observer.next({\n                                        type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                                        data: {\n                                            isEmpty: !hasMore,\n                                        },\n                                    });\n                                }, 'mutation processor event')));\n                                //#endregion\n                                //#region Merge subscriptions buffer\n                                subscriptions.push(dataSubsObservable.subscribe(([_transformerMutationType, modelDefinition, item]) => this.runningProcesses.add(async () => {\n                                    const modelConstructor = this.userModelClasses[modelDefinition.name];\n                                    const model = this.modelInstanceCreator(modelConstructor, item);\n                                    await this.storage.runExclusive(storage => this.modelMerger.merge(storage, model, modelDefinition));\n                                }, 'subscription dataSubsObservable event')));\n                                //#endregion\n                            }\n                            else if (!online) {\n                                this.online = online;\n                                observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                                    data: {\n                                        active: this.online,\n                                    },\n                                });\n                                subscriptions.forEach(sub => sub.unsubscribe());\n                                subscriptions = [];\n                            }\n                            doneStarting();\n                        }, 'datastore connectivity event'));\n                });\n                this.storage\n                    .observe(null, null, ownSymbol)\n                    .pipe(filter(({ model }) => {\n                    const modelDefinition = this.getModelDefinition(model);\n                    return modelDefinition.syncable === true;\n                }))\n                    .subscribe({\n                    next: async ({ opType, model, element, condition }) => this.runningProcesses.add(async () => {\n                        const namespace = this.schema.namespaces[this.namespaceResolver(model)];\n                        const MutationEventConstructor = this.modelClasses['MutationEvent'];\n                        const modelDefinition = this.getModelDefinition(model);\n                        const graphQLCondition = predicateToGraphQLCondition(condition, modelDefinition);\n                        const mutationEvent = createMutationInstanceFromModelOperation(namespace.relationships, this.getModelDefinition(model), opType, model, element, graphQLCondition, MutationEventConstructor, this.modelInstanceCreator);\n                        await this.outbox.enqueue(this.storage, mutationEvent);\n                        observer.next({\n                            type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED,\n                            data: {\n                                model,\n                                element,\n                            },\n                        });\n                        observer.next({\n                            type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                            data: {\n                                isEmpty: false,\n                            },\n                        });\n                        await startPromise;\n                        // Set by the this.datastoreConnectivity.status().subscribe() loop\n                        if (this.online) {\n                            this.mutationsProcessor.resume();\n                        }\n                    }, 'storage event'),\n                });\n                observer.next({\n                    type: ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED,\n                });\n                const hasMutationsInOutbox = (await this.outbox.peek(this.storage)) === undefined;\n                observer.next({\n                    type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                    data: {\n                        isEmpty: hasMutationsInOutbox,\n                    },\n                });\n                await startPromise;\n                observer.next({\n                    type: ControlMessage.SYNC_ENGINE_READY,\n                });\n            }, 'sync start');\n        });\n    }\n    async getModelsMetadataWithNextFullSync(currentTimeStamp) {\n        const modelLastSync = new Map((await this.runningProcesses.add(() => this.getModelsMetadata(), 'sync/index getModelsMetadataWithNextFullSync')).map(({ namespace, model, lastSync, lastFullSync, fullSyncInterval, lastSyncPredicate, }) => {\n            const nextFullSync = lastFullSync + fullSyncInterval;\n            const syncFrom = !lastFullSync || nextFullSync < currentTimeStamp\n                ? 0 // perform full sync if expired\n                : lastSync; // perform delta sync\n            return [\n                this.schema.namespaces[namespace].models[model],\n                [namespace, syncFrom],\n            ];\n        }));\n        return modelLastSync;\n    }\n    syncQueriesObservable() {\n        if (!this.online) {\n            return of({}); // TODO(v6): fix this\n        }\n        return new Observable(observer => {\n            let syncQueriesSubscription;\n            this.runningProcesses.isOpen &&\n                this.runningProcesses.add(async (onTerminate) => {\n                    let terminated = false;\n                    while (!observer.closed && !terminated) {\n                        const count = new WeakMap();\n                        const modelLastSync = await this.getModelsMetadataWithNextFullSync(Date.now());\n                        const paginatingModels = new Set(modelLastSync.keys());\n                        let lastFullSyncStartedAt;\n                        let syncInterval;\n                        let start;\n                        let syncDuration;\n                        let lastStartedAt;\n                        await new Promise((resolve, reject) => {\n                            if (!this.runningProcesses.isOpen)\n                                resolve();\n                            onTerminate.then(() => resolve());\n                            syncQueriesSubscription = this.syncQueriesProcessor\n                                .start(modelLastSync)\n                                .subscribe({\n                                next: async ({ namespace, modelDefinition, items, done, startedAt, isFullSync, }) => {\n                                    const modelConstructor = this.userModelClasses[modelDefinition.name];\n                                    if (!count.has(modelConstructor)) {\n                                        count.set(modelConstructor, {\n                                            new: 0,\n                                            updated: 0,\n                                            deleted: 0,\n                                        });\n                                        start = getNow();\n                                        lastStartedAt =\n                                            lastStartedAt === undefined\n                                                ? startedAt\n                                                : Math.max(lastStartedAt, startedAt);\n                                    }\n                                    /**\n                                     * If there are mutations in the outbox for a given id, those need to be\n                                     * merged individually. Otherwise, we can merge them in batches.\n                                     */\n                                    await this.storage.runExclusive(async (storage) => {\n                                        const idsInOutbox = await this.outbox.getModelIds(storage);\n                                        const oneByOne = [];\n                                        const page = items.filter(item => {\n                                            const itemId = getIdentifierValue(modelDefinition, item);\n                                            if (!idsInOutbox.has(itemId)) {\n                                                return true;\n                                            }\n                                            oneByOne.push(item);\n                                            return false;\n                                        });\n                                        const opTypeCount = [];\n                                        for (const item of oneByOne) {\n                                            const opType = await this.modelMerger.merge(storage, item, modelDefinition);\n                                            if (opType !== undefined) {\n                                                opTypeCount.push([item, opType]);\n                                            }\n                                        }\n                                        opTypeCount.push(...(await this.modelMerger.mergePage(storage, modelConstructor, page, modelDefinition)));\n                                        const counts = count.get(modelConstructor);\n                                        opTypeCount.forEach(([, opType]) => {\n                                            switch (opType) {\n                                                case OpType.INSERT:\n                                                    counts.new++;\n                                                    break;\n                                                case OpType.UPDATE:\n                                                    counts.updated++;\n                                                    break;\n                                                case OpType.DELETE:\n                                                    counts.deleted++;\n                                                    break;\n                                                default:\n                                                    throw new Error(`Invalid opType ${opType}`);\n                                            }\n                                        });\n                                    });\n                                    if (done) {\n                                        const { name: modelName } = modelDefinition;\n                                        //#region update last sync for type\n                                        let modelMetadata = await this.getModelMetadata(namespace, modelName);\n                                        const { lastFullSync, fullSyncInterval } = modelMetadata;\n                                        syncInterval = fullSyncInterval;\n                                        lastFullSyncStartedAt =\n                                            lastFullSyncStartedAt === undefined\n                                                ? lastFullSync\n                                                : Math.max(lastFullSyncStartedAt, isFullSync ? startedAt : lastFullSync);\n                                        modelMetadata = this.modelClasses\n                                            .ModelMetadata.copyOf(modelMetadata, draft => {\n                                            draft.lastSync = startedAt;\n                                            draft.lastFullSync = isFullSync\n                                                ? startedAt\n                                                : modelMetadata.lastFullSync;\n                                        });\n                                        await this.storage.save(modelMetadata, undefined, ownSymbol);\n                                        //#endregion\n                                        const counts = count.get(modelConstructor);\n                                        this.modelSyncedStatus.set(modelConstructor, true);\n                                        observer.next({\n                                            type: ControlMessage.SYNC_ENGINE_MODEL_SYNCED,\n                                            data: {\n                                                model: modelConstructor,\n                                                isFullSync,\n                                                isDeltaSync: !isFullSync,\n                                                counts,\n                                            },\n                                        });\n                                        paginatingModels.delete(modelDefinition);\n                                        if (paginatingModels.size === 0) {\n                                            syncDuration = getNow() - start;\n                                            resolve();\n                                            observer.next({\n                                                type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY,\n                                            });\n                                            syncQueriesSubscription.unsubscribe();\n                                        }\n                                    }\n                                },\n                                error: error => {\n                                    observer.error(error);\n                                },\n                            });\n                            observer.next({\n                                type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_STARTED,\n                                data: {\n                                    models: Array.from(paginatingModels).map(({ name }) => name),\n                                },\n                            });\n                        });\n                        // null is cast to 0 resulting in unexpected behavior.\n                        // undefined in arithmetic operations results in NaN also resulting in unexpected behavior.\n                        // If lastFullSyncStartedAt is null this is the first sync.\n                        // Assume lastStartedAt is is also newest full sync.\n                        let msNextFullSync;\n                        if (!lastFullSyncStartedAt) {\n                            msNextFullSync = syncInterval - syncDuration;\n                        }\n                        else {\n                            msNextFullSync =\n                                lastFullSyncStartedAt +\n                                    syncInterval -\n                                    (lastStartedAt + syncDuration);\n                        }\n                        logger.debug(`Next fullSync in ${msNextFullSync / 1000} seconds. (${new Date(Date.now() + msNextFullSync)})`);\n                        // TODO: create `BackgroundProcessManager.sleep()` ... but, need to put\n                        // a lot of thought into what that contract looks like to\n                        //  support possible use-cases:\n                        //\n                        //  1. non-cancelable\n                        //  2. cancelable, unsleep on exit()\n                        //  3. cancelable, throw Error on exit()\n                        //  4. cancelable, callback first on exit()?\n                        //  5. ... etc. ? ...\n                        //\n                        // TLDR; this is a lot of complexity here for a sleep(),\n                        // but, it's not clear to me yet how to support an\n                        // extensible, centralized cancelable `sleep()` elegantly.\n                        await this.runningProcesses.add(async (onTerminate) => {\n                            let sleepTimer;\n                            let unsleep;\n                            const sleep = new Promise(_unsleep => {\n                                unsleep = _unsleep;\n                                sleepTimer = setTimeout(unsleep, msNextFullSync);\n                            });\n                            onTerminate.then(() => {\n                                terminated = true;\n                                this.syncQueriesObservableStartSleeping();\n                                unsleep();\n                            });\n                            this.unsleepSyncQueriesObservable = unsleep;\n                            this.syncQueriesObservableStartSleeping();\n                            return sleep;\n                        }, 'syncQueriesObservable sleep');\n                        this.unsleepSyncQueriesObservable = null;\n                        this.waitForSleepState = new Promise(resolve => {\n                            this.syncQueriesObservableStartSleeping = resolve;\n                        });\n                    }\n                }, 'syncQueriesObservable main');\n        });\n    }\n    disconnectionHandler() {\n        return (msg) => {\n            // This implementation is tied to AWSAppSyncRealTimeProvider 'Connection closed', 'Timeout disconnect' msg\n            if (PUBSUB_CONTROL_MSG.CONNECTION_CLOSED === msg ||\n                PUBSUB_CONTROL_MSG.TIMEOUT_DISCONNECT === msg) {\n                this.datastoreConnectivity.socketDisconnected();\n            }\n        };\n    }\n    unsubscribeConnectivity() {\n        this.datastoreConnectivity.unsubscribe();\n    }\n    /**\n     * Stops all subscription activities and resolves when all activies report\n     * that they're disconnected, done retrying, etc..\n     */\n    async stop() {\n        logger.debug('stopping sync engine');\n        /**\n         * Gracefully disconnecting subscribers first just prevents *more* work\n         * from entering the pipelines.\n         */\n        this.unsubscribeConnectivity();\n        /**\n         * Stop listening for websocket connection disruption\n         */\n        this.stopDisruptionListener && this.stopDisruptionListener();\n        /**\n         * aggressively shut down any lingering background processes.\n         * some of this might be semi-redundant with unsubscribing. however,\n         * unsubscribing doesn't allow us to wait for settling.\n         * (Whereas `stop()` does.)\n         */\n        await this.mutationsProcessor.stop();\n        await this.subscriptionsProcessor.stop();\n        await this.datastoreConnectivity.stop();\n        await this.syncQueriesProcessor.stop();\n        await this.runningProcesses.close();\n        await this.runningProcesses.open();\n        logger.debug('sync engine stopped and ready to restart');\n    }\n    async setupModels(params) {\n        const { fullSyncInterval } = params;\n        const ModelMetadataConstructor = this.modelClasses\n            .ModelMetadata;\n        const models = [];\n        let savedModel;\n        Object.values(this.schema.namespaces).forEach(namespace => {\n            Object.values(namespace.models)\n                .filter(({ syncable }) => syncable)\n                .forEach(model => {\n                models.push([namespace.name, model]);\n                if (namespace.name === USER) {\n                    const modelConstructor = this.userModelClasses[model.name];\n                    this.modelSyncedStatus.set(modelConstructor, false);\n                }\n            });\n        });\n        const promises = models.map(async ([namespace, model]) => {\n            const modelMetadata = await this.getModelMetadata(namespace, model.name);\n            const syncPredicate = ModelPredicateCreator.getPredicates(this.syncPredicates.get(model), false);\n            const lastSyncPredicate = syncPredicate\n                ? JSON.stringify(syncPredicate)\n                : null;\n            if (modelMetadata === undefined) {\n                [[savedModel]] = await this.storage.save(this.modelInstanceCreator(ModelMetadataConstructor, {\n                    model: model.name,\n                    namespace,\n                    lastSync: null,\n                    fullSyncInterval,\n                    lastFullSync: null,\n                    lastSyncPredicate,\n                }), undefined, ownSymbol);\n            }\n            else {\n                const prevSyncPredicate = modelMetadata.lastSyncPredicate\n                    ? modelMetadata.lastSyncPredicate\n                    : null;\n                const syncPredicateUpdated = prevSyncPredicate !== lastSyncPredicate;\n                [[savedModel]] = await this.storage.save(ModelMetadataConstructor.copyOf(modelMetadata, draft => {\n                    draft.fullSyncInterval = fullSyncInterval;\n                    // perform a base sync if the syncPredicate changed in between calls to DataStore.start\n                    // ensures that the local store contains all the data specified by the syncExpression\n                    if (syncPredicateUpdated) {\n                        draft.lastSync = null;\n                        draft.lastFullSync = null;\n                        draft.lastSyncPredicate = lastSyncPredicate;\n                    }\n                }));\n            }\n            return savedModel;\n        });\n        const result = {};\n        for (const modelMetadata of await Promise.all(promises)) {\n            const { model: modelName } = modelMetadata;\n            result[modelName] = modelMetadata;\n        }\n        return result;\n    }\n    async getModelsMetadata() {\n        const ModelMetadata = this.modelClasses\n            .ModelMetadata;\n        const modelsMetadata = await this.storage.query(ModelMetadata);\n        return modelsMetadata;\n    }\n    async getModelMetadata(namespace, model) {\n        const ModelMetadata = this.modelClasses\n            .ModelMetadata;\n        const predicate = ModelPredicateCreator.createFromAST(this.schema.namespaces[SYNC].models[ModelMetadata.name], { and: [{ namespace: { eq: namespace } }, { model: { eq: model } }] });\n        const [modelMetadata] = await this.storage.query(ModelMetadata, predicate, {\n            page: 0,\n            limit: 1,\n        });\n        return modelMetadata;\n    }\n    getModelDefinition(modelConstructor) {\n        const namespaceName = this.namespaceResolver(modelConstructor);\n        const modelDefinition = this.schema.namespaces[namespaceName].models[modelConstructor.name];\n        return modelDefinition;\n    }\n    static getNamespace() {\n        const namespace = {\n            name: SYNC,\n            relationships: {},\n            enums: {\n                OperationType: {\n                    name: 'OperationType',\n                    values: ['CREATE', 'UPDATE', 'DELETE'],\n                },\n            },\n            nonModels: {},\n            models: {\n                MutationEvent: {\n                    name: 'MutationEvent',\n                    pluralName: 'MutationEvents',\n                    syncable: false,\n                    fields: {\n                        id: {\n                            name: 'id',\n                            type: 'ID',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        model: {\n                            name: 'model',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        data: {\n                            name: 'data',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        modelId: {\n                            name: 'modelId',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        operation: {\n                            name: 'operation',\n                            type: {\n                                enum: 'Operationtype',\n                            },\n                            isArray: false,\n                            isRequired: true,\n                        },\n                        condition: {\n                            name: 'condition',\n                            type: 'String',\n                            isArray: false,\n                            isRequired: true,\n                        },\n                    },\n                },\n                ModelMetadata: {\n                    name: 'ModelMetadata',\n                    pluralName: 'ModelsMetadata',\n                    syncable: false,\n                    fields: {\n                        id: {\n                            name: 'id',\n                            type: 'ID',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        namespace: {\n                            name: 'namespace',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        model: {\n                            name: 'model',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        lastSync: {\n                            name: 'lastSync',\n                            type: 'Int',\n                            isRequired: false,\n                            isArray: false,\n                        },\n                        lastFullSync: {\n                            name: 'lastFullSync',\n                            type: 'Int',\n                            isRequired: false,\n                            isArray: false,\n                        },\n                        fullSyncInterval: {\n                            name: 'fullSyncInterval',\n                            type: 'Int',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        lastSyncPredicate: {\n                            name: 'lastSyncPredicate',\n                            type: 'String',\n                            isRequired: false,\n                            isArray: false,\n                        },\n                    },\n                },\n            },\n        };\n        return namespace;\n    }\n    /**\n     * listen for websocket connection disruption\n     *\n     * May indicate there was a period of time where messages\n     * from AppSync were missed. A sync needs to be triggered to\n     * retrieve the missed data.\n     */\n    startDisruptionListener() {\n        return Hub.listen('api', (data) => {\n            if (data.source === 'PubSub' &&\n                data.payload.event === PUBSUB_CONNECTION_STATE_CHANGE) {\n                const connectionState = data.payload.data\n                    .connectionState;\n                switch (connectionState) {\n                    // Do not need to listen for ConnectionDisruptedPendingNetwork\n                    // Normal network reconnection logic will handle the sync\n                    case ConnectionState.ConnectionDisrupted:\n                        this.connectionDisrupted = true;\n                        break;\n                    case ConnectionState.Connected:\n                        if (this.connectionDisrupted) {\n                            this.scheduleSync();\n                        }\n                        this.connectionDisrupted = false;\n                        break;\n                }\n            }\n        });\n    }\n    /*\n     * Schedule a sync to start when syncQueriesObservable enters sleep state\n     * Start sync immediately if syncQueriesObservable is already in sleep state\n     */\n    scheduleSync() {\n        return (this.runningProcesses.isOpen &&\n            this.runningProcesses.add(() => this.waitForSleepState.then(() => {\n                // unsleepSyncQueriesObservable will be set if waitForSleepState has resolved\n                this.unsleepSyncQueriesObservable();\n            })));\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}