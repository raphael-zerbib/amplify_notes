{"ast":null,"code":"import { extractPrimaryKeyFieldNames, extractPrimaryKeyValues } from '../util.mjs';\nexport { ModelSortPredicateCreator } from './sort.mjs';\nconst predicatesAllSet = new WeakSet();\nfunction isPredicatesAll(predicate) {\n  return predicatesAllSet.has(predicate);\n}\n/**\n * The valid logical grouping keys for a predicate group.\n */\nconst groupKeys = new Set(['and', 'or', 'not']);\n/**\n * Determines whether an object is a GraphQL style predicate \"group\", which must be an\n * object containing a single \"group key\", which then contains the child condition(s).\n *\n * E.g.,\n *\n * ```\n * { and: [ ... ] }\n * { not: { ... } }\n * ```\n *\n * @param o The object to test.\n */\nconst isGroup = o => {\n  const keys = [...Object.keys(o)];\n  return keys.length === 1 && groupKeys.has(keys[0]);\n};\n/**\n * Determines whether an object specifies no conditions and should match everything,\n * as would be the case with `Predicates.ALL`.\n *\n * @param o The object to test.\n */\nconst isEmpty = o => {\n  return !Array.isArray(o) && Object.keys(o).length === 0;\n};\n/**\n * The valid comparison operators that can be used as keys in a predicate comparison object.\n */\nconst comparisonKeys = new Set(['eq', 'ne', 'gt', 'lt', 'ge', 'le', 'contains', 'notContains', 'beginsWith', 'between']);\n/**\n * Determines whether an object is a GraphQL style predicate comparison node, which must\n * be an object containing a single \"comparison operator\" key, which then contains the\n * operand or operands to compare against.\n *\n * @param o The object to test.\n */\nconst isComparison = o => {\n  const keys = [...Object.keys(o)];\n  return !Array.isArray(o) && keys.length === 1 && comparisonKeys.has(keys[0]);\n};\n/**\n * A light check to determine whether an object is a valid GraphQL Condition AST.\n *\n * @param o The object to test.\n */\nconst isValid = o => {\n  if (Array.isArray(o)) {\n    return o.every(v => isValid(v));\n  } else {\n    return Object.keys(o).length <= 1;\n  }\n};\n// This symbol is not used at runtime, only its type (unique symbol)\nconst PredicateAll = Symbol('A predicate that matches all records');\nclass Predicates {\n  static get ALL() {\n    const predicate = c => c;\n    predicatesAllSet.add(predicate);\n    return predicate;\n  }\n}\nclass ModelPredicateCreator {\n  /**\n   * Determines whether the given storage predicate (lookup key) is a predicate\n   * key that DataStore recognizes.\n   *\n   * @param predicate The storage predicate (lookup key) to test.\n   */\n  static isValidPredicate(predicate) {\n    return ModelPredicateCreator.predicateGroupsMap.has(predicate);\n  }\n  /**\n   * Looks for the storage predicate AST that corresponds to a given storage\n   * predicate key.\n   *\n   * The key must have been created internally by a DataStore utility\n   * method, such as `ModelPredicate.createFromAST()`.\n   *\n   * @param predicate The predicate reference to look up.\n   * @param throwOnInvalid Whether to throw an exception if the predicate\n   * isn't a valid DataStore predicate.\n   */\n  static getPredicates(predicate) {\n    let throwOnInvalid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (throwOnInvalid && !ModelPredicateCreator.isValidPredicate(predicate)) {\n      throw new Error('The predicate is not valid');\n    }\n    return ModelPredicateCreator.predicateGroupsMap.get(predicate);\n  }\n  /**\n   * using the PK values from the given `model` (which can be a partial of T\n   * Creates a predicate that matches an instance described by `modelDefinition`\n   * that contains only PK field values.)\n   *\n   * @param modelDefinition The model definition to create a predicate for.\n   * @param model The model instance to extract value equalities from.\n   */\n  static createForPk(modelDefinition, model) {\n    const keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n    const keyValues = extractPrimaryKeyValues(model, keyFields);\n    const predicate = this.createFromAST(modelDefinition, {\n      and: keyFields.map((field, idx) => {\n        const operand = keyValues[idx];\n        return {\n          [field]: {\n            eq: operand\n          }\n        };\n      })\n    });\n    return predicate;\n  }\n  /**\n   * Searches a `Model` table for records matching the given equalities object.\n   *\n   * This only matches against fields given in the equalities object. No other\n   * fields are tested by the predicate.\n   *\n   * @param modelDefinition The model we need a predicate for.\n   * @param flatEqualities An object holding field equalities to search for.\n   */\n  static createFromFlatEqualities(modelDefinition, flatEqualities) {\n    const ast = {\n      and: Object.entries(flatEqualities).map(_ref => {\n        let [k, v] = _ref;\n        return {\n          [k]: {\n            eq: v\n          }\n        };\n      })\n    };\n    return this.createFromAST(modelDefinition, ast);\n  }\n  /**\n   * Accepts a GraphQL style filter predicate tree and transforms it into an\n   * AST that can be used for a storage adapter predicate. Example input:\n   *\n   * ```js\n   * {\n   * \tand: [\n   * \t\t{ name: { eq: \"Bob Jones\" } },\n   * \t\t{ age: { between: [32, 64] } },\n   * \t\t{ not: {\n   * \t\t\tor: [\n   * \t\t\t\t{ favoriteFood: { eq: 'pizza' } },\n   * \t\t\t\t{ favoriteFood: { eq: 'tacos' } },\n   * \t\t\t]\n   * \t\t}}\n   * \t]\n   * }\n   * ```\n   *\n   * @param gql GraphQL style filter node.\n   */\n  static transformGraphQLFilterNodeToPredicateAST(gql) {\n    if (!isValid(gql)) {\n      throw new Error('Invalid GraphQL Condition or subtree: ' + JSON.stringify(gql));\n    }\n    if (isEmpty(gql)) {\n      return {\n        type: 'and',\n        predicates: []\n      };\n    } else if (isGroup(gql)) {\n      const groupkey = Object.keys(gql)[0];\n      const children = this.transformGraphQLFilterNodeToPredicateAST(gql[groupkey]);\n      return {\n        type: groupkey,\n        predicates: Array.isArray(children) ? children : [children]\n      };\n    } else if (isComparison(gql)) {\n      const operatorKey = Object.keys(gql)[0];\n      return {\n        operator: operatorKey,\n        operand: gql[operatorKey]\n      };\n    } else {\n      if (Array.isArray(gql)) {\n        return gql.map(o => this.transformGraphQLFilterNodeToPredicateAST(o));\n      } else {\n        const fieldKey = Object.keys(gql)[0];\n        return {\n          field: fieldKey,\n          ...this.transformGraphQLFilterNodeToPredicateAST(gql[fieldKey])\n        };\n      }\n    }\n  }\n  /**\n   * Accepts a GraphQL style filter predicate tree and transforms it into a predicate\n   * that storage adapters understand. Example input:\n   *\n   * ```js\n   * {\n   * \tand: [\n   * \t\t{ name: { eq: \"Bob Jones\" } },\n   * \t\t{ age: { between: [32, 64] } },\n   * \t\t{ not: {\n   * \t\t\tor: [\n   * \t\t\t\t{ favoriteFood: { eq: 'pizza' } },\n   * \t\t\t\t{ favoriteFood: { eq: 'tacos' } },\n   * \t\t\t]\n   * \t\t}}\n   * \t]\n   * }\n   * ```\n   *\n   * @param modelDefinition The model that the AST/predicate must be compatible with.\n   * @param ast The graphQL style AST that should specify conditions for `modelDefinition`.\n   */\n  static createFromAST(modelDefinition, ast) {\n    const key = {};\n    ModelPredicateCreator.predicateGroupsMap.set(key, this.transformGraphQLFilterNodeToPredicateAST(ast));\n    return key;\n  }\n}\n/**\n * Map of storage predicates (key objects) to storage predicate AST's.\n */\nModelPredicateCreator.predicateGroupsMap = new WeakMap();\nexport { ModelPredicateCreator, PredicateAll, Predicates, comparisonKeys, isPredicatesAll };","map":{"version":3,"names":["predicatesAllSet","WeakSet","isPredicatesAll","predicate","has","groupKeys","Set","isGroup","o","keys","Object","length","isEmpty","Array","isArray","comparisonKeys","isComparison","isValid","every","v","PredicateAll","Symbol","Predicates","ALL","c","add","ModelPredicateCreator","isValidPredicate","predicateGroupsMap","getPredicates","throwOnInvalid","arguments","undefined","Error","get","createForPk","modelDefinition","model","keyFields","extractPrimaryKeyFieldNames","keyValues","extractPrimaryKeyValues","createFromAST","and","map","field","idx","operand","eq","createFromFlatEqualities","flatEqualities","ast","entries","_ref","k","transformGraphQLFilterNodeToPredicateAST","gql","JSON","stringify","type","predicates","groupkey","children","operatorKey","operator","fieldKey","key","set","WeakMap"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/predicates/index.ts"],"sourcesContent":["import { extractPrimaryKeyFieldNames, extractPrimaryKeyValues } from '../util';\nexport { ModelSortPredicateCreator } from './sort';\nconst predicatesAllSet = new WeakSet();\nexport function isPredicatesAll(predicate) {\n    return predicatesAllSet.has(predicate);\n}\n/**\n * The valid logical grouping keys for a predicate group.\n */\nconst groupKeys = new Set(['and', 'or', 'not']);\n/**\n * Determines whether an object is a GraphQL style predicate \"group\", which must be an\n * object containing a single \"group key\", which then contains the child condition(s).\n *\n * E.g.,\n *\n * ```\n * { and: [ ... ] }\n * { not: { ... } }\n * ```\n *\n * @param o The object to test.\n */\nconst isGroup = o => {\n    const keys = [...Object.keys(o)];\n    return keys.length === 1 && groupKeys.has(keys[0]);\n};\n/**\n * Determines whether an object specifies no conditions and should match everything,\n * as would be the case with `Predicates.ALL`.\n *\n * @param o The object to test.\n */\nconst isEmpty = o => {\n    return !Array.isArray(o) && Object.keys(o).length === 0;\n};\n/**\n * The valid comparison operators that can be used as keys in a predicate comparison object.\n */\nexport const comparisonKeys = new Set([\n    'eq',\n    'ne',\n    'gt',\n    'lt',\n    'ge',\n    'le',\n    'contains',\n    'notContains',\n    'beginsWith',\n    'between',\n]);\n/**\n * Determines whether an object is a GraphQL style predicate comparison node, which must\n * be an object containing a single \"comparison operator\" key, which then contains the\n * operand or operands to compare against.\n *\n * @param o The object to test.\n */\nconst isComparison = o => {\n    const keys = [...Object.keys(o)];\n    return !Array.isArray(o) && keys.length === 1 && comparisonKeys.has(keys[0]);\n};\n/**\n * A light check to determine whether an object is a valid GraphQL Condition AST.\n *\n * @param o The object to test.\n */\nconst isValid = o => {\n    if (Array.isArray(o)) {\n        return o.every(v => isValid(v));\n    }\n    else {\n        return Object.keys(o).length <= 1;\n    }\n};\n// This symbol is not used at runtime, only its type (unique symbol)\nexport const PredicateAll = Symbol('A predicate that matches all records');\nexport class Predicates {\n    static get ALL() {\n        const predicate = (c => c);\n        predicatesAllSet.add(predicate);\n        return predicate;\n    }\n}\nexport class ModelPredicateCreator {\n    /**\n     * Determines whether the given storage predicate (lookup key) is a predicate\n     * key that DataStore recognizes.\n     *\n     * @param predicate The storage predicate (lookup key) to test.\n     */\n    static isValidPredicate(predicate) {\n        return ModelPredicateCreator.predicateGroupsMap.has(predicate);\n    }\n    /**\n     * Looks for the storage predicate AST that corresponds to a given storage\n     * predicate key.\n     *\n     * The key must have been created internally by a DataStore utility\n     * method, such as `ModelPredicate.createFromAST()`.\n     *\n     * @param predicate The predicate reference to look up.\n     * @param throwOnInvalid Whether to throw an exception if the predicate\n     * isn't a valid DataStore predicate.\n     */\n    static getPredicates(predicate, throwOnInvalid = true) {\n        if (throwOnInvalid && !ModelPredicateCreator.isValidPredicate(predicate)) {\n            throw new Error('The predicate is not valid');\n        }\n        return ModelPredicateCreator.predicateGroupsMap.get(predicate);\n    }\n    /**\n     * using the PK values from the given `model` (which can be a partial of T\n     * Creates a predicate that matches an instance described by `modelDefinition`\n     * that contains only PK field values.)\n     *\n     * @param modelDefinition The model definition to create a predicate for.\n     * @param model The model instance to extract value equalities from.\n     */\n    static createForPk(modelDefinition, model) {\n        const keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n        const keyValues = extractPrimaryKeyValues(model, keyFields);\n        const predicate = this.createFromAST(modelDefinition, {\n            and: keyFields.map((field, idx) => {\n                const operand = keyValues[idx];\n                return { [field]: { eq: operand } };\n            }),\n        });\n        return predicate;\n    }\n    /**\n     * Searches a `Model` table for records matching the given equalities object.\n     *\n     * This only matches against fields given in the equalities object. No other\n     * fields are tested by the predicate.\n     *\n     * @param modelDefinition The model we need a predicate for.\n     * @param flatEqualities An object holding field equalities to search for.\n     */\n    static createFromFlatEqualities(modelDefinition, flatEqualities) {\n        const ast = {\n            and: Object.entries(flatEqualities).map(([k, v]) => ({ [k]: { eq: v } })),\n        };\n        return this.createFromAST(modelDefinition, ast);\n    }\n    /**\n     * Accepts a GraphQL style filter predicate tree and transforms it into an\n     * AST that can be used for a storage adapter predicate. Example input:\n     *\n     * ```js\n     * {\n     * \tand: [\n     * \t\t{ name: { eq: \"Bob Jones\" } },\n     * \t\t{ age: { between: [32, 64] } },\n     * \t\t{ not: {\n     * \t\t\tor: [\n     * \t\t\t\t{ favoriteFood: { eq: 'pizza' } },\n     * \t\t\t\t{ favoriteFood: { eq: 'tacos' } },\n     * \t\t\t]\n     * \t\t}}\n     * \t]\n     * }\n     * ```\n     *\n     * @param gql GraphQL style filter node.\n     */\n    static transformGraphQLFilterNodeToPredicateAST(gql) {\n        if (!isValid(gql)) {\n            throw new Error('Invalid GraphQL Condition or subtree: ' + JSON.stringify(gql));\n        }\n        if (isEmpty(gql)) {\n            return {\n                type: 'and',\n                predicates: [],\n            };\n        }\n        else if (isGroup(gql)) {\n            const groupkey = Object.keys(gql)[0];\n            const children = this.transformGraphQLFilterNodeToPredicateAST(gql[groupkey]);\n            return {\n                type: groupkey,\n                predicates: Array.isArray(children) ? children : [children],\n            };\n        }\n        else if (isComparison(gql)) {\n            const operatorKey = Object.keys(gql)[0];\n            return {\n                operator: operatorKey,\n                operand: gql[operatorKey],\n            };\n        }\n        else {\n            if (Array.isArray(gql)) {\n                return gql.map(o => this.transformGraphQLFilterNodeToPredicateAST(o));\n            }\n            else {\n                const fieldKey = Object.keys(gql)[0];\n                return {\n                    field: fieldKey,\n                    ...this.transformGraphQLFilterNodeToPredicateAST(gql[fieldKey]),\n                };\n            }\n        }\n    }\n    /**\n     * Accepts a GraphQL style filter predicate tree and transforms it into a predicate\n     * that storage adapters understand. Example input:\n     *\n     * ```js\n     * {\n     * \tand: [\n     * \t\t{ name: { eq: \"Bob Jones\" } },\n     * \t\t{ age: { between: [32, 64] } },\n     * \t\t{ not: {\n     * \t\t\tor: [\n     * \t\t\t\t{ favoriteFood: { eq: 'pizza' } },\n     * \t\t\t\t{ favoriteFood: { eq: 'tacos' } },\n     * \t\t\t]\n     * \t\t}}\n     * \t]\n     * }\n     * ```\n     *\n     * @param modelDefinition The model that the AST/predicate must be compatible with.\n     * @param ast The graphQL style AST that should specify conditions for `modelDefinition`.\n     */\n    static createFromAST(modelDefinition, ast) {\n        const key = {};\n        ModelPredicateCreator.predicateGroupsMap.set(key, this.transformGraphQLFilterNodeToPredicateAST(ast));\n        return key;\n    }\n}\n/**\n * Map of storage predicates (key objects) to storage predicate AST's.\n */\nModelPredicateCreator.predicateGroupsMap = new WeakMap();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}