{"ast":null,"code":"import { GraphQLAuthError } from '@aws-amplify/api';\nimport { isSchemaModel, isSchemaModelWithAttributes, isGraphQLScalarType, isEnumFieldType, isTargetNameAssociation, isNonModelFieldType, OpType, isPredicateObj, isPredicateGroup, ModelOperation } from '../types.mjs';\nimport { establishRelationAndKeys, extractPrimaryKeyFieldNames, IDENTIFIER_KEY_SEPARATOR } from '../util.mjs';\nimport { ConsoleLogger } from '@aws-amplify/core';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('DataStore');\nvar GraphQLOperationType;\n(function (GraphQLOperationType) {\n  GraphQLOperationType[\"LIST\"] = \"query\";\n  GraphQLOperationType[\"CREATE\"] = \"mutation\";\n  GraphQLOperationType[\"UPDATE\"] = \"mutation\";\n  GraphQLOperationType[\"DELETE\"] = \"mutation\";\n  GraphQLOperationType[\"GET\"] = \"query\";\n})(GraphQLOperationType || (GraphQLOperationType = {}));\nvar TransformerMutationType;\n(function (TransformerMutationType) {\n  TransformerMutationType[\"CREATE\"] = \"Create\";\n  TransformerMutationType[\"UPDATE\"] = \"Update\";\n  TransformerMutationType[\"DELETE\"] = \"Delete\";\n  TransformerMutationType[\"GET\"] = \"Get\";\n})(TransformerMutationType || (TransformerMutationType = {}));\nconst dummyMetadata = {\n  _version: undefined,\n  _lastChangedAt: undefined,\n  _deleted: undefined\n};\nconst metadataFields = Object.keys(dummyMetadata);\nfunction getMetadataFields() {\n  return metadataFields;\n}\nfunction generateSelectionSet(namespace, modelDefinition) {\n  const scalarFields = getScalarFields(modelDefinition);\n  const nonModelFields = getNonModelFields(namespace, modelDefinition);\n  const implicitOwnerField = getImplicitOwnerField(modelDefinition, scalarFields);\n  let scalarAndMetadataFields = Object.values(scalarFields).map(_ref => {\n    let {\n      name\n    } = _ref;\n    return name;\n  }).concat(implicitOwnerField).concat(nonModelFields);\n  if (isSchemaModel(modelDefinition)) {\n    scalarAndMetadataFields = scalarAndMetadataFields.concat(getMetadataFields()).concat(getConnectionFields(modelDefinition, namespace));\n  }\n  const result = scalarAndMetadataFields.join('\\n');\n  return result;\n}\nfunction getImplicitOwnerField(modelDefinition, scalarFields) {\n  const ownerFields = getOwnerFields(modelDefinition);\n  if (!scalarFields.owner && ownerFields.includes('owner')) {\n    return ['owner'];\n  }\n  return [];\n}\nfunction getOwnerFields(modelDefinition) {\n  const ownerFields = [];\n  if (isSchemaModelWithAttributes(modelDefinition)) {\n    modelDefinition.attributes.forEach(attr => {\n      if (attr.properties && attr.properties.rules) {\n        const rule = attr.properties.rules.find(rule => rule.allow === 'owner');\n        if (rule && rule.ownerField) {\n          ownerFields.push(rule.ownerField);\n        }\n      }\n    });\n  }\n  return ownerFields;\n}\nfunction getScalarFields(modelDefinition) {\n  const {\n    fields\n  } = modelDefinition;\n  const result = Object.values(fields).filter(field => {\n    if (isGraphQLScalarType(field.type) || isEnumFieldType(field.type)) {\n      return true;\n    }\n    return false;\n  }).reduce((acc, field) => {\n    acc[field.name] = field;\n    return acc;\n  }, {});\n  return result;\n}\n// Used for generating the selection set for queries and mutations\nfunction getConnectionFields(modelDefinition, namespace) {\n  const result = [];\n  Object.values(modelDefinition.fields).filter(_ref2 => {\n    let {\n      association\n    } = _ref2;\n    return association && Object.keys(association).length;\n  }).forEach(_ref3 => {\n    let {\n      name,\n      association\n    } = _ref3;\n    const {\n      connectionType\n    } = association || {};\n    switch (connectionType) {\n      case 'HAS_ONE':\n      case 'HAS_MANY':\n        // Intentionally blank\n        break;\n      case 'BELONGS_TO':\n        if (isTargetNameAssociation(association)) {\n          // New codegen (CPK)\n          if (association.targetNames && association.targetNames.length > 0) {\n            // Need to retrieve relations in order to get connected model keys\n            const [relations] = establishRelationAndKeys(namespace);\n            const connectedModelName = modelDefinition.fields[name].type['model'];\n            const byPkIndex = relations[connectedModelName].indexes.find(_ref4 => {\n              let [name] = _ref4;\n              return name === 'byPk';\n            });\n            const keyFields = byPkIndex && byPkIndex[1];\n            const keyFieldSelectionSet = keyFields === null || keyFields === void 0 ? void 0 : keyFields.join(' ');\n            // We rely on `_deleted` when we process the sync query (e.g. in batchSave in the adapters)\n            result.push(\"\".concat(name, \" { \").concat(keyFieldSelectionSet, \" _deleted }\"));\n          } else {\n            // backwards-compatability for schema generated prior to custom primary key support\n            result.push(\"\".concat(name, \" { id _deleted }\"));\n          }\n        }\n        break;\n      default:\n        throw new Error(\"Invalid connection type \".concat(connectionType));\n    }\n  });\n  return result;\n}\nfunction getNonModelFields(namespace, modelDefinition) {\n  const result = [];\n  Object.values(modelDefinition.fields).forEach(_ref5 => {\n    let {\n      name,\n      type\n    } = _ref5;\n    if (isNonModelFieldType(type)) {\n      const typeDefinition = namespace.nonModels[type.nonModel];\n      const scalarFields = Object.values(getScalarFields(typeDefinition)).map(_ref6 => {\n        let {\n          name\n        } = _ref6;\n        return name;\n      });\n      const nested = [];\n      Object.values(typeDefinition.fields).forEach(field => {\n        const {\n          type,\n          name\n        } = field;\n        if (isNonModelFieldType(type)) {\n          const typeDefinition = namespace.nonModels[type.nonModel];\n          nested.push(\"\".concat(name, \" { \").concat(generateSelectionSet(namespace, typeDefinition), \" }\"));\n        }\n      });\n      result.push(\"\".concat(name, \" { \").concat(scalarFields.join(' '), \" \").concat(nested.join(' '), \" }\"));\n    }\n  });\n  return result;\n}\nfunction getAuthorizationRules(modelDefinition) {\n  // Searching for owner authorization on attributes\n  const authConfig = [].concat(modelDefinition.attributes || []).find(attr => attr && attr.type === 'auth');\n  const {\n    properties: {\n      rules = []\n    } = {}\n  } = authConfig || {};\n  const resultRules = [];\n  // Multiple rules can be declared for allow: owner\n  rules.forEach(rule => {\n    // setting defaults for backwards compatibility with old cli\n    const {\n      identityClaim = 'cognito:username',\n      ownerField = 'owner',\n      operations = ['create', 'update', 'delete', 'read'],\n      provider = 'userPools',\n      groupClaim = 'cognito:groups',\n      allow: authStrategy = 'iam',\n      groups = [],\n      groupsField = ''\n    } = rule;\n    const isReadAuthorized = operations.includes('read');\n    const isOwnerAuth = authStrategy === 'owner';\n    if (!isReadAuthorized && !isOwnerAuth) {\n      return;\n    }\n    const authRule = {\n      identityClaim,\n      ownerField,\n      provider,\n      groupClaim,\n      authStrategy,\n      groups,\n      groupsField,\n      areSubscriptionsPublic: false\n    };\n    if (isOwnerAuth) {\n      // look for the subscription level override\n      // only pay attention to the public level\n      const modelConfig = [].concat(modelDefinition.attributes || []).find(attr => attr && attr.type === 'model');\n      // find the subscriptions level. ON is default\n      const {\n        properties: {\n          subscriptions: {\n            level = 'on'\n          } = {}\n        } = {}\n      } = modelConfig || {};\n      // treat subscriptions as public for owner auth with unprotected reads\n      // when `read` is omitted from `operations`\n      authRule.areSubscriptionsPublic = !operations.includes('read') || level === 'public';\n    }\n    if (isOwnerAuth) {\n      // owner rules has least priority\n      resultRules.push(authRule);\n      return;\n    }\n    resultRules.unshift(authRule);\n  });\n  return resultRules;\n}\nfunction buildSubscriptionGraphQLOperation(namespace, modelDefinition, transformerMutationType, isOwnerAuthorization, ownerField) {\n  let filterArg = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  const selectionSet = generateSelectionSet(namespace, modelDefinition);\n  const {\n    name: typeName\n  } = modelDefinition;\n  const opName = \"on\".concat(transformerMutationType).concat(typeName);\n  const docArgs = [];\n  const opArgs = [];\n  if (filterArg) {\n    docArgs.push(\"$filter: ModelSubscription\".concat(typeName, \"FilterInput\"));\n    opArgs.push('filter: $filter');\n  }\n  if (isOwnerAuthorization) {\n    docArgs.push(\"$\".concat(ownerField, \": String!\"));\n    opArgs.push(\"\".concat(ownerField, \": $\").concat(ownerField));\n  }\n  const docStr = docArgs.length ? \"(\".concat(docArgs.join(','), \")\") : '';\n  const opStr = opArgs.length ? \"(\".concat(opArgs.join(','), \")\") : '';\n  return [transformerMutationType, opName, \"subscription operation\".concat(docStr, \"{\\n\\t\\t\\t\").concat(opName).concat(opStr, \"{\\n\\t\\t\\t\\t\").concat(selectionSet, \"\\n\\t\\t\\t}\\n\\t\\t}\")];\n}\nfunction buildGraphQLOperation(namespace, modelDefinition, graphQLOpType) {\n  let selectionSet = generateSelectionSet(namespace, modelDefinition);\n  const {\n    name: typeName,\n    pluralName: pluralTypeName\n  } = modelDefinition;\n  let operation;\n  let documentArgs;\n  let operationArgs;\n  let transformerMutationType;\n  switch (graphQLOpType) {\n    case 'LIST':\n      operation = \"sync\".concat(pluralTypeName);\n      documentArgs = \"($limit: Int, $nextToken: String, $lastSync: AWSTimestamp, $filter: Model\".concat(typeName, \"FilterInput)\");\n      operationArgs = '(limit: $limit, nextToken: $nextToken, lastSync: $lastSync, filter: $filter)';\n      selectionSet = \"items {\\n\\t\\t\\t\\t\\t\\t\\t\".concat(selectionSet, \"\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tnextToken\\n\\t\\t\\t\\t\\t\\tstartedAt\");\n      break;\n    case 'CREATE':\n      operation = \"create\".concat(typeName);\n      documentArgs = \"($input: Create\".concat(typeName, \"Input!)\");\n      operationArgs = '(input: $input)';\n      transformerMutationType = TransformerMutationType.CREATE;\n      break;\n    case 'UPDATE':\n      operation = \"update\".concat(typeName);\n      documentArgs = \"($input: Update\".concat(typeName, \"Input!, $condition: Model\").concat(typeName, \"ConditionInput)\");\n      operationArgs = '(input: $input, condition: $condition)';\n      transformerMutationType = TransformerMutationType.UPDATE;\n      break;\n    case 'DELETE':\n      operation = \"delete\".concat(typeName);\n      documentArgs = \"($input: Delete\".concat(typeName, \"Input!, $condition: Model\").concat(typeName, \"ConditionInput)\");\n      operationArgs = '(input: $input, condition: $condition)';\n      transformerMutationType = TransformerMutationType.DELETE;\n      break;\n    case 'GET':\n      operation = \"get\".concat(typeName);\n      documentArgs = \"($id: ID!)\";\n      operationArgs = '(id: $id)';\n      transformerMutationType = TransformerMutationType.GET;\n      break;\n    default:\n      throw new Error(\"Invalid graphQlOpType \".concat(graphQLOpType));\n  }\n  return [[transformerMutationType, operation, \"\".concat(GraphQLOperationType[graphQLOpType], \" operation\").concat(documentArgs, \"{\\n\\t\\t\").concat(operation).concat(operationArgs, \"{\\n\\t\\t\\t\").concat(selectionSet, \"\\n\\t\\t}\\n\\t}\")]];\n}\nfunction createMutationInstanceFromModelOperation(relationships, modelDefinition, opType, model, element, condition, MutationEventConstructor, modelInstanceCreator, id) {\n  let operation;\n  switch (opType) {\n    case OpType.INSERT:\n      operation = TransformerMutationType.CREATE;\n      break;\n    case OpType.UPDATE:\n      operation = TransformerMutationType.UPDATE;\n      break;\n    case OpType.DELETE:\n      operation = TransformerMutationType.DELETE;\n      break;\n    default:\n      throw new Error(\"Invalid opType \".concat(opType));\n  }\n  // stringify nested objects of type AWSJSON\n  // this allows us to return parsed JSON to users (see `castInstanceType()` in datastore.ts),\n  // but still send the object correctly over the wire\n  const replacer = (k, v) => {\n    const isAWSJSON = k && v !== null && typeof v === 'object' && modelDefinition.fields[k] && modelDefinition.fields[k].type === 'AWSJSON';\n    if (isAWSJSON) {\n      return JSON.stringify(v);\n    }\n    return v;\n  };\n  const modelId = getIdentifierValue(modelDefinition, element);\n  const optionalId = OpType.INSERT && id ? {\n    id\n  } : {};\n  const mutationEvent = modelInstanceCreator(MutationEventConstructor, {\n    ...optionalId,\n    data: JSON.stringify(element, replacer),\n    modelId,\n    model: model.name,\n    operation: operation,\n    condition: JSON.stringify(condition)\n  });\n  return mutationEvent;\n}\nfunction predicateToGraphQLCondition(predicate, modelDefinition) {\n  const result = {};\n  if (!predicate || !Array.isArray(predicate.predicates)) {\n    return result;\n  }\n  // This is compatible with how the GQL Transform currently generates the Condition Input,\n  // i.e. any PK and SK fields are omitted and can't be used as conditions.\n  // However, I think this limits usability.\n  // What if we want to delete all records where SK > some value\n  // Or all records where PK = some value but SKs are different values\n  // TODO: if the Transform gets updated we'll need to modify this logic to only omit\n  // key fields from the predicate/condition when ALL of the keyFields are present and using `eq` operators\n  const keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n  return predicateToGraphQLFilter(predicate, keyFields);\n}\n/**\n * @param predicatesGroup - Predicate Group\n    @returns GQL Filter Expression from Predicate Group\n    \n    @remarks Flattens redundant list predicates\n    @example\n\n    ```js\n    { and:[{ and:[{ username:  { eq: 'bob' }}] }] }\n    ```\n    Becomes\n    ```js\n    { and:[{ username: { eq: 'bob' }}] }\n    ```\n    */\nfunction predicateToGraphQLFilter(predicatesGroup) {\n  let fieldsToOmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const result = {};\n  if (!predicatesGroup || !Array.isArray(predicatesGroup.predicates)) {\n    return result;\n  }\n  const {\n    type,\n    predicates\n  } = predicatesGroup;\n  const isList = type === 'and' || type === 'or';\n  result[type] = isList ? [] : {};\n  const children = [];\n  predicates.forEach(predicate => {\n    if (isPredicateObj(predicate)) {\n      const {\n        field,\n        operator,\n        operand\n      } = predicate;\n      if (fieldsToOmit.includes(field)) return;\n      const gqlField = {\n        [field]: {\n          [operator]: operand\n        }\n      };\n      children.push(gqlField);\n      return;\n    }\n    const child = predicateToGraphQLFilter(predicate, fieldsToOmit, false);\n    if (Object.keys(child).length > 0) {\n      children.push(child);\n    }\n  });\n  // flatten redundant list predicates\n  if (children.length === 1) {\n    const [child] = children;\n    if (\n    // any nested list node\n    isList && !root ||\n    // root list node where the only child is also a list node\n    isList && root && ('and' in child || 'or' in child)) {\n      delete result[type];\n      Object.assign(result, child);\n      return result;\n    }\n  }\n  children.forEach(child => {\n    if (isList) {\n      result[type].push(child);\n    } else {\n      result[type] = child;\n    }\n  });\n  if (isList) {\n    if (result[type].length === 0) return {};\n  } else {\n    if (Object.keys(result[type]).length === 0) return {};\n  }\n  return result;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns set of distinct field names in the filter group\n */\nfunction filterFields(group) {\n  const fields = new Set();\n  if (!group || !Array.isArray(group.predicates)) return fields;\n  const {\n    predicates\n  } = group;\n  const stack = [...predicates];\n  while (stack.length > 0) {\n    const current = stack.pop();\n    if (isPredicateObj(current)) {\n      fields.add(current.field);\n    } else if (isPredicateGroup(current)) {\n      stack.push(...current.predicates);\n    }\n  }\n  return fields;\n}\n/**\n *\n * @param modelDefinition\n * @returns set of field names used with dynamic auth modes configured for the provided model definition\n */\nfunction dynamicAuthFields(modelDefinition) {\n  const rules = getAuthorizationRules(modelDefinition);\n  const fields = new Set();\n  for (const rule of rules) {\n    if (rule.groupsField && !rule.groups.length) {\n      // dynamic group rule will have no values in `rule.groups`\n      fields.add(rule.groupsField);\n    } else if (rule.ownerField) {\n      fields.add(rule.ownerField);\n    }\n  }\n  return fields;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns the total number of OR'd predicates in the filter group\n *\n * @example returns 2\n * ```js\n * { type: \"or\", predicates: [\n * { field: \"username\", operator: \"beginsWith\", operand: \"a\" },\n * { field: \"title\", operator: \"contains\", operand: \"abc\" },\n * ]}\n * ```\n */\nfunction countFilterCombinations(group) {\n  if (!group || !Array.isArray(group.predicates)) return 0;\n  let count = 0;\n  const stack = [group];\n  while (stack.length > 0) {\n    const current = stack.pop();\n    if (isPredicateGroup(current)) {\n      const {\n        predicates,\n        type\n      } = current;\n      // ignore length = 1; groups with 1 predicate will get flattened when converted to gqlFilter\n      if (type === 'or' && predicates.length > 1) {\n        count += predicates.length;\n      }\n      stack.push(...predicates);\n    }\n  }\n  // if we didn't encounter any OR groups, default to 1\n  return count || 1;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns name of repeated field | null\n *\n * @example returns \"username\"\n * ```js\n * { type: \"and\", predicates: [\n * \t\t{ field: \"username\", operator: \"beginsWith\", operand: \"a\" },\n * \t\t{ field: \"username\", operator: \"contains\", operand: \"abc\" },\n * ] }\n * ```\n */\nfunction repeatedFieldInGroup(group) {\n  if (!group || !Array.isArray(group.predicates)) return null;\n  // convert to filter in order to flatten redundant groups\n  const gqlFilter = predicateToGraphQLFilter(group);\n  const stack = [gqlFilter];\n  const hasGroupRepeatedFields = fields => {\n    const seen = {};\n    for (const f of fields) {\n      const [fieldName] = Object.keys(f);\n      if (seen[fieldName]) {\n        return fieldName;\n      }\n      seen[fieldName] = true;\n    }\n    return null;\n  };\n  while (stack.length > 0) {\n    const current = stack.pop();\n    const [key] = Object.keys(current);\n    const values = current[key];\n    if (!Array.isArray(values)) {\n      return null;\n    }\n    // field value will be single object\n    const predicateObjects = values.filter(v => !Array.isArray(Object.values(v)[0]));\n    // group value will be an array\n    const predicateGroups = values.filter(v => Array.isArray(Object.values(v)[0]));\n    if (key === 'and') {\n      const repeatedField = hasGroupRepeatedFields(predicateObjects);\n      if (repeatedField) {\n        return repeatedField;\n      }\n    }\n    stack.push(...predicateGroups);\n  }\n  return null;\n}\nvar RTFError;\n(function (RTFError) {\n  RTFError[RTFError[\"UnknownField\"] = 0] = \"UnknownField\";\n  RTFError[RTFError[\"MaxAttributes\"] = 1] = \"MaxAttributes\";\n  RTFError[RTFError[\"MaxCombinations\"] = 2] = \"MaxCombinations\";\n  RTFError[RTFError[\"RepeatedFieldname\"] = 3] = \"RepeatedFieldname\";\n  RTFError[RTFError[\"NotGroup\"] = 4] = \"NotGroup\";\n  RTFError[RTFError[\"FieldNotInType\"] = 5] = \"FieldNotInType\";\n})(RTFError || (RTFError = {}));\nfunction generateRTFRemediation(errorType, modelDefinition, predicatesGroup) {\n  const selSyncFields = filterFields(predicatesGroup);\n  const selSyncFieldStr = [...selSyncFields].join(', ');\n  const dynamicAuthModeFields = dynamicAuthFields(modelDefinition);\n  const dynamicAuthFieldsStr = [...dynamicAuthModeFields].join(', ');\n  const filterCombinations = countFilterCombinations(predicatesGroup);\n  const repeatedField = repeatedFieldInGroup(predicatesGroup);\n  switch (errorType) {\n    case RTFError.UnknownField:\n      return \"Your API was generated with an older version of the CLI that doesn't support backend subscription filtering.\" + 'To enable backend subscription filtering, upgrade your Amplify CLI to the latest version and push your app by running `amplify upgrade` followed by `amplify push`';\n    case RTFError.MaxAttributes:\n      {\n        let message = \"Your selective sync expression for \".concat(modelDefinition.name, \" contains \").concat(selSyncFields.size, \" different model fields: \").concat(selSyncFieldStr, \".\\n\\n\");\n        if (dynamicAuthModeFields.size > 0) {\n          message += \"Note: the number of fields you can use with selective sync is affected by @auth rules configured on the model.\\n\\n\" + \"Dynamic auth modes, such as owner auth and dynamic group auth each utilize 1 field.\\n\" + \"You currently have \".concat(dynamicAuthModeFields.size, \" dynamic auth mode(s) configured on this model: \").concat(dynamicAuthFieldsStr, \".\");\n        }\n        return message;\n      }\n    case RTFError.MaxCombinations:\n      {\n        let message = \"Your selective sync expression for \".concat(modelDefinition.name, \" contains \").concat(filterCombinations, \" field combinations (total number of predicates in an OR expression).\\n\\n\");\n        if (dynamicAuthModeFields.size > 0) {\n          message += \"Note: the number of fields you can use with selective sync is affected by @auth rules configured on the model.\\n\\n\" + \"Dynamic auth modes, such as owner auth and dynamic group auth factor in to the number of combinations you're using.\\n\" + \"You currently have \".concat(dynamicAuthModeFields.size, \" dynamic auth mode(s) configured on this model: \").concat(dynamicAuthFieldsStr, \".\");\n        }\n        return message;\n      }\n    case RTFError.RepeatedFieldname:\n      return \"Your selective sync expression for \".concat(modelDefinition.name, \" contains multiple entries for \").concat(repeatedField, \" in the same AND group.\");\n    case RTFError.NotGroup:\n      return \"Your selective sync expression for \".concat(modelDefinition.name, \" uses a `not` group. If you'd like to filter subscriptions in the backend, \") + \"rewrite your expression using `ne` or `notContains` operators.\";\n    case RTFError.FieldNotInType:\n      // no remediation instructions. We'll surface the message directly\n      return '';\n  }\n}\nfunction getUserGroupsFromToken(token, rule) {\n  // validate token against groupClaim\n  let userGroups = token[rule.groupClaim] || [];\n  if (typeof userGroups === 'string') {\n    let parsedGroups;\n    try {\n      parsedGroups = JSON.parse(userGroups);\n    } catch (e) {\n      parsedGroups = userGroups;\n    }\n    userGroups = [].concat(parsedGroups);\n  }\n  return userGroups;\n}\nasync function getModelAuthModes(_ref7) {\n  let {\n    authModeStrategy,\n    defaultAuthMode,\n    modelName,\n    schema\n  } = _ref7;\n  const operations = Object.values(ModelOperation);\n  const modelAuthModes = {\n    CREATE: [],\n    READ: [],\n    UPDATE: [],\n    DELETE: []\n  };\n  try {\n    await Promise.all(operations.map(async operation => {\n      const authModes = await authModeStrategy({\n        schema,\n        modelName,\n        operation\n      });\n      if (typeof authModes === 'string') {\n        modelAuthModes[operation] = [authModes];\n      } else if (Array.isArray(authModes) && authModes.length) {\n        modelAuthModes[operation] = authModes;\n      } else {\n        // Use default auth mode if nothing is returned from authModeStrategy\n        modelAuthModes[operation] = [defaultAuthMode];\n      }\n    }));\n  } catch (error) {\n    logger.debug(\"Error getting auth modes for model: \".concat(modelName), error);\n  }\n  return modelAuthModes;\n}\nfunction getForbiddenError(error) {\n  const forbiddenErrorCodes = [401, 403];\n  let forbiddenError;\n  if (error && error.errors) {\n    forbiddenError = error.errors.find(err => forbiddenErrorCodes.includes(resolveServiceErrorStatusCode(err)));\n  } else if (error && error.message) {\n    forbiddenError = error;\n  }\n  if (forbiddenError) {\n    var _forbiddenError$messa;\n    return (_forbiddenError$messa = forbiddenError.message) !== null && _forbiddenError$messa !== void 0 ? _forbiddenError$messa : \"Request failed with status code \".concat(resolveServiceErrorStatusCode(forbiddenError));\n  }\n  return null;\n}\nfunction resolveServiceErrorStatusCode(error) {\n  var _error$$metadata;\n  if (error !== null && error !== void 0 && (_error$$metadata = error['$metadata']) !== null && _error$$metadata !== void 0 && _error$$metadata['httpStatusCode']) {\n    var _error$$metadata2;\n    return Number(error === null || error === void 0 || (_error$$metadata2 = error['$metadata']) === null || _error$$metadata2 === void 0 ? void 0 : _error$$metadata2['httpStatusCode']);\n  } else if (error !== null && error !== void 0 && error.originalError) {\n    return resolveServiceErrorStatusCode(error === null || error === void 0 ? void 0 : error.originalError);\n  } else {\n    return null;\n  }\n}\nfunction getClientSideAuthError(error) {\n  const clientSideAuthErrors = Object.values(GraphQLAuthError);\n  const clientSideError = error && error.message && clientSideAuthErrors.find(clientError => error.message.includes(clientError));\n  return clientSideError || null;\n}\nasync function getTokenForCustomAuth(authMode) {\n  let amplifyConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (authMode === 'lambda') {\n    const {\n      authProviders: {\n        functionAuthProvider\n      } = {\n        functionAuthProvider: null\n      }\n    } = amplifyConfig;\n    if (functionAuthProvider && typeof functionAuthProvider === 'function') {\n      try {\n        const {\n          token\n        } = await functionAuthProvider();\n        return token;\n      } catch (error) {\n        throw new Error(\"Error retrieving token from `functionAuthProvider`: \".concat(error));\n      }\n    } else {\n      // TODO: add docs link once available\n      throw new Error('You must provide a `functionAuthProvider` function to `DataStore.configure` when using lambda');\n    }\n  }\n}\n// Util that takes a modelDefinition and model and returns either the id value(s) or the custom primary key value(s)\nfunction getIdentifierValue(modelDefinition, model) {\n  const pkFieldNames = extractPrimaryKeyFieldNames(modelDefinition);\n  const idOrPk = pkFieldNames.map(f => model[f]).join(IDENTIFIER_KEY_SEPARATOR);\n  return idOrPk;\n}\nexport { RTFError, TransformerMutationType, buildGraphQLOperation, buildSubscriptionGraphQLOperation, countFilterCombinations, createMutationInstanceFromModelOperation, dynamicAuthFields, filterFields, generateRTFRemediation, generateSelectionSet, getAuthorizationRules, getClientSideAuthError, getForbiddenError, getIdentifierValue, getMetadataFields, getModelAuthModes, getTokenForCustomAuth, getUserGroupsFromToken, predicateToGraphQLCondition, predicateToGraphQLFilter, repeatedFieldInGroup, resolveServiceErrorStatusCode };","map":{"version":3,"names":["logger","ConsoleLogger","GraphQLOperationType","TransformerMutationType","dummyMetadata","_version","undefined","_lastChangedAt","_deleted","metadataFields","Object","keys","getMetadataFields","generateSelectionSet","namespace","modelDefinition","scalarFields","getScalarFields","nonModelFields","getNonModelFields","implicitOwnerField","getImplicitOwnerField","scalarAndMetadataFields","values","map","_ref","name","concat","isSchemaModel","getConnectionFields","result","join","ownerFields","getOwnerFields","owner","includes","isSchemaModelWithAttributes","attributes","forEach","attr","properties","rules","rule","find","allow","ownerField","push","fields","filter","field","isGraphQLScalarType","type","isEnumFieldType","reduce","acc","_ref2","association","length","_ref3","connectionType","isTargetNameAssociation","targetNames","relations","establishRelationAndKeys","connectedModelName","byPkIndex","indexes","_ref4","keyFields","keyFieldSelectionSet","Error","_ref5","isNonModelFieldType","typeDefinition","nonModels","nonModel","_ref6","nested","getAuthorizationRules","authConfig","resultRules","identityClaim","operations","provider","groupClaim","authStrategy","groups","groupsField","isReadAuthorized","isOwnerAuth","authRule","areSubscriptionsPublic","modelConfig","subscriptions","level","unshift","buildSubscriptionGraphQLOperation","transformerMutationType","isOwnerAuthorization","filterArg","arguments","selectionSet","typeName","opName","docArgs","opArgs","docStr","opStr","buildGraphQLOperation","graphQLOpType","pluralName","pluralTypeName","operation","documentArgs","operationArgs","CREATE","UPDATE","DELETE","GET","createMutationInstanceFromModelOperation","relationships","opType","model","element","condition","MutationEventConstructor","modelInstanceCreator","id","OpType","INSERT","replacer","k","v","isAWSJSON","JSON","stringify","modelId","getIdentifierValue","optionalId","mutationEvent","data","predicateToGraphQLCondition","predicate","Array","isArray","predicates","extractPrimaryKeyFieldNames","predicateToGraphQLFilter","predicatesGroup","fieldsToOmit","root","isList","children","isPredicateObj","operator","operand","gqlField","child","assign","filterFields","group","Set","stack","current","pop","add","isPredicateGroup","dynamicAuthFields","countFilterCombinations","count","repeatedFieldInGroup","gqlFilter","hasGroupRepeatedFields","seen","f","fieldName","key","predicateObjects","predicateGroups","repeatedField","RTFError","generateRTFRemediation","errorType","selSyncFields","selSyncFieldStr","dynamicAuthModeFields","dynamicAuthFieldsStr","filterCombinations","UnknownField","MaxAttributes","message","size","MaxCombinations","RepeatedFieldname","NotGroup","FieldNotInType","getUserGroupsFromToken","token","userGroups","parsedGroups","parse","e","getModelAuthModes","_ref7","authModeStrategy","defaultAuthMode","modelName","schema","ModelOperation","modelAuthModes","READ","Promise","all","authModes","error","debug","getForbiddenError","forbiddenErrorCodes","forbiddenError","errors","err","resolveServiceErrorStatusCode","_forbiddenError$messa","_error$$metadata","_error$$metadata2","Number","originalError","getClientSideAuthError","clientSideAuthErrors","GraphQLAuthError","clientSideError","clientError","getTokenForCustomAuth","authMode","amplifyConfig","authProviders","functionAuthProvider","pkFieldNames","idOrPk","IDENTIFIER_KEY_SEPARATOR"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/sync/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { GraphQLAuthError } from '@aws-amplify/api';\nimport { isEnumFieldType, isGraphQLScalarType, isPredicateObj, isSchemaModel, isSchemaModelWithAttributes, isTargetNameAssociation, isNonModelFieldType, OpType, ModelOperation, isPredicateGroup, } from '../types';\nimport { extractPrimaryKeyFieldNames, establishRelationAndKeys, IDENTIFIER_KEY_SEPARATOR, } from '../util';\nimport { ConsoleLogger } from '@aws-amplify/core';\nconst logger = new ConsoleLogger('DataStore');\nvar GraphQLOperationType;\n(function (GraphQLOperationType) {\n    GraphQLOperationType[\"LIST\"] = \"query\";\n    GraphQLOperationType[\"CREATE\"] = \"mutation\";\n    GraphQLOperationType[\"UPDATE\"] = \"mutation\";\n    GraphQLOperationType[\"DELETE\"] = \"mutation\";\n    GraphQLOperationType[\"GET\"] = \"query\";\n})(GraphQLOperationType || (GraphQLOperationType = {}));\nexport var TransformerMutationType;\n(function (TransformerMutationType) {\n    TransformerMutationType[\"CREATE\"] = \"Create\";\n    TransformerMutationType[\"UPDATE\"] = \"Update\";\n    TransformerMutationType[\"DELETE\"] = \"Delete\";\n    TransformerMutationType[\"GET\"] = \"Get\";\n})(TransformerMutationType || (TransformerMutationType = {}));\nconst dummyMetadata = {\n    _version: undefined,\n    _lastChangedAt: undefined,\n    _deleted: undefined,\n};\nconst metadataFields = (Object.keys(dummyMetadata));\nexport function getMetadataFields() {\n    return metadataFields;\n}\nexport function generateSelectionSet(namespace, modelDefinition) {\n    const scalarFields = getScalarFields(modelDefinition);\n    const nonModelFields = getNonModelFields(namespace, modelDefinition);\n    const implicitOwnerField = getImplicitOwnerField(modelDefinition, scalarFields);\n    let scalarAndMetadataFields = Object.values(scalarFields)\n        .map(({ name }) => name)\n        .concat(implicitOwnerField)\n        .concat(nonModelFields);\n    if (isSchemaModel(modelDefinition)) {\n        scalarAndMetadataFields = scalarAndMetadataFields\n            .concat(getMetadataFields())\n            .concat(getConnectionFields(modelDefinition, namespace));\n    }\n    const result = scalarAndMetadataFields.join('\\n');\n    return result;\n}\nfunction getImplicitOwnerField(modelDefinition, scalarFields) {\n    const ownerFields = getOwnerFields(modelDefinition);\n    if (!scalarFields.owner && ownerFields.includes('owner')) {\n        return ['owner'];\n    }\n    return [];\n}\nfunction getOwnerFields(modelDefinition) {\n    const ownerFields = [];\n    if (isSchemaModelWithAttributes(modelDefinition)) {\n        modelDefinition.attributes.forEach(attr => {\n            if (attr.properties && attr.properties.rules) {\n                const rule = attr.properties.rules.find(rule => rule.allow === 'owner');\n                if (rule && rule.ownerField) {\n                    ownerFields.push(rule.ownerField);\n                }\n            }\n        });\n    }\n    return ownerFields;\n}\nfunction getScalarFields(modelDefinition) {\n    const { fields } = modelDefinition;\n    const result = Object.values(fields)\n        .filter(field => {\n        if (isGraphQLScalarType(field.type) || isEnumFieldType(field.type)) {\n            return true;\n        }\n        return false;\n    })\n        .reduce((acc, field) => {\n        acc[field.name] = field;\n        return acc;\n    }, {});\n    return result;\n}\n// Used for generating the selection set for queries and mutations\nfunction getConnectionFields(modelDefinition, namespace) {\n    const result = [];\n    Object.values(modelDefinition.fields)\n        .filter(({ association }) => association && Object.keys(association).length)\n        .forEach(({ name, association }) => {\n        const { connectionType } = association || {};\n        switch (connectionType) {\n            case 'HAS_ONE':\n            case 'HAS_MANY':\n                // Intentionally blank\n                break;\n            case 'BELONGS_TO':\n                if (isTargetNameAssociation(association)) {\n                    // New codegen (CPK)\n                    if (association.targetNames && association.targetNames.length > 0) {\n                        // Need to retrieve relations in order to get connected model keys\n                        const [relations] = establishRelationAndKeys(namespace);\n                        const connectedModelName = modelDefinition.fields[name].type['model'];\n                        const byPkIndex = relations[connectedModelName].indexes.find(([name]) => name === 'byPk');\n                        const keyFields = byPkIndex && byPkIndex[1];\n                        const keyFieldSelectionSet = keyFields?.join(' ');\n                        // We rely on `_deleted` when we process the sync query (e.g. in batchSave in the adapters)\n                        result.push(`${name} { ${keyFieldSelectionSet} _deleted }`);\n                    }\n                    else {\n                        // backwards-compatability for schema generated prior to custom primary key support\n                        result.push(`${name} { id _deleted }`);\n                    }\n                }\n                break;\n            default:\n                throw new Error(`Invalid connection type ${connectionType}`);\n        }\n    });\n    return result;\n}\nfunction getNonModelFields(namespace, modelDefinition) {\n    const result = [];\n    Object.values(modelDefinition.fields).forEach(({ name, type }) => {\n        if (isNonModelFieldType(type)) {\n            const typeDefinition = namespace.nonModels[type.nonModel];\n            const scalarFields = Object.values(getScalarFields(typeDefinition)).map(({ name }) => name);\n            const nested = [];\n            Object.values(typeDefinition.fields).forEach(field => {\n                const { type, name } = field;\n                if (isNonModelFieldType(type)) {\n                    const typeDefinition = namespace.nonModels[type.nonModel];\n                    nested.push(`${name} { ${generateSelectionSet(namespace, typeDefinition)} }`);\n                }\n            });\n            result.push(`${name} { ${scalarFields.join(' ')} ${nested.join(' ')} }`);\n        }\n    });\n    return result;\n}\nexport function getAuthorizationRules(modelDefinition) {\n    // Searching for owner authorization on attributes\n    const authConfig = []\n        .concat(modelDefinition.attributes || [])\n        .find(attr => attr && attr.type === 'auth');\n    const { properties: { rules = [] } = {} } = authConfig || {};\n    const resultRules = [];\n    // Multiple rules can be declared for allow: owner\n    rules.forEach(rule => {\n        // setting defaults for backwards compatibility with old cli\n        const { identityClaim = 'cognito:username', ownerField = 'owner', operations = ['create', 'update', 'delete', 'read'], provider = 'userPools', groupClaim = 'cognito:groups', allow: authStrategy = 'iam', groups = [], groupsField = '', } = rule;\n        const isReadAuthorized = operations.includes('read');\n        const isOwnerAuth = authStrategy === 'owner';\n        if (!isReadAuthorized && !isOwnerAuth) {\n            return;\n        }\n        const authRule = {\n            identityClaim,\n            ownerField,\n            provider,\n            groupClaim,\n            authStrategy,\n            groups,\n            groupsField,\n            areSubscriptionsPublic: false,\n        };\n        if (isOwnerAuth) {\n            // look for the subscription level override\n            // only pay attention to the public level\n            const modelConfig = []\n                .concat(modelDefinition.attributes || [])\n                .find(attr => attr && attr.type === 'model');\n            // find the subscriptions level. ON is default\n            const { properties: { subscriptions: { level = 'on' } = {} } = {} } = modelConfig || {};\n            // treat subscriptions as public for owner auth with unprotected reads\n            // when `read` is omitted from `operations`\n            authRule.areSubscriptionsPublic =\n                !operations.includes('read') || level === 'public';\n        }\n        if (isOwnerAuth) {\n            // owner rules has least priority\n            resultRules.push(authRule);\n            return;\n        }\n        resultRules.unshift(authRule);\n    });\n    return resultRules;\n}\nexport function buildSubscriptionGraphQLOperation(namespace, modelDefinition, transformerMutationType, isOwnerAuthorization, ownerField, filterArg = false) {\n    const selectionSet = generateSelectionSet(namespace, modelDefinition);\n    const { name: typeName } = modelDefinition;\n    const opName = `on${transformerMutationType}${typeName}`;\n    const docArgs = [];\n    const opArgs = [];\n    if (filterArg) {\n        docArgs.push(`$filter: ModelSubscription${typeName}FilterInput`);\n        opArgs.push('filter: $filter');\n    }\n    if (isOwnerAuthorization) {\n        docArgs.push(`$${ownerField}: String!`);\n        opArgs.push(`${ownerField}: $${ownerField}`);\n    }\n    const docStr = docArgs.length ? `(${docArgs.join(',')})` : '';\n    const opStr = opArgs.length ? `(${opArgs.join(',')})` : '';\n    return [\n        transformerMutationType,\n        opName,\n        `subscription operation${docStr}{\n\t\t\t${opName}${opStr}{\n\t\t\t\t${selectionSet}\n\t\t\t}\n\t\t}`,\n    ];\n}\nexport function buildGraphQLOperation(namespace, modelDefinition, graphQLOpType) {\n    let selectionSet = generateSelectionSet(namespace, modelDefinition);\n    const { name: typeName, pluralName: pluralTypeName } = modelDefinition;\n    let operation;\n    let documentArgs;\n    let operationArgs;\n    let transformerMutationType;\n    switch (graphQLOpType) {\n        case 'LIST':\n            operation = `sync${pluralTypeName}`;\n            documentArgs = `($limit: Int, $nextToken: String, $lastSync: AWSTimestamp, $filter: Model${typeName}FilterInput)`;\n            operationArgs =\n                '(limit: $limit, nextToken: $nextToken, lastSync: $lastSync, filter: $filter)';\n            selectionSet = `items {\n\t\t\t\t\t\t\t${selectionSet}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextToken\n\t\t\t\t\t\tstartedAt`;\n            break;\n        case 'CREATE':\n            operation = `create${typeName}`;\n            documentArgs = `($input: Create${typeName}Input!)`;\n            operationArgs = '(input: $input)';\n            transformerMutationType = TransformerMutationType.CREATE;\n            break;\n        case 'UPDATE':\n            operation = `update${typeName}`;\n            documentArgs = `($input: Update${typeName}Input!, $condition: Model${typeName}ConditionInput)`;\n            operationArgs = '(input: $input, condition: $condition)';\n            transformerMutationType = TransformerMutationType.UPDATE;\n            break;\n        case 'DELETE':\n            operation = `delete${typeName}`;\n            documentArgs = `($input: Delete${typeName}Input!, $condition: Model${typeName}ConditionInput)`;\n            operationArgs = '(input: $input, condition: $condition)';\n            transformerMutationType = TransformerMutationType.DELETE;\n            break;\n        case 'GET':\n            operation = `get${typeName}`;\n            documentArgs = `($id: ID!)`;\n            operationArgs = '(id: $id)';\n            transformerMutationType = TransformerMutationType.GET;\n            break;\n        default:\n            throw new Error(`Invalid graphQlOpType ${graphQLOpType}`);\n    }\n    return [\n        [\n            transformerMutationType,\n            operation,\n            `${GraphQLOperationType[graphQLOpType]} operation${documentArgs}{\n\t\t${operation}${operationArgs}{\n\t\t\t${selectionSet}\n\t\t}\n\t}`,\n        ],\n    ];\n}\nexport function createMutationInstanceFromModelOperation(relationships, modelDefinition, opType, model, element, condition, MutationEventConstructor, modelInstanceCreator, id) {\n    let operation;\n    switch (opType) {\n        case OpType.INSERT:\n            operation = TransformerMutationType.CREATE;\n            break;\n        case OpType.UPDATE:\n            operation = TransformerMutationType.UPDATE;\n            break;\n        case OpType.DELETE:\n            operation = TransformerMutationType.DELETE;\n            break;\n        default:\n            throw new Error(`Invalid opType ${opType}`);\n    }\n    // stringify nested objects of type AWSJSON\n    // this allows us to return parsed JSON to users (see `castInstanceType()` in datastore.ts),\n    // but still send the object correctly over the wire\n    const replacer = (k, v) => {\n        const isAWSJSON = k &&\n            v !== null &&\n            typeof v === 'object' &&\n            modelDefinition.fields[k] &&\n            modelDefinition.fields[k].type === 'AWSJSON';\n        if (isAWSJSON) {\n            return JSON.stringify(v);\n        }\n        return v;\n    };\n    const modelId = getIdentifierValue(modelDefinition, element);\n    const optionalId = OpType.INSERT && id ? { id } : {};\n    const mutationEvent = modelInstanceCreator(MutationEventConstructor, {\n        ...optionalId,\n        data: JSON.stringify(element, replacer),\n        modelId,\n        model: model.name,\n        operation: operation,\n        condition: JSON.stringify(condition),\n    });\n    return mutationEvent;\n}\nexport function predicateToGraphQLCondition(predicate, modelDefinition) {\n    const result = {};\n    if (!predicate || !Array.isArray(predicate.predicates)) {\n        return result;\n    }\n    // This is compatible with how the GQL Transform currently generates the Condition Input,\n    // i.e. any PK and SK fields are omitted and can't be used as conditions.\n    // However, I think this limits usability.\n    // What if we want to delete all records where SK > some value\n    // Or all records where PK = some value but SKs are different values\n    // TODO: if the Transform gets updated we'll need to modify this logic to only omit\n    // key fields from the predicate/condition when ALL of the keyFields are present and using `eq` operators\n    const keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n    return predicateToGraphQLFilter(predicate, keyFields);\n}\n/**\n * @param predicatesGroup - Predicate Group\n    @returns GQL Filter Expression from Predicate Group\n    \n    @remarks Flattens redundant list predicates\n    @example\n\n    ```js\n    { and:[{ and:[{ username:  { eq: 'bob' }}] }] }\n    ```\n    Becomes\n    ```js\n    { and:[{ username: { eq: 'bob' }}] }\n    ```\n    */\nexport function predicateToGraphQLFilter(predicatesGroup, fieldsToOmit = [], root = true) {\n    const result = {};\n    if (!predicatesGroup || !Array.isArray(predicatesGroup.predicates)) {\n        return result;\n    }\n    const { type, predicates } = predicatesGroup;\n    const isList = type === 'and' || type === 'or';\n    result[type] = isList ? [] : {};\n    const children = [];\n    predicates.forEach(predicate => {\n        if (isPredicateObj(predicate)) {\n            const { field, operator, operand } = predicate;\n            if (fieldsToOmit.includes(field))\n                return;\n            const gqlField = {\n                [field]: { [operator]: operand },\n            };\n            children.push(gqlField);\n            return;\n        }\n        const child = predicateToGraphQLFilter(predicate, fieldsToOmit, false);\n        if (Object.keys(child).length > 0) {\n            children.push(child);\n        }\n    });\n    // flatten redundant list predicates\n    if (children.length === 1) {\n        const [child] = children;\n        if (\n        // any nested list node\n        (isList && !root) ||\n            // root list node where the only child is also a list node\n            (isList && root && ('and' in child || 'or' in child))) {\n            delete result[type];\n            Object.assign(result, child);\n            return result;\n        }\n    }\n    children.forEach(child => {\n        if (isList) {\n            result[type].push(child);\n        }\n        else {\n            result[type] = child;\n        }\n    });\n    if (isList) {\n        if (result[type].length === 0)\n            return {};\n    }\n    else {\n        if (Object.keys(result[type]).length === 0)\n            return {};\n    }\n    return result;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns set of distinct field names in the filter group\n */\nexport function filterFields(group) {\n    const fields = new Set();\n    if (!group || !Array.isArray(group.predicates))\n        return fields;\n    const { predicates } = group;\n    const stack = [...predicates];\n    while (stack.length > 0) {\n        const current = stack.pop();\n        if (isPredicateObj(current)) {\n            fields.add(current.field);\n        }\n        else if (isPredicateGroup(current)) {\n            stack.push(...current.predicates);\n        }\n    }\n    return fields;\n}\n/**\n *\n * @param modelDefinition\n * @returns set of field names used with dynamic auth modes configured for the provided model definition\n */\nexport function dynamicAuthFields(modelDefinition) {\n    const rules = getAuthorizationRules(modelDefinition);\n    const fields = new Set();\n    for (const rule of rules) {\n        if (rule.groupsField && !rule.groups.length) {\n            // dynamic group rule will have no values in `rule.groups`\n            fields.add(rule.groupsField);\n        }\n        else if (rule.ownerField) {\n            fields.add(rule.ownerField);\n        }\n    }\n    return fields;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns the total number of OR'd predicates in the filter group\n *\n * @example returns 2\n * ```js\n * { type: \"or\", predicates: [\n * { field: \"username\", operator: \"beginsWith\", operand: \"a\" },\n * { field: \"title\", operator: \"contains\", operand: \"abc\" },\n * ]}\n * ```\n */\nexport function countFilterCombinations(group) {\n    if (!group || !Array.isArray(group.predicates))\n        return 0;\n    let count = 0;\n    const stack = [group];\n    while (stack.length > 0) {\n        const current = stack.pop();\n        if (isPredicateGroup(current)) {\n            const { predicates, type } = current;\n            // ignore length = 1; groups with 1 predicate will get flattened when converted to gqlFilter\n            if (type === 'or' && predicates.length > 1) {\n                count += predicates.length;\n            }\n            stack.push(...predicates);\n        }\n    }\n    // if we didn't encounter any OR groups, default to 1\n    return count || 1;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns name of repeated field | null\n *\n * @example returns \"username\"\n * ```js\n * { type: \"and\", predicates: [\n * \t\t{ field: \"username\", operator: \"beginsWith\", operand: \"a\" },\n * \t\t{ field: \"username\", operator: \"contains\", operand: \"abc\" },\n * ] }\n * ```\n */\nexport function repeatedFieldInGroup(group) {\n    if (!group || !Array.isArray(group.predicates))\n        return null;\n    // convert to filter in order to flatten redundant groups\n    const gqlFilter = predicateToGraphQLFilter(group);\n    const stack = [gqlFilter];\n    const hasGroupRepeatedFields = (fields) => {\n        const seen = {};\n        for (const f of fields) {\n            const [fieldName] = Object.keys(f);\n            if (seen[fieldName]) {\n                return fieldName;\n            }\n            seen[fieldName] = true;\n        }\n        return null;\n    };\n    while (stack.length > 0) {\n        const current = stack.pop();\n        const [key] = Object.keys(current);\n        const values = current[key];\n        if (!Array.isArray(values)) {\n            return null;\n        }\n        // field value will be single object\n        const predicateObjects = values.filter(v => !Array.isArray(Object.values(v)[0]));\n        // group value will be an array\n        const predicateGroups = values.filter(v => Array.isArray(Object.values(v)[0]));\n        if (key === 'and') {\n            const repeatedField = hasGroupRepeatedFields(predicateObjects);\n            if (repeatedField) {\n                return repeatedField;\n            }\n        }\n        stack.push(...predicateGroups);\n    }\n    return null;\n}\nexport var RTFError;\n(function (RTFError) {\n    RTFError[RTFError[\"UnknownField\"] = 0] = \"UnknownField\";\n    RTFError[RTFError[\"MaxAttributes\"] = 1] = \"MaxAttributes\";\n    RTFError[RTFError[\"MaxCombinations\"] = 2] = \"MaxCombinations\";\n    RTFError[RTFError[\"RepeatedFieldname\"] = 3] = \"RepeatedFieldname\";\n    RTFError[RTFError[\"NotGroup\"] = 4] = \"NotGroup\";\n    RTFError[RTFError[\"FieldNotInType\"] = 5] = \"FieldNotInType\";\n})(RTFError || (RTFError = {}));\nexport function generateRTFRemediation(errorType, modelDefinition, predicatesGroup) {\n    const selSyncFields = filterFields(predicatesGroup);\n    const selSyncFieldStr = [...selSyncFields].join(', ');\n    const dynamicAuthModeFields = dynamicAuthFields(modelDefinition);\n    const dynamicAuthFieldsStr = [...dynamicAuthModeFields].join(', ');\n    const filterCombinations = countFilterCombinations(predicatesGroup);\n    const repeatedField = repeatedFieldInGroup(predicatesGroup);\n    switch (errorType) {\n        case RTFError.UnknownField:\n            return (`Your API was generated with an older version of the CLI that doesn't support backend subscription filtering.` +\n                'To enable backend subscription filtering, upgrade your Amplify CLI to the latest version and push your app by running `amplify upgrade` followed by `amplify push`');\n        case RTFError.MaxAttributes: {\n            let message = `Your selective sync expression for ${modelDefinition.name} contains ${selSyncFields.size} different model fields: ${selSyncFieldStr}.\\n\\n`;\n            if (dynamicAuthModeFields.size > 0) {\n                message +=\n                    `Note: the number of fields you can use with selective sync is affected by @auth rules configured on the model.\\n\\n` +\n                        `Dynamic auth modes, such as owner auth and dynamic group auth each utilize 1 field.\\n` +\n                        `You currently have ${dynamicAuthModeFields.size} dynamic auth mode(s) configured on this model: ${dynamicAuthFieldsStr}.`;\n            }\n            return message;\n        }\n        case RTFError.MaxCombinations: {\n            let message = `Your selective sync expression for ${modelDefinition.name} contains ${filterCombinations} field combinations (total number of predicates in an OR expression).\\n\\n`;\n            if (dynamicAuthModeFields.size > 0) {\n                message +=\n                    `Note: the number of fields you can use with selective sync is affected by @auth rules configured on the model.\\n\\n` +\n                        `Dynamic auth modes, such as owner auth and dynamic group auth factor in to the number of combinations you're using.\\n` +\n                        `You currently have ${dynamicAuthModeFields.size} dynamic auth mode(s) configured on this model: ${dynamicAuthFieldsStr}.`;\n            }\n            return message;\n        }\n        case RTFError.RepeatedFieldname:\n            return `Your selective sync expression for ${modelDefinition.name} contains multiple entries for ${repeatedField} in the same AND group.`;\n        case RTFError.NotGroup:\n            return (`Your selective sync expression for ${modelDefinition.name} uses a \\`not\\` group. If you'd like to filter subscriptions in the backend, ` +\n                `rewrite your expression using \\`ne\\` or \\`notContains\\` operators.`);\n        case RTFError.FieldNotInType:\n            // no remediation instructions. We'll surface the message directly\n            return '';\n    }\n}\nexport function getUserGroupsFromToken(token, rule) {\n    // validate token against groupClaim\n    let userGroups = token[rule.groupClaim] || [];\n    if (typeof userGroups === 'string') {\n        let parsedGroups;\n        try {\n            parsedGroups = JSON.parse(userGroups);\n        }\n        catch (e) {\n            parsedGroups = userGroups;\n        }\n        userGroups = [].concat(parsedGroups);\n    }\n    return userGroups;\n}\nexport async function getModelAuthModes({ authModeStrategy, defaultAuthMode, modelName, schema, }) {\n    const operations = Object.values(ModelOperation);\n    const modelAuthModes = {\n        CREATE: [],\n        READ: [],\n        UPDATE: [],\n        DELETE: [],\n    };\n    try {\n        await Promise.all(operations.map(async (operation) => {\n            const authModes = await authModeStrategy({\n                schema,\n                modelName,\n                operation,\n            });\n            if (typeof authModes === 'string') {\n                modelAuthModes[operation] = [authModes];\n            }\n            else if (Array.isArray(authModes) && authModes.length) {\n                modelAuthModes[operation] = authModes;\n            }\n            else {\n                // Use default auth mode if nothing is returned from authModeStrategy\n                modelAuthModes[operation] = [defaultAuthMode];\n            }\n        }));\n    }\n    catch (error) {\n        logger.debug(`Error getting auth modes for model: ${modelName}`, error);\n    }\n    return modelAuthModes;\n}\nexport function getForbiddenError(error) {\n    const forbiddenErrorCodes = [401, 403];\n    let forbiddenError;\n    if (error && error.errors) {\n        forbiddenError = error.errors.find(err => forbiddenErrorCodes.includes(resolveServiceErrorStatusCode(err)));\n    }\n    else if (error && error.message) {\n        forbiddenError = error;\n    }\n    if (forbiddenError) {\n        return (forbiddenError.message ??\n            `Request failed with status code ${resolveServiceErrorStatusCode(forbiddenError)}`);\n    }\n    return null;\n}\nexport function resolveServiceErrorStatusCode(error) {\n    if (error?.['$metadata']?.['httpStatusCode']) {\n        return Number(error?.['$metadata']?.['httpStatusCode']);\n    }\n    else if (error?.originalError) {\n        return resolveServiceErrorStatusCode(error?.originalError);\n    }\n    else {\n        return null;\n    }\n}\nexport function getClientSideAuthError(error) {\n    const clientSideAuthErrors = Object.values(GraphQLAuthError);\n    const clientSideError = error &&\n        error.message &&\n        clientSideAuthErrors.find(clientError => error.message.includes(clientError));\n    return clientSideError || null;\n}\nexport async function getTokenForCustomAuth(authMode, amplifyConfig = {}) {\n    if (authMode === 'lambda') {\n        const { authProviders: { functionAuthProvider } = { functionAuthProvider: null }, } = amplifyConfig;\n        if (functionAuthProvider && typeof functionAuthProvider === 'function') {\n            try {\n                const { token } = await functionAuthProvider();\n                return token;\n            }\n            catch (error) {\n                throw new Error(`Error retrieving token from \\`functionAuthProvider\\`: ${error}`);\n            }\n        }\n        else {\n            // TODO: add docs link once available\n            throw new Error('You must provide a `functionAuthProvider` function to `DataStore.configure` when using lambda');\n        }\n    }\n}\n// Util that takes a modelDefinition and model and returns either the id value(s) or the custom primary key value(s)\nexport function getIdentifierValue(modelDefinition, model) {\n    const pkFieldNames = extractPrimaryKeyFieldNames(modelDefinition);\n    const idOrPk = pkFieldNames.map(f => model[f]).join(IDENTIFIER_KEY_SEPARATOR);\n    return idOrPk;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}