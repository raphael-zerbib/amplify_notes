{"ast":null,"code":"import { OpType, QueryOne } from '../../types.mjs';\nimport { monotonicUlidFactory, indexNameFromKeys, DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR } from '../../util.mjs';\nimport { createInMemoryStore } from './InMemoryStore.mjs';\nconst DB_NAME = '@AmplifyDatastore';\nconst COLLECTION = 'Collection';\nconst DATA = 'Data';\nconst monotonicFactoriesMap = new Map();\nclass AsyncStorageDatabase {\n  constructor() {\n    /**\n     * Maps storeNames to a map of ulid->id\n     */\n    this._collectionInMemoryIndex = new Map();\n    this.storage = createInMemoryStore();\n  }\n  /**\n   * Collection index is map of stores (i.e. sync, metadata, mutation event, and data)\n   * @param storeName {string} - Name of the store\n   * @returns Map of ulid->id\n   */\n  getCollectionIndex(storeName) {\n    if (!this._collectionInMemoryIndex.has(storeName)) {\n      this._collectionInMemoryIndex.set(storeName, new Map());\n    }\n    return this._collectionInMemoryIndex.get(storeName);\n  }\n  /**\n   * Return ULID for store if it exists, otherwise create a new one\n   * @param storeName {string} - Name of the store\n   * @returns ulid\n   */\n  getMonotonicFactory(storeName) {\n    if (!monotonicFactoriesMap.has(storeName)) {\n      monotonicFactoriesMap.set(storeName, monotonicUlidFactory());\n    }\n    return monotonicFactoriesMap.get(storeName);\n  }\n  async init() {\n    this._collectionInMemoryIndex.clear();\n    const allKeys = await this.storage.getAllKeys();\n    const keysForCollectionEntries = [];\n    for (const key of allKeys) {\n      const [dbName, storeName, recordType, ulidOrId, id] = key.split('::');\n      if (dbName === DB_NAME) {\n        if (recordType === DATA) {\n          let ulid;\n          if (id === undefined) {\n            // It is an old entry (without ulid). Need to migrate to new key format\n            const id = ulidOrId;\n            const newUlid = this.getMonotonicFactory(storeName)();\n            const oldKey = this.getLegacyKeyForItem(storeName, id);\n            const newKey = this.getKeyForItem(storeName, id, newUlid);\n            const item = await this.storage.getItem(oldKey);\n            await this.storage.setItem(newKey, item);\n            await this.storage.removeItem(oldKey);\n            ulid = newUlid;\n          } else {\n            ulid = ulidOrId;\n          }\n          this.getCollectionIndex(storeName).set(id, ulid);\n        } else if (recordType === COLLECTION) {\n          keysForCollectionEntries.push(key);\n        }\n      }\n    }\n    if (keysForCollectionEntries.length > 0) {\n      await this.storage.multiRemove(keysForCollectionEntries);\n    }\n  }\n  async save(item, storeName, keys, keyValuesPath) {\n    const idxName = indexNameFromKeys(keys);\n    const ulid = this.getCollectionIndex(storeName)?.get(idxName) || this.getMonotonicFactory(storeName)();\n    // Retrieve db key for item\n    const itemKey = this.getKeyForItem(storeName, keyValuesPath, ulid);\n    // Set key in collection index\n    this.getCollectionIndex(storeName)?.set(keyValuesPath, ulid);\n    // Save item in db\n    await this.storage.setItem(itemKey, JSON.stringify(item));\n  }\n  async batchSave(storeName, items, keys) {\n    if (items.length === 0) {\n      return [];\n    }\n    const result = [];\n    const collection = this.getCollectionIndex(storeName);\n    const keysToDelete = new Set();\n    const keysToSave = new Set();\n    const allItemsKeys = [];\n    const itemsMap = {};\n    /* Populate allItemKeys, keysToDelete, and keysToSave */\n    for (const item of items) {\n      // Extract keys from concatenated key path, map to item values\n      const keyValues = keys.map(field => item[field]);\n      const {\n        _deleted\n      } = item;\n      // If id is in the store, retrieve, otherwise generate new ULID\n      const ulid = collection.get(keyValues.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR)) || this.getMonotonicFactory(storeName)();\n      // Generate the \"longer key\" for the item\n      const key = this.getKeyForItem(storeName, keyValues.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR), ulid);\n      allItemsKeys.push(key);\n      itemsMap[key] = {\n        ulid,\n        model: item\n      };\n      if (_deleted) {\n        keysToDelete.add(key);\n      } else {\n        keysToSave.add(key);\n      }\n    }\n    const existingRecordsMap = await this.storage.multiGet(allItemsKeys);\n    const existingRecordsKeys = existingRecordsMap.filter(([, v]) => !!v).reduce((set, [k]) => set.add(k), new Set());\n    // Delete\n    await new Promise((resolve, reject) => {\n      if (keysToDelete.size === 0) {\n        resolve();\n        return;\n      }\n      const keysToDeleteArray = Array.from(keysToDelete);\n      keysToDeleteArray.forEach(key => {\n        // key: full db key\n        // keys: PK and/or SK keys\n        const primaryKeyValues = keys.map(field => itemsMap[key].model[field]).join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n        collection.delete(primaryKeyValues);\n      });\n      this.storage.multiRemove(keysToDeleteArray, errors => {\n        if (errors && errors.length > 0) {\n          reject(errors);\n        } else {\n          resolve();\n        }\n      });\n    });\n    // Save\n    await new Promise((resolve, reject) => {\n      if (keysToSave.size === 0) {\n        resolve();\n        return;\n      }\n      const entriesToSet = Array.from(keysToSave).map(key => [key, JSON.stringify(itemsMap[key].model)]);\n      keysToSave.forEach(key => {\n        const {\n          model,\n          ulid\n        } = itemsMap[key];\n        // Retrieve values from model, use as key for collection index\n        const keyValues = keys.map(field => model[field]).join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n        collection.set(keyValues, ulid);\n      });\n      this.storage.multiSet(entriesToSet, errors => {\n        if (errors && errors.length > 0) {\n          reject(errors);\n        } else {\n          resolve();\n        }\n      });\n    });\n    for (const key of allItemsKeys) {\n      if (keysToDelete.has(key) && existingRecordsKeys.has(key)) {\n        result.push([itemsMap[key].model, OpType.DELETE]);\n      } else if (keysToSave.has(key)) {\n        result.push([itemsMap[key].model, existingRecordsKeys.has(key) ? OpType.UPDATE : OpType.INSERT]);\n      }\n    }\n    return result;\n  }\n  async get(keyValuePath, storeName) {\n    const ulid = this.getCollectionIndex(storeName).get(keyValuePath);\n    const itemKey = this.getKeyForItem(storeName, keyValuePath, ulid);\n    const recordAsString = await this.storage.getItem(itemKey);\n    const record = recordAsString && JSON.parse(recordAsString);\n    return record;\n  }\n  async getOne(firstOrLast, storeName) {\n    const collection = this.getCollectionIndex(storeName);\n    const [itemId, ulid] = firstOrLast === QueryOne.FIRST ? (() => {\n      let id, ulid;\n      for ([id, ulid] of collection) break; // Get first element of the set\n      return [id, ulid];\n    })() : (() => {\n      let id, ulid;\n      for ([id, ulid] of collection); // Get last element of the set\n      return [id, ulid];\n    })();\n    const itemKey = this.getKeyForItem(storeName, itemId, ulid);\n    const itemString = itemKey && (await this.storage.getItem(itemKey));\n    const result = itemString ? JSON.parse(itemString) || undefined : undefined;\n    return result;\n  }\n  /**\n   * This function gets all the records stored in async storage for a particular storeName\n   * It then loads all the records for that filtered set of keys using multiGet()\n   */\n  async getAll(storeName, pagination) {\n    const collection = this.getCollectionIndex(storeName);\n    const {\n      page = 0,\n      limit = 0\n    } = pagination || {};\n    const start = Math.max(0, page * limit) || 0;\n    const end = limit > 0 ? start + limit : undefined;\n    const keysForStore = [];\n    let count = 0;\n    for (const [id, ulid] of collection) {\n      count++;\n      if (count <= start) {\n        continue;\n      }\n      keysForStore.push(this.getKeyForItem(storeName, id, ulid));\n      if (count === end) {\n        break;\n      }\n    }\n    const storeRecordStrings = await this.storage.multiGet(keysForStore);\n    const records = storeRecordStrings.filter(([, value]) => value).map(([, value]) => JSON.parse(value));\n    return records;\n  }\n  async delete(key, storeName) {\n    const ulid = this.getCollectionIndex(storeName).get(key);\n    const itemKey = this.getKeyForItem(storeName, key, ulid);\n    this.getCollectionIndex(storeName).delete(key);\n    await this.storage.removeItem(itemKey);\n  }\n  /**\n   * Clear the AsyncStorage of all DataStore entries\n   */\n  async clear() {\n    const allKeys = await this.storage.getAllKeys();\n    const allDataStoreKeys = allKeys.filter(key => key.startsWith(DB_NAME));\n    await this.storage.multiRemove(allDataStoreKeys);\n    this._collectionInMemoryIndex.clear();\n  }\n  getKeyForItem(storeName, id, ulid) {\n    return `${this.getKeyPrefixForStoreItems(storeName)}::${ulid}::${id}`;\n  }\n  getLegacyKeyForItem(storeName, id) {\n    return `${this.getKeyPrefixForStoreItems(storeName)}::${id}`;\n  }\n  getKeyPrefixForStoreItems(storeName) {\n    return `${DB_NAME}::${storeName}::${DATA}`;\n  }\n}\nexport { AsyncStorageDatabase as default };","map":{"version":3,"names":["DB_NAME","COLLECTION","DATA","monotonicFactoriesMap","Map","AsyncStorageDatabase","constructor","_collectionInMemoryIndex","storage","createInMemoryStore","getCollectionIndex","storeName","has","set","get","getMonotonicFactory","monotonicUlidFactory","init","clear","allKeys","getAllKeys","keysForCollectionEntries","key","dbName","recordType","ulidOrId","id","split","ulid","undefined","newUlid","oldKey","getLegacyKeyForItem","newKey","getKeyForItem","item","getItem","setItem","removeItem","push","length","multiRemove","save","keys","keyValuesPath","idxName","indexNameFromKeys","itemKey","JSON","stringify","batchSave","items","result","collection","keysToDelete","Set","keysToSave","allItemsKeys","itemsMap","keyValues","map","field","_deleted","join","DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR","model","add","existingRecordsMap","multiGet","existingRecordsKeys","filter","v","reduce","k","Promise","resolve","reject","size","keysToDeleteArray","Array","from","forEach","primaryKeyValues","delete","errors","entriesToSet","multiSet","OpType","DELETE","UPDATE","INSERT","keyValuePath","recordAsString","record","parse","getOne","firstOrLast","itemId","QueryOne","FIRST","itemString","getAll","pagination","page","limit","start","Math","max","end","keysForStore","count","storeRecordStrings","records","value","allDataStoreKeys","startsWith","getKeyPrefixForStoreItems"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/storage/adapter/AsyncStorageDatabase.ts"],"sourcesContent":["import { OpType, QueryOne, } from '../../types';\nimport { DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR, indexNameFromKeys, monotonicUlidFactory, } from '../../util';\nimport { createInMemoryStore } from './InMemoryStore';\nconst DB_NAME = '@AmplifyDatastore';\nconst COLLECTION = 'Collection';\nconst DATA = 'Data';\nconst monotonicFactoriesMap = new Map();\nclass AsyncStorageDatabase {\n    constructor() {\n        /**\n         * Maps storeNames to a map of ulid->id\n         */\n        this._collectionInMemoryIndex = new Map();\n        this.storage = createInMemoryStore();\n    }\n    /**\n     * Collection index is map of stores (i.e. sync, metadata, mutation event, and data)\n     * @param storeName {string} - Name of the store\n     * @returns Map of ulid->id\n     */\n    getCollectionIndex(storeName) {\n        if (!this._collectionInMemoryIndex.has(storeName)) {\n            this._collectionInMemoryIndex.set(storeName, new Map());\n        }\n        return this._collectionInMemoryIndex.get(storeName);\n    }\n    /**\n     * Return ULID for store if it exists, otherwise create a new one\n     * @param storeName {string} - Name of the store\n     * @returns ulid\n     */\n    getMonotonicFactory(storeName) {\n        if (!monotonicFactoriesMap.has(storeName)) {\n            monotonicFactoriesMap.set(storeName, monotonicUlidFactory());\n        }\n        return monotonicFactoriesMap.get(storeName);\n    }\n    async init() {\n        this._collectionInMemoryIndex.clear();\n        const allKeys = await this.storage.getAllKeys();\n        const keysForCollectionEntries = [];\n        for (const key of allKeys) {\n            const [dbName, storeName, recordType, ulidOrId, id] = key.split('::');\n            if (dbName === DB_NAME) {\n                if (recordType === DATA) {\n                    let ulid;\n                    if (id === undefined) {\n                        // It is an old entry (without ulid). Need to migrate to new key format\n                        const id = ulidOrId;\n                        const newUlid = this.getMonotonicFactory(storeName)();\n                        const oldKey = this.getLegacyKeyForItem(storeName, id);\n                        const newKey = this.getKeyForItem(storeName, id, newUlid);\n                        const item = await this.storage.getItem(oldKey);\n                        await this.storage.setItem(newKey, item);\n                        await this.storage.removeItem(oldKey);\n                        ulid = newUlid;\n                    }\n                    else {\n                        ulid = ulidOrId;\n                    }\n                    this.getCollectionIndex(storeName).set(id, ulid);\n                }\n                else if (recordType === COLLECTION) {\n                    keysForCollectionEntries.push(key);\n                }\n            }\n        }\n        if (keysForCollectionEntries.length > 0) {\n            await this.storage.multiRemove(keysForCollectionEntries);\n        }\n    }\n    async save(item, storeName, keys, keyValuesPath) {\n        const idxName = indexNameFromKeys(keys);\n        const ulid = this.getCollectionIndex(storeName)?.get(idxName) ||\n            this.getMonotonicFactory(storeName)();\n        // Retrieve db key for item\n        const itemKey = this.getKeyForItem(storeName, keyValuesPath, ulid);\n        // Set key in collection index\n        this.getCollectionIndex(storeName)?.set(keyValuesPath, ulid);\n        // Save item in db\n        await this.storage.setItem(itemKey, JSON.stringify(item));\n    }\n    async batchSave(storeName, items, keys) {\n        if (items.length === 0) {\n            return [];\n        }\n        const result = [];\n        const collection = this.getCollectionIndex(storeName);\n        const keysToDelete = new Set();\n        const keysToSave = new Set();\n        const allItemsKeys = [];\n        const itemsMap = {};\n        /* Populate allItemKeys, keysToDelete, and keysToSave */\n        for (const item of items) {\n            // Extract keys from concatenated key path, map to item values\n            const keyValues = keys.map(field => item[field]);\n            const { _deleted } = item;\n            // If id is in the store, retrieve, otherwise generate new ULID\n            const ulid = collection.get(keyValues.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR)) ||\n                this.getMonotonicFactory(storeName)();\n            // Generate the \"longer key\" for the item\n            const key = this.getKeyForItem(storeName, keyValues.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR), ulid);\n            allItemsKeys.push(key);\n            itemsMap[key] = { ulid, model: item };\n            if (_deleted) {\n                keysToDelete.add(key);\n            }\n            else {\n                keysToSave.add(key);\n            }\n        }\n        const existingRecordsMap = await this.storage.multiGet(allItemsKeys);\n        const existingRecordsKeys = existingRecordsMap\n            .filter(([, v]) => !!v)\n            .reduce((set, [k]) => set.add(k), new Set());\n        // Delete\n        await new Promise((resolve, reject) => {\n            if (keysToDelete.size === 0) {\n                resolve();\n                return;\n            }\n            const keysToDeleteArray = Array.from(keysToDelete);\n            keysToDeleteArray.forEach(key => {\n                // key: full db key\n                // keys: PK and/or SK keys\n                const primaryKeyValues = keys\n                    .map(field => itemsMap[key].model[field])\n                    .join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n                collection.delete(primaryKeyValues);\n            });\n            this.storage.multiRemove(keysToDeleteArray, (errors) => {\n                if (errors && errors.length > 0) {\n                    reject(errors);\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n        // Save\n        await new Promise((resolve, reject) => {\n            if (keysToSave.size === 0) {\n                resolve();\n                return;\n            }\n            const entriesToSet = Array.from(keysToSave).map(key => [\n                key,\n                JSON.stringify(itemsMap[key].model),\n            ]);\n            keysToSave.forEach(key => {\n                const { model, ulid } = itemsMap[key];\n                // Retrieve values from model, use as key for collection index\n                const keyValues = keys\n                    .map(field => model[field])\n                    .join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n                collection.set(keyValues, ulid);\n            });\n            this.storage.multiSet(entriesToSet, (errors) => {\n                if (errors && errors.length > 0) {\n                    reject(errors);\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n        for (const key of allItemsKeys) {\n            if (keysToDelete.has(key) && existingRecordsKeys.has(key)) {\n                result.push([itemsMap[key].model, OpType.DELETE]);\n            }\n            else if (keysToSave.has(key)) {\n                result.push([\n                    itemsMap[key].model,\n                    existingRecordsKeys.has(key) ? OpType.UPDATE : OpType.INSERT,\n                ]);\n            }\n        }\n        return result;\n    }\n    async get(keyValuePath, storeName) {\n        const ulid = this.getCollectionIndex(storeName).get(keyValuePath);\n        const itemKey = this.getKeyForItem(storeName, keyValuePath, ulid);\n        const recordAsString = await this.storage.getItem(itemKey);\n        const record = recordAsString && JSON.parse(recordAsString);\n        return record;\n    }\n    async getOne(firstOrLast, storeName) {\n        const collection = this.getCollectionIndex(storeName);\n        const [itemId, ulid] = firstOrLast === QueryOne.FIRST\n            ? (() => {\n                let id, ulid;\n                for ([id, ulid] of collection)\n                    break; // Get first element of the set\n                return [id, ulid];\n            })()\n            : (() => {\n                let id, ulid;\n                for ([id, ulid] of collection)\n                    ; // Get last element of the set\n                return [id, ulid];\n            })();\n        const itemKey = this.getKeyForItem(storeName, itemId, ulid);\n        const itemString = itemKey && (await this.storage.getItem(itemKey));\n        const result = itemString ? JSON.parse(itemString) || undefined : undefined;\n        return result;\n    }\n    /**\n     * This function gets all the records stored in async storage for a particular storeName\n     * It then loads all the records for that filtered set of keys using multiGet()\n     */\n    async getAll(storeName, pagination) {\n        const collection = this.getCollectionIndex(storeName);\n        const { page = 0, limit = 0 } = pagination || {};\n        const start = Math.max(0, page * limit) || 0;\n        const end = limit > 0 ? start + limit : undefined;\n        const keysForStore = [];\n        let count = 0;\n        for (const [id, ulid] of collection) {\n            count++;\n            if (count <= start) {\n                continue;\n            }\n            keysForStore.push(this.getKeyForItem(storeName, id, ulid));\n            if (count === end) {\n                break;\n            }\n        }\n        const storeRecordStrings = await this.storage.multiGet(keysForStore);\n        const records = storeRecordStrings\n            .filter(([, value]) => value)\n            .map(([, value]) => JSON.parse(value));\n        return records;\n    }\n    async delete(key, storeName) {\n        const ulid = this.getCollectionIndex(storeName).get(key);\n        const itemKey = this.getKeyForItem(storeName, key, ulid);\n        this.getCollectionIndex(storeName).delete(key);\n        await this.storage.removeItem(itemKey);\n    }\n    /**\n     * Clear the AsyncStorage of all DataStore entries\n     */\n    async clear() {\n        const allKeys = await this.storage.getAllKeys();\n        const allDataStoreKeys = allKeys.filter(key => key.startsWith(DB_NAME));\n        await this.storage.multiRemove(allDataStoreKeys);\n        this._collectionInMemoryIndex.clear();\n    }\n    getKeyForItem(storeName, id, ulid) {\n        return `${this.getKeyPrefixForStoreItems(storeName)}::${ulid}::${id}`;\n    }\n    getLegacyKeyForItem(storeName, id) {\n        return `${this.getKeyPrefixForStoreItems(storeName)}::${id}`;\n    }\n    getKeyPrefixForStoreItems(storeName) {\n        return `${DB_NAME}::${storeName}::${DATA}`;\n    }\n}\nexport default AsyncStorageDatabase;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}