{"ast":null,"code":"import { InternalAPI } from '@aws-amplify/api/internals';\nimport { jitteredBackoff, BackgroundProcessManager, retry, Category, DataStoreAction, NonRetryableError } from '@aws-amplify/core/internals/utils';\nimport { Observable } from 'rxjs';\nimport { ProcessName, DISCARD, isModelFieldType, isTargetNameAssociation, OpType } from '../../types.mjs';\nimport { extractTargetNamesFromSrc, USER, ID } from '../../util.mjs';\nimport { buildGraphQLOperation, getModelAuthModes, getTokenForCustomAuth, createMutationInstanceFromModelOperation, TransformerMutationType } from '../utils.mjs';\nimport { getMutationErrorType } from './errorMaps.mjs';\nimport { ConsoleLogger } from '@aws-amplify/core';\nconst MAX_ATTEMPTS = 10;\nconst logger = new ConsoleLogger('DataStore');\nclass MutationProcessor {\n  constructor(schema, storage, userClasses, outbox, modelInstanceCreator, MutationEvent, amplifyConfig = {}, authModeStrategy, errorHandler, conflictHandler, amplifyContext) {\n    this.schema = schema;\n    this.storage = storage;\n    this.userClasses = userClasses;\n    this.outbox = outbox;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.MutationEvent = MutationEvent;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.errorHandler = errorHandler;\n    this.conflictHandler = conflictHandler;\n    this.amplifyContext = amplifyContext;\n    this.typeQuery = new WeakMap();\n    this.processing = false;\n    this.runningProcesses = new BackgroundProcessManager();\n    this.amplifyContext.InternalAPI = this.amplifyContext.InternalAPI || InternalAPI;\n    this.generateQueries();\n  }\n  generateQueries() {\n    Object.values(this.schema.namespaces).forEach(namespace => {\n      Object.values(namespace.models).filter(({\n        syncable\n      }) => syncable).forEach(model => {\n        const [createMutation] = buildGraphQLOperation(namespace, model, 'CREATE');\n        const [updateMutation] = buildGraphQLOperation(namespace, model, 'UPDATE');\n        const [deleteMutation] = buildGraphQLOperation(namespace, model, 'DELETE');\n        this.typeQuery.set(model, [createMutation, updateMutation, deleteMutation]);\n      });\n    });\n  }\n  isReady() {\n    return this.observer !== undefined;\n  }\n  start() {\n    this.runningProcesses = new BackgroundProcessManager();\n    const observable = new Observable(observer => {\n      this.observer = observer;\n      try {\n        this.resume();\n      } catch (error) {\n        logger.error('mutations processor start error', error);\n        throw error;\n      }\n      return this.runningProcesses.addCleaner(async () => {\n        // The observer has unsubscribed and/or `stop()` has been called.\n        this.removeObserver();\n        this.pause();\n      });\n    });\n    return observable;\n  }\n  async stop() {\n    this.removeObserver();\n    await this.runningProcesses.close();\n    await this.runningProcesses.open();\n  }\n  removeObserver() {\n    this.observer?.complete?.();\n    this.observer = undefined;\n  }\n  async resume() {\n    if (this.runningProcesses.isOpen) {\n      await this.runningProcesses.add(async onTerminate => {\n        if (this.processing || !this.isReady() || !this.runningProcesses.isOpen) {\n          return;\n        }\n        this.processing = true;\n        let head;\n        const namespaceName = USER;\n        // start to drain outbox\n        while (this.processing && this.runningProcesses.isOpen && (head = await this.outbox.peek(this.storage)) !== undefined) {\n          const {\n            model,\n            operation,\n            data,\n            condition\n          } = head;\n          const modelConstructor = this.userClasses[model];\n          let result = undefined;\n          let opName = undefined;\n          let modelDefinition = undefined;\n          try {\n            const modelAuthModes = await getModelAuthModes({\n              authModeStrategy: this.authModeStrategy,\n              defaultAuthMode: this.amplifyConfig.aws_appsync_authenticationType,\n              modelName: model,\n              schema: this.schema\n            });\n            const operationAuthModes = modelAuthModes[operation.toUpperCase()];\n            let authModeAttempts = 0;\n            const authModeRetry = async () => {\n              try {\n                logger.debug(`Attempting mutation with authMode: ${operationAuthModes[authModeAttempts]}`);\n                const response = await this.jitteredRetry(namespaceName, model, operation, data, condition, modelConstructor, this.MutationEvent, head, operationAuthModes[authModeAttempts], onTerminate);\n                logger.debug(`Mutation sent successfully with authMode: ${operationAuthModes[authModeAttempts]}`);\n                return response;\n              } catch (error) {\n                authModeAttempts++;\n                if (authModeAttempts >= operationAuthModes.length) {\n                  logger.debug(`Mutation failed with authMode: ${operationAuthModes[authModeAttempts - 1]}`);\n                  try {\n                    await this.errorHandler({\n                      recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                      localModel: null,\n                      message: error.message,\n                      model: modelConstructor.name,\n                      operation: opName,\n                      errorType: getMutationErrorType(error),\n                      process: ProcessName.sync,\n                      remoteModel: null,\n                      cause: error\n                    });\n                  } catch (e) {\n                    logger.error('Mutation error handler failed with:', e);\n                  }\n                  throw error;\n                }\n                logger.debug(`Mutation failed with authMode: ${operationAuthModes[authModeAttempts - 1]}. Retrying with authMode: ${operationAuthModes[authModeAttempts]}`);\n                return await authModeRetry();\n              }\n            };\n            [result, opName, modelDefinition] = await authModeRetry();\n          } catch (error) {\n            if (error.message === 'Offline' || error.message === 'RetryMutation') {\n              continue;\n            }\n          }\n          if (result === undefined) {\n            logger.debug('done retrying');\n            await this.storage.runExclusive(async storage => {\n              await this.outbox.dequeue(storage);\n            });\n            continue;\n          }\n          const record = result.data[opName];\n          let hasMore = false;\n          await this.storage.runExclusive(async storage => {\n            // using runExclusive to prevent possible race condition\n            // when another record gets enqueued between dequeue and peek\n            await this.outbox.dequeue(storage, record, operation);\n            hasMore = (await this.outbox.peek(storage)) !== undefined;\n          });\n          this.observer?.next?.({\n            operation,\n            modelDefinition,\n            model: record,\n            hasMore\n          });\n        }\n        // pauses itself\n        this.pause();\n      }, 'mutation resume loop');\n    }\n  }\n  async jitteredRetry(namespaceName, model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent, authMode, onTerminate) {\n    return await retry(async (model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent) => {\n      const [query, variables, graphQLCondition, opName, modelDefinition] = this.createQueryVariables(namespaceName, model, operation, data, condition);\n      const authToken = await getTokenForCustomAuth(authMode, this.amplifyConfig);\n      const tryWith = {\n        query,\n        variables,\n        authMode,\n        authToken\n      };\n      let attempt = 0;\n      const opType = this.opTypeFromTransformerOperation(operation);\n      const customUserAgentDetails = {\n        category: Category.DataStore,\n        action: DataStoreAction.GraphQl\n      };\n      do {\n        try {\n          const result = await this.amplifyContext.InternalAPI.graphql(tryWith, undefined, customUserAgentDetails);\n          // Use `as any` because TypeScript doesn't seem to like passing tuples\n          // through generic params.\n          return [result, opName, modelDefinition];\n        } catch (err) {\n          if (err.errors && err.errors.length > 0) {\n            const [error] = err.errors;\n            const {\n              originalError: {\n                code = null\n              } = {}\n            } = error;\n            if (error.errorType === 'Unauthorized') {\n              throw new NonRetryableError('Unauthorized');\n            }\n            if (error.message === 'Network Error' || code === 'ECONNABORTED' // refers to axios timeout error caused by device's bad network condition\n            ) {\n              if (!this.processing) {\n                throw new NonRetryableError('Offline');\n              }\n              // TODO: Check errors on different env (react-native or other browsers)\n              throw new Error('Network Error');\n            }\n            if (error.errorType === 'ConflictUnhandled') {\n              // TODO: add on ConflictConditionalCheck error query last from server\n              attempt++;\n              let retryWith;\n              if (attempt > MAX_ATTEMPTS) {\n                retryWith = DISCARD;\n              } else {\n                try {\n                  retryWith = await this.conflictHandler({\n                    modelConstructor,\n                    localModel: this.modelInstanceCreator(modelConstructor, variables.input),\n                    remoteModel: this.modelInstanceCreator(modelConstructor, error.data),\n                    operation: opType,\n                    attempts: attempt\n                  });\n                } catch (err) {\n                  logger.warn('conflict trycatch', err);\n                  continue;\n                }\n              }\n              if (retryWith === DISCARD) {\n                // Query latest from server and notify merger\n                const [[, opName, query]] = buildGraphQLOperation(this.schema.namespaces[namespaceName], modelDefinition, 'GET');\n                const authToken = await getTokenForCustomAuth(authMode, this.amplifyConfig);\n                const serverData = await this.amplifyContext.InternalAPI.graphql({\n                  query,\n                  variables: {\n                    id: variables.input.id\n                  },\n                  authMode,\n                  authToken\n                }, undefined, customUserAgentDetails);\n                // onTerminate cancel graphql()\n                return [serverData, opName, modelDefinition];\n              }\n              const namespace = this.schema.namespaces[namespaceName];\n              // convert retry with to tryWith\n              const updatedMutation = createMutationInstanceFromModelOperation(namespace.relationships, modelDefinition, opType, modelConstructor, retryWith, graphQLCondition, MutationEvent, this.modelInstanceCreator, mutationEvent.id);\n              await this.storage.save(updatedMutation);\n              throw new NonRetryableError('RetryMutation');\n            } else {\n              try {\n                this.errorHandler({\n                  recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                  localModel: variables.input,\n                  message: error.message,\n                  operation,\n                  errorType: getMutationErrorType(error),\n                  errorInfo: error.errorInfo,\n                  process: ProcessName.mutate,\n                  cause: error,\n                  remoteModel: error.data ? this.modelInstanceCreator(modelConstructor, error.data) : null\n                });\n              } catch (err) {\n                logger.warn('Mutation error handler failed with:', err);\n              } finally {\n                // Return empty tuple, dequeues the mutation\n                return error.data ? [{\n                  data: {\n                    [opName]: error.data\n                  }\n                }, opName, modelDefinition] : [];\n              }\n            }\n          } else {\n            // Catch-all for client-side errors that don't come back in the `GraphQLError` format.\n            // These errors should not be retried.\n            throw new NonRetryableError(err);\n          }\n        }\n      } while (tryWith);\n    }, [model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent], safeJitteredBackoff, onTerminate);\n  }\n  createQueryVariables(namespaceName, model, operation, data, condition) {\n    const modelDefinition = this.schema.namespaces[namespaceName].models[model];\n    const {\n      primaryKey\n    } = this.schema.namespaces[namespaceName].keys[model];\n    const auth = modelDefinition.attributes?.find(a => a.type === 'auth');\n    const ownerFields = auth?.properties?.rules.map(rule => rule.ownerField).filter(f => f) || ['owner'];\n    const queriesTuples = this.typeQuery.get(modelDefinition);\n    const [, opName, query] = queriesTuples.find(([transformerMutationType]) => transformerMutationType === operation);\n    const {\n      _version,\n      ...parsedData\n    } = JSON.parse(data);\n    // include all the fields that comprise a custom PK if one is specified\n    const deleteInput = {};\n    if (primaryKey && primaryKey.length) {\n      for (const pkField of primaryKey) {\n        deleteInput[pkField] = parsedData[pkField];\n      }\n    } else {\n      deleteInput[ID] = parsedData.id;\n    }\n    let mutationInput;\n    if (operation === TransformerMutationType.DELETE) {\n      // For DELETE mutations, only the key(s) are included in the input\n      mutationInput = deleteInput;\n    } else {\n      // Otherwise, we construct the mutation input with the following logic\n      mutationInput = {};\n      const modelFields = Object.values(modelDefinition.fields);\n      for (const {\n        name,\n        type,\n        association,\n        isReadOnly\n      } of modelFields) {\n        // omit readonly fields. cloud storage doesn't need them and won't take them!\n        if (isReadOnly) {\n          continue;\n        }\n        // omit owner fields if it's `null`. cloud storage doesn't allow it.\n        if (ownerFields.includes(name) && parsedData[name] === null) {\n          continue;\n        }\n        // model fields should be stripped out from the input\n        if (isModelFieldType(type)) {\n          // except for belongs to relations - we need to replace them with the correct foreign key(s)\n          if (isTargetNameAssociation(association) && association.connectionType === 'BELONGS_TO') {\n            const targetNames = extractTargetNamesFromSrc(association);\n            if (targetNames) {\n              // instead of including the connected model itself, we add its key(s) to the mutation input\n              for (const targetName of targetNames) {\n                mutationInput[targetName] = parsedData[targetName];\n              }\n            }\n          }\n          continue;\n        }\n        // scalar fields / non-model types\n        if (operation === TransformerMutationType.UPDATE) {\n          if (!parsedData.hasOwnProperty(name)) {\n            // for update mutations - strip out a field if it's unchanged\n            continue;\n          }\n        }\n        // all other fields are added to the input object\n        mutationInput[name] = parsedData[name];\n      }\n    }\n    // Build mutation variables input object\n    const input = {\n      ...mutationInput,\n      _version\n    };\n    const graphQLCondition = JSON.parse(condition);\n    const variables = {\n      input,\n      ...(operation === TransformerMutationType.CREATE ? {} : {\n        condition: Object.keys(graphQLCondition).length > 0 ? graphQLCondition : null\n      })\n    };\n    return [query, variables, graphQLCondition, opName, modelDefinition];\n  }\n  opTypeFromTransformerOperation(operation) {\n    switch (operation) {\n      case TransformerMutationType.CREATE:\n        return OpType.INSERT;\n      case TransformerMutationType.DELETE:\n        return OpType.DELETE;\n      case TransformerMutationType.UPDATE:\n        return OpType.UPDATE;\n      case TransformerMutationType.GET:\n        // Intentionally blank\n        break;\n      default:\n        throw new Error(`Invalid operation ${operation}`);\n    }\n    // because it makes TS happy ...\n    return undefined;\n  }\n  pause() {\n    this.processing = false;\n  }\n}\nconst MAX_RETRY_DELAY_MS = 5 * 60 * 1000;\nconst originalJitteredBackoff = jitteredBackoff(MAX_RETRY_DELAY_MS);\n/**\n * @private\n * Internal use of Amplify only.\n *\n * Wraps the jittered backoff calculation to retry Network Errors indefinitely.\n * Backs off according to original jittered retry logic until the original retry\n * logic hits its max. After this occurs, if the error is a Network Error, we\n * ignore the attempt count and return MAX_RETRY_DELAY_MS to retry forever (until\n * the request succeeds).\n *\n * @param attempt ignored\n * @param _args ignored\n * @param error tested to see if `.message` is 'Network Error'\n * @returns number | false :\n */\nconst safeJitteredBackoff = (attempt, _args, error) => {\n  const attemptResult = originalJitteredBackoff(attempt);\n  // If this is the last attempt and it is a network error, we retry indefinitively every 5 minutes\n  if (attemptResult === false && (error || {}).message === 'Network Error') {\n    return MAX_RETRY_DELAY_MS;\n  }\n  return attemptResult;\n};\nexport { MutationProcessor, safeJitteredBackoff };","map":{"version":3,"names":["MAX_ATTEMPTS","logger","ConsoleLogger","MutationProcessor","constructor","schema","storage","userClasses","outbox","modelInstanceCreator","MutationEvent","amplifyConfig","authModeStrategy","errorHandler","conflictHandler","amplifyContext","typeQuery","WeakMap","processing","runningProcesses","BackgroundProcessManager","InternalAPI","generateQueries","Object","values","namespaces","forEach","namespace","models","filter","syncable","model","createMutation","buildGraphQLOperation","updateMutation","deleteMutation","set","isReady","observer","undefined","start","observable","Observable","resume","error","addCleaner","removeObserver","pause","stop","close","open","complete","isOpen","add","onTerminate","head","namespaceName","USER","peek","operation","data","condition","modelConstructor","result","opName","modelDefinition","modelAuthModes","getModelAuthModes","defaultAuthMode","aws_appsync_authenticationType","modelName","operationAuthModes","toUpperCase","authModeAttempts","authModeRetry","debug","response","jitteredRetry","length","recoverySuggestion","localModel","message","name","errorType","getMutationErrorType","process","ProcessName","sync","remoteModel","cause","e","runExclusive","dequeue","record","hasMore","next","mutationEvent","authMode","retry","query","variables","graphQLCondition","createQueryVariables","authToken","getTokenForCustomAuth","tryWith","attempt","opType","opTypeFromTransformerOperation","customUserAgentDetails","category","Category","DataStore","action","DataStoreAction","GraphQl","graphql","err","errors","originalError","code","NonRetryableError","Error","retryWith","DISCARD","input","attempts","warn","serverData","id","updatedMutation","createMutationInstanceFromModelOperation","relationships","save","errorInfo","mutate","safeJitteredBackoff","primaryKey","keys","auth","attributes","find","a","type","ownerFields","properties","rules","map","rule","ownerField","f","queriesTuples","get","transformerMutationType","_version","parsedData","JSON","parse","deleteInput","pkField","ID","mutationInput","TransformerMutationType","DELETE","modelFields","fields","association","isReadOnly","includes","isModelFieldType","isTargetNameAssociation","connectionType","targetNames","extractTargetNamesFromSrc","targetName","UPDATE","hasOwnProperty","CREATE","OpType","INSERT","GET","MAX_RETRY_DELAY_MS","originalJitteredBackoff","jitteredBackoff","_args","attemptResult"],"sources":["/Users/raphaperso/Documents/Hub/FreeCodeCamp/amplify_notes/node_modules/@aws-amplify/datastore/src/sync/processors/mutation.ts"],"sourcesContent":["import { InternalAPI } from '@aws-amplify/api/internals';\nimport { Category, DataStoreAction, jitteredBackoff, NonRetryableError, retry, BackgroundProcessManager, } from '@aws-amplify/core/internals/utils';\nimport { Observable } from 'rxjs';\nimport { DISCARD, isModelFieldType, isTargetNameAssociation, OpType, ProcessName, } from '../../types';\nimport { extractTargetNamesFromSrc, USER, ID } from '../../util';\nimport { buildGraphQLOperation, createMutationInstanceFromModelOperation, getModelAuthModes, TransformerMutationType, getTokenForCustomAuth, } from '../utils';\nimport { getMutationErrorType } from './errorMaps';\nimport { ConsoleLogger } from '@aws-amplify/core';\nconst MAX_ATTEMPTS = 10;\nconst logger = new ConsoleLogger('DataStore');\nclass MutationProcessor {\n    constructor(schema, storage, userClasses, outbox, modelInstanceCreator, MutationEvent, amplifyConfig = {}, authModeStrategy, errorHandler, conflictHandler, amplifyContext) {\n        this.schema = schema;\n        this.storage = storage;\n        this.userClasses = userClasses;\n        this.outbox = outbox;\n        this.modelInstanceCreator = modelInstanceCreator;\n        this.MutationEvent = MutationEvent;\n        this.amplifyConfig = amplifyConfig;\n        this.authModeStrategy = authModeStrategy;\n        this.errorHandler = errorHandler;\n        this.conflictHandler = conflictHandler;\n        this.amplifyContext = amplifyContext;\n        this.typeQuery = new WeakMap();\n        this.processing = false;\n        this.runningProcesses = new BackgroundProcessManager();\n        this.amplifyContext.InternalAPI =\n            this.amplifyContext.InternalAPI || InternalAPI;\n        this.generateQueries();\n    }\n    generateQueries() {\n        Object.values(this.schema.namespaces).forEach(namespace => {\n            Object.values(namespace.models)\n                .filter(({ syncable }) => syncable)\n                .forEach(model => {\n                const [createMutation] = buildGraphQLOperation(namespace, model, 'CREATE');\n                const [updateMutation] = buildGraphQLOperation(namespace, model, 'UPDATE');\n                const [deleteMutation] = buildGraphQLOperation(namespace, model, 'DELETE');\n                this.typeQuery.set(model, [\n                    createMutation,\n                    updateMutation,\n                    deleteMutation,\n                ]);\n            });\n        });\n    }\n    isReady() {\n        return this.observer !== undefined;\n    }\n    start() {\n        this.runningProcesses = new BackgroundProcessManager();\n        const observable = new Observable(observer => {\n            this.observer = observer;\n            try {\n                this.resume();\n            }\n            catch (error) {\n                logger.error('mutations processor start error', error);\n                throw error;\n            }\n            return this.runningProcesses.addCleaner(async () => {\n                // The observer has unsubscribed and/or `stop()` has been called.\n                this.removeObserver();\n                this.pause();\n            });\n        });\n        return observable;\n    }\n    async stop() {\n        this.removeObserver();\n        await this.runningProcesses.close();\n        await this.runningProcesses.open();\n    }\n    removeObserver() {\n        this.observer?.complete?.();\n        this.observer = undefined;\n    }\n    async resume() {\n        if (this.runningProcesses.isOpen) {\n            await this.runningProcesses.add(async (onTerminate) => {\n                if (this.processing ||\n                    !this.isReady() ||\n                    !this.runningProcesses.isOpen) {\n                    return;\n                }\n                this.processing = true;\n                let head;\n                const namespaceName = USER;\n                // start to drain outbox\n                while (this.processing &&\n                    this.runningProcesses.isOpen &&\n                    (head = await this.outbox.peek(this.storage)) !== undefined) {\n                    const { model, operation, data, condition } = head;\n                    const modelConstructor = this.userClasses[model];\n                    let result = undefined;\n                    let opName = undefined;\n                    let modelDefinition = undefined;\n                    try {\n                        const modelAuthModes = await getModelAuthModes({\n                            authModeStrategy: this.authModeStrategy,\n                            defaultAuthMode: this.amplifyConfig.aws_appsync_authenticationType,\n                            modelName: model,\n                            schema: this.schema,\n                        });\n                        const operationAuthModes = modelAuthModes[operation.toUpperCase()];\n                        let authModeAttempts = 0;\n                        const authModeRetry = async () => {\n                            try {\n                                logger.debug(`Attempting mutation with authMode: ${operationAuthModes[authModeAttempts]}`);\n                                const response = await this.jitteredRetry(namespaceName, model, operation, data, condition, modelConstructor, this.MutationEvent, head, operationAuthModes[authModeAttempts], onTerminate);\n                                logger.debug(`Mutation sent successfully with authMode: ${operationAuthModes[authModeAttempts]}`);\n                                return response;\n                            }\n                            catch (error) {\n                                authModeAttempts++;\n                                if (authModeAttempts >= operationAuthModes.length) {\n                                    logger.debug(`Mutation failed with authMode: ${operationAuthModes[authModeAttempts - 1]}`);\n                                    try {\n                                        await this.errorHandler({\n                                            recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                                            localModel: null,\n                                            message: error.message,\n                                            model: modelConstructor.name,\n                                            operation: opName,\n                                            errorType: getMutationErrorType(error),\n                                            process: ProcessName.sync,\n                                            remoteModel: null,\n                                            cause: error,\n                                        });\n                                    }\n                                    catch (e) {\n                                        logger.error('Mutation error handler failed with:', e);\n                                    }\n                                    throw error;\n                                }\n                                logger.debug(`Mutation failed with authMode: ${operationAuthModes[authModeAttempts - 1]}. Retrying with authMode: ${operationAuthModes[authModeAttempts]}`);\n                                return await authModeRetry();\n                            }\n                        };\n                        [result, opName, modelDefinition] = await authModeRetry();\n                    }\n                    catch (error) {\n                        if (error.message === 'Offline' ||\n                            error.message === 'RetryMutation') {\n                            continue;\n                        }\n                    }\n                    if (result === undefined) {\n                        logger.debug('done retrying');\n                        await this.storage.runExclusive(async (storage) => {\n                            await this.outbox.dequeue(storage);\n                        });\n                        continue;\n                    }\n                    const record = result.data[opName];\n                    let hasMore = false;\n                    await this.storage.runExclusive(async (storage) => {\n                        // using runExclusive to prevent possible race condition\n                        // when another record gets enqueued between dequeue and peek\n                        await this.outbox.dequeue(storage, record, operation);\n                        hasMore = (await this.outbox.peek(storage)) !== undefined;\n                    });\n                    this.observer?.next?.({\n                        operation,\n                        modelDefinition,\n                        model: record,\n                        hasMore,\n                    });\n                }\n                // pauses itself\n                this.pause();\n            }, 'mutation resume loop');\n        }\n    }\n    async jitteredRetry(namespaceName, model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent, authMode, onTerminate) {\n        return await retry(async (model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent) => {\n            const [query, variables, graphQLCondition, opName, modelDefinition] = this.createQueryVariables(namespaceName, model, operation, data, condition);\n            const authToken = await getTokenForCustomAuth(authMode, this.amplifyConfig);\n            const tryWith = {\n                query,\n                variables,\n                authMode,\n                authToken,\n            };\n            let attempt = 0;\n            const opType = this.opTypeFromTransformerOperation(operation);\n            const customUserAgentDetails = {\n                category: Category.DataStore,\n                action: DataStoreAction.GraphQl,\n            };\n            do {\n                try {\n                    const result = (await this.amplifyContext.InternalAPI.graphql(tryWith, undefined, customUserAgentDetails));\n                    // Use `as any` because TypeScript doesn't seem to like passing tuples\n                    // through generic params.\n                    return [result, opName, modelDefinition];\n                }\n                catch (err) {\n                    if (err.errors && err.errors.length > 0) {\n                        const [error] = err.errors;\n                        const { originalError: { code = null } = {} } = error;\n                        if (error.errorType === 'Unauthorized') {\n                            throw new NonRetryableError('Unauthorized');\n                        }\n                        if (error.message === 'Network Error' ||\n                            code === 'ECONNABORTED' // refers to axios timeout error caused by device's bad network condition\n                        ) {\n                            if (!this.processing) {\n                                throw new NonRetryableError('Offline');\n                            }\n                            // TODO: Check errors on different env (react-native or other browsers)\n                            throw new Error('Network Error');\n                        }\n                        if (error.errorType === 'ConflictUnhandled') {\n                            // TODO: add on ConflictConditionalCheck error query last from server\n                            attempt++;\n                            let retryWith;\n                            if (attempt > MAX_ATTEMPTS) {\n                                retryWith = DISCARD;\n                            }\n                            else {\n                                try {\n                                    retryWith = await this.conflictHandler({\n                                        modelConstructor,\n                                        localModel: this.modelInstanceCreator(modelConstructor, variables.input),\n                                        remoteModel: this.modelInstanceCreator(modelConstructor, error.data),\n                                        operation: opType,\n                                        attempts: attempt,\n                                    });\n                                }\n                                catch (err) {\n                                    logger.warn('conflict trycatch', err);\n                                    continue;\n                                }\n                            }\n                            if (retryWith === DISCARD) {\n                                // Query latest from server and notify merger\n                                const [[, opName, query]] = buildGraphQLOperation(this.schema.namespaces[namespaceName], modelDefinition, 'GET');\n                                const authToken = await getTokenForCustomAuth(authMode, this.amplifyConfig);\n                                const serverData = await this.amplifyContext.InternalAPI.graphql({\n                                    query,\n                                    variables: { id: variables.input.id },\n                                    authMode,\n                                    authToken,\n                                }, undefined, customUserAgentDetails);\n                                // onTerminate cancel graphql()\n                                return [serverData, opName, modelDefinition];\n                            }\n                            const namespace = this.schema.namespaces[namespaceName];\n                            // convert retry with to tryWith\n                            const updatedMutation = createMutationInstanceFromModelOperation(namespace.relationships, modelDefinition, opType, modelConstructor, retryWith, graphQLCondition, MutationEvent, this.modelInstanceCreator, mutationEvent.id);\n                            await this.storage.save(updatedMutation);\n                            throw new NonRetryableError('RetryMutation');\n                        }\n                        else {\n                            try {\n                                this.errorHandler({\n                                    recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                                    localModel: variables.input,\n                                    message: error.message,\n                                    operation,\n                                    errorType: getMutationErrorType(error),\n                                    errorInfo: error.errorInfo,\n                                    process: ProcessName.mutate,\n                                    cause: error,\n                                    remoteModel: error.data\n                                        ? this.modelInstanceCreator(modelConstructor, error.data)\n                                        : null,\n                                });\n                            }\n                            catch (err) {\n                                logger.warn('Mutation error handler failed with:', err);\n                            }\n                            finally {\n                                // Return empty tuple, dequeues the mutation\n                                return error.data\n                                    ? [\n                                        { data: { [opName]: error.data } },\n                                        opName,\n                                        modelDefinition,\n                                    ]\n                                    : [];\n                            }\n                        }\n                    }\n                    else {\n                        // Catch-all for client-side errors that don't come back in the `GraphQLError` format.\n                        // These errors should not be retried.\n                        throw new NonRetryableError(err);\n                    }\n                }\n            } while (tryWith);\n        }, [\n            model,\n            operation,\n            data,\n            condition,\n            modelConstructor,\n            MutationEvent,\n            mutationEvent,\n        ], safeJitteredBackoff, onTerminate);\n    }\n    createQueryVariables(namespaceName, model, operation, data, condition) {\n        const modelDefinition = this.schema.namespaces[namespaceName].models[model];\n        const { primaryKey } = this.schema.namespaces[namespaceName].keys[model];\n        const auth = modelDefinition.attributes?.find(a => a.type === 'auth');\n        const ownerFields = auth?.properties?.rules\n            .map(rule => rule.ownerField)\n            .filter(f => f) || ['owner'];\n        const queriesTuples = this.typeQuery.get(modelDefinition);\n        const [, opName, query] = queriesTuples.find(([transformerMutationType]) => transformerMutationType === operation);\n        const { _version, ...parsedData } = JSON.parse(data);\n        // include all the fields that comprise a custom PK if one is specified\n        const deleteInput = {};\n        if (primaryKey && primaryKey.length) {\n            for (const pkField of primaryKey) {\n                deleteInput[pkField] = parsedData[pkField];\n            }\n        }\n        else {\n            deleteInput[ID] = parsedData.id;\n        }\n        let mutationInput;\n        if (operation === TransformerMutationType.DELETE) {\n            // For DELETE mutations, only the key(s) are included in the input\n            mutationInput = deleteInput;\n        }\n        else {\n            // Otherwise, we construct the mutation input with the following logic\n            mutationInput = {};\n            const modelFields = Object.values(modelDefinition.fields);\n            for (const { name, type, association, isReadOnly } of modelFields) {\n                // omit readonly fields. cloud storage doesn't need them and won't take them!\n                if (isReadOnly) {\n                    continue;\n                }\n                // omit owner fields if it's `null`. cloud storage doesn't allow it.\n                if (ownerFields.includes(name) && parsedData[name] === null) {\n                    continue;\n                }\n                // model fields should be stripped out from the input\n                if (isModelFieldType(type)) {\n                    // except for belongs to relations - we need to replace them with the correct foreign key(s)\n                    if (isTargetNameAssociation(association) &&\n                        association.connectionType === 'BELONGS_TO') {\n                        const targetNames = extractTargetNamesFromSrc(association);\n                        if (targetNames) {\n                            // instead of including the connected model itself, we add its key(s) to the mutation input\n                            for (const targetName of targetNames) {\n                                mutationInput[targetName] = parsedData[targetName];\n                            }\n                        }\n                    }\n                    continue;\n                }\n                // scalar fields / non-model types\n                if (operation === TransformerMutationType.UPDATE) {\n                    if (!parsedData.hasOwnProperty(name)) {\n                        // for update mutations - strip out a field if it's unchanged\n                        continue;\n                    }\n                }\n                // all other fields are added to the input object\n                mutationInput[name] = parsedData[name];\n            }\n        }\n        // Build mutation variables input object\n        const input = {\n            ...mutationInput,\n            _version,\n        };\n        const graphQLCondition = JSON.parse(condition);\n        const variables = {\n            input,\n            ...(operation === TransformerMutationType.CREATE\n                ? {}\n                : {\n                    condition: Object.keys(graphQLCondition).length > 0\n                        ? graphQLCondition\n                        : null,\n                }),\n        };\n        return [query, variables, graphQLCondition, opName, modelDefinition];\n    }\n    opTypeFromTransformerOperation(operation) {\n        switch (operation) {\n            case TransformerMutationType.CREATE:\n                return OpType.INSERT;\n            case TransformerMutationType.DELETE:\n                return OpType.DELETE;\n            case TransformerMutationType.UPDATE:\n                return OpType.UPDATE;\n            case TransformerMutationType.GET: // Intentionally blank\n                break;\n            default:\n                throw new Error(`Invalid operation ${operation}`);\n        }\n        // because it makes TS happy ...\n        return undefined;\n    }\n    pause() {\n        this.processing = false;\n    }\n}\nconst MAX_RETRY_DELAY_MS = 5 * 60 * 1000;\nconst originalJitteredBackoff = jitteredBackoff(MAX_RETRY_DELAY_MS);\n/**\n * @private\n * Internal use of Amplify only.\n *\n * Wraps the jittered backoff calculation to retry Network Errors indefinitely.\n * Backs off according to original jittered retry logic until the original retry\n * logic hits its max. After this occurs, if the error is a Network Error, we\n * ignore the attempt count and return MAX_RETRY_DELAY_MS to retry forever (until\n * the request succeeds).\n *\n * @param attempt ignored\n * @param _args ignored\n * @param error tested to see if `.message` is 'Network Error'\n * @returns number | false :\n */\nexport const safeJitteredBackoff = (attempt, _args, error) => {\n    const attemptResult = originalJitteredBackoff(attempt);\n    // If this is the last attempt and it is a network error, we retry indefinitively every 5 minutes\n    if (attemptResult === false &&\n        (error || {}).message === 'Network Error') {\n        return MAX_RETRY_DELAY_MS;\n    }\n    return attemptResult;\n};\nexport { MutationProcessor };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}