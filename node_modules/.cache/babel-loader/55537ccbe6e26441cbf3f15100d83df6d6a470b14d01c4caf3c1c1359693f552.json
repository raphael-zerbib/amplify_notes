{"ast":null,"code":"import { BackgroundProcessManager } from '@aws-amplify/core/internals/utils';\nimport { ConsoleLogger, Hub } from '@aws-amplify/core';\nimport { Observable, filter, of } from 'rxjs';\nimport { ModelPredicateCreator } from '../predicates/index.mjs';\nimport { OpType } from '../types.mjs';\nimport { getNow, USER, SYNC } from '../util.mjs';\nimport DataStoreConnectivity from './datastoreConnectivity.mjs';\nimport { ModelMerger } from './merger.mjs';\nimport { MutationEventOutbox } from './outbox.mjs';\nimport { MutationProcessor } from './processors/mutation.mjs';\nimport { SubscriptionProcessor, CONTROL_MSG } from './processors/subscription.mjs';\nimport { SyncProcessor } from './processors/sync.mjs';\nimport { predicateToGraphQLCondition, createMutationInstanceFromModelOperation, getIdentifierValue } from './utils.mjs';\nimport { CONTROL_MSG as CONTROL_MSG$1, CONNECTION_STATE_CHANGE, ConnectionState } from '@aws-amplify/api-graphql';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('DataStore');\nconst ownSymbol = Symbol('sync');\nvar ControlMessage;\n(function (ControlMessage) {\n  ControlMessage[\"SYNC_ENGINE_STORAGE_SUBSCRIBED\"] = \"storageSubscribed\";\n  ControlMessage[\"SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\"] = \"subscriptionsEstablished\";\n  ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_STARTED\"] = \"syncQueriesStarted\";\n  ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_READY\"] = \"syncQueriesReady\";\n  ControlMessage[\"SYNC_ENGINE_MODEL_SYNCED\"] = \"modelSynced\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED\"] = \"outboxMutationEnqueued\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED\"] = \"outboxMutationProcessed\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_STATUS\"] = \"outboxStatus\";\n  ControlMessage[\"SYNC_ENGINE_NETWORK_STATUS\"] = \"networkStatus\";\n  ControlMessage[\"SYNC_ENGINE_READY\"] = \"ready\";\n})(ControlMessage || (ControlMessage = {}));\nclass SyncEngine {\n  getModelSyncedStatus(modelConstructor) {\n    return this.modelSyncedStatus.get(modelConstructor);\n  }\n  constructor(schema, namespaceResolver, modelClasses, userModelClasses, storage, modelInstanceCreator, conflictHandler, errorHandler, syncPredicates) {\n    let amplifyConfig = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : {};\n    let authModeStrategy = arguments.length > 10 ? arguments[10] : undefined;\n    let amplifyContext = arguments.length > 11 ? arguments[11] : undefined;\n    let connectivityMonitor = arguments.length > 12 ? arguments[12] : undefined;\n    this.schema = schema;\n    this.namespaceResolver = namespaceResolver;\n    this.modelClasses = modelClasses;\n    this.userModelClasses = userModelClasses;\n    this.storage = storage;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.syncPredicates = syncPredicates;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.amplifyContext = amplifyContext;\n    this.connectivityMonitor = connectivityMonitor;\n    this.online = false;\n    this.modelSyncedStatus = new WeakMap();\n    this.connectionDisrupted = false;\n    this.runningProcesses = new BackgroundProcessManager();\n    this.waitForSleepState = new Promise(resolve => {\n      this.syncQueriesObservableStartSleeping = resolve;\n    });\n    const MutationEvent = this.modelClasses['MutationEvent'];\n    this.outbox = new MutationEventOutbox(this.schema, MutationEvent, modelInstanceCreator, ownSymbol);\n    this.modelMerger = new ModelMerger(this.outbox, ownSymbol);\n    this.syncQueriesProcessor = new SyncProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n    this.subscriptionsProcessor = new SubscriptionProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n    this.mutationsProcessor = new MutationProcessor(this.schema, this.storage, this.userModelClasses, this.outbox, this.modelInstanceCreator, MutationEvent, this.amplifyConfig, this.authModeStrategy, errorHandler, conflictHandler, this.amplifyContext);\n    this.datastoreConnectivity = this.connectivityMonitor || new DataStoreConnectivity();\n  }\n  start(params) {\n    return new Observable(observer => {\n      logger.log('starting sync engine...');\n      let subscriptions = [];\n      this.runningProcesses.add(async () => {\n        try {\n          await this.setupModels(params);\n        } catch (err) {\n          observer.error(err);\n          return;\n        }\n        // this is awaited at the bottom. so, we don't need to register\n        // this explicitly with the context. it's already contained.\n        const startPromise = new Promise((doneStarting, failedStarting) => {\n          this.datastoreConnectivity.status().subscribe(async _ref => {\n            let {\n              online\n            } = _ref;\n            return this.runningProcesses.isOpen && this.runningProcesses.add(async onTerminate => {\n              // From offline to online\n              if (online && !this.online) {\n                this.online = online;\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                  data: {\n                    active: this.online\n                  }\n                });\n                let ctlSubsObservable;\n                let dataSubsObservable;\n                this.stopDisruptionListener = this.startDisruptionListener();\n                //#region GraphQL Subscriptions\n                [ctlSubsObservable, dataSubsObservable] = this.subscriptionsProcessor.start();\n                try {\n                  await new Promise((resolve, reject) => {\n                    onTerminate.then(reject);\n                    const ctlSubsSubscription = ctlSubsObservable.subscribe({\n                      next: msg => {\n                        if (msg === CONTROL_MSG.CONNECTED) {\n                          resolve();\n                        }\n                      },\n                      error: err => {\n                        reject(err);\n                        const handleDisconnect = this.disconnectionHandler();\n                        handleDisconnect(err);\n                      }\n                    });\n                    subscriptions.push(ctlSubsSubscription);\n                  });\n                } catch (err) {\n                  observer.error(err);\n                  failedStarting();\n                  return;\n                }\n                logger.log('Realtime ready');\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\n                });\n                //#endregion\n                //#region Base & Sync queries\n                try {\n                  await new Promise((resolve, reject) => {\n                    const syncQuerySubscription = this.syncQueriesObservable().subscribe({\n                      next: message => {\n                        const {\n                          type\n                        } = message;\n                        if (type === ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY) {\n                          resolve();\n                        }\n                        observer.next(message);\n                      },\n                      complete: () => {\n                        resolve();\n                      },\n                      error: error => {\n                        reject(error);\n                      }\n                    });\n                    if (syncQuerySubscription) {\n                      subscriptions.push(syncQuerySubscription);\n                    }\n                  });\n                } catch (error) {\n                  observer.error(error);\n                  failedStarting();\n                  return;\n                }\n                //#endregion\n                //#region process mutations (outbox)\n                subscriptions.push(this.mutationsProcessor.start().subscribe(_ref2 => {\n                  let {\n                    modelDefinition,\n                    model: item,\n                    hasMore\n                  } = _ref2;\n                  return this.runningProcesses.add(async () => {\n                    const modelConstructor = this.userModelClasses[modelDefinition.name];\n                    const model = this.modelInstanceCreator(modelConstructor, item);\n                    await this.storage.runExclusive(storage => this.modelMerger.merge(storage, model, modelDefinition));\n                    observer.next({\n                      type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED,\n                      data: {\n                        model: modelConstructor,\n                        element: model\n                      }\n                    });\n                    observer.next({\n                      type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                      data: {\n                        isEmpty: !hasMore\n                      }\n                    });\n                  }, 'mutation processor event');\n                }));\n                //#endregion\n                //#region Merge subscriptions buffer\n                subscriptions.push(dataSubsObservable.subscribe(_ref3 => {\n                  let [_transformerMutationType, modelDefinition, item] = _ref3;\n                  return this.runningProcesses.add(async () => {\n                    const modelConstructor = this.userModelClasses[modelDefinition.name];\n                    const model = this.modelInstanceCreator(modelConstructor, item);\n                    await this.storage.runExclusive(storage => this.modelMerger.merge(storage, model, modelDefinition));\n                  }, 'subscription dataSubsObservable event');\n                }));\n                //#endregion\n              } else if (!online) {\n                this.online = online;\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                  data: {\n                    active: this.online\n                  }\n                });\n                subscriptions.forEach(sub => sub.unsubscribe());\n                subscriptions = [];\n              }\n              doneStarting();\n            }, 'datastore connectivity event');\n          });\n        });\n        this.storage.observe(null, null, ownSymbol).pipe(filter(_ref4 => {\n          let {\n            model\n          } = _ref4;\n          const modelDefinition = this.getModelDefinition(model);\n          return modelDefinition.syncable === true;\n        })).subscribe({\n          next: async _ref5 => {\n            let {\n              opType,\n              model,\n              element,\n              condition\n            } = _ref5;\n            return this.runningProcesses.add(async () => {\n              const namespace = this.schema.namespaces[this.namespaceResolver(model)];\n              const MutationEventConstructor = this.modelClasses['MutationEvent'];\n              const modelDefinition = this.getModelDefinition(model);\n              const graphQLCondition = predicateToGraphQLCondition(condition, modelDefinition);\n              const mutationEvent = createMutationInstanceFromModelOperation(namespace.relationships, this.getModelDefinition(model), opType, model, element, graphQLCondition, MutationEventConstructor, this.modelInstanceCreator);\n              await this.outbox.enqueue(this.storage, mutationEvent);\n              observer.next({\n                type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED,\n                data: {\n                  model,\n                  element\n                }\n              });\n              observer.next({\n                type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                data: {\n                  isEmpty: false\n                }\n              });\n              await startPromise;\n              // Set by the this.datastoreConnectivity.status().subscribe() loop\n              if (this.online) {\n                this.mutationsProcessor.resume();\n              }\n            }, 'storage event');\n          }\n        });\n        observer.next({\n          type: ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED\n        });\n        const hasMutationsInOutbox = (await this.outbox.peek(this.storage)) === undefined;\n        observer.next({\n          type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n          data: {\n            isEmpty: hasMutationsInOutbox\n          }\n        });\n        await startPromise;\n        observer.next({\n          type: ControlMessage.SYNC_ENGINE_READY\n        });\n      }, 'sync start');\n    });\n  }\n  async getModelsMetadataWithNextFullSync(currentTimeStamp) {\n    const modelLastSync = new Map((await this.runningProcesses.add(() => this.getModelsMetadata(), 'sync/index getModelsMetadataWithNextFullSync')).map(_ref6 => {\n      let {\n        namespace,\n        model,\n        lastSync,\n        lastFullSync,\n        fullSyncInterval,\n        lastSyncPredicate\n      } = _ref6;\n      const nextFullSync = lastFullSync + fullSyncInterval;\n      const syncFrom = !lastFullSync || nextFullSync < currentTimeStamp ? 0 // perform full sync if expired\n      : lastSync; // perform delta sync\n      return [this.schema.namespaces[namespace].models[model], [namespace, syncFrom]];\n    }));\n    return modelLastSync;\n  }\n  syncQueriesObservable() {\n    if (!this.online) {\n      return of({}); // TODO(v6): fix this\n    }\n    return new Observable(observer => {\n      let syncQueriesSubscription;\n      this.runningProcesses.isOpen && this.runningProcesses.add(async onTerminate => {\n        let terminated = false;\n        while (!observer.closed && !terminated) {\n          const count = new WeakMap();\n          const modelLastSync = await this.getModelsMetadataWithNextFullSync(Date.now());\n          const paginatingModels = new Set(modelLastSync.keys());\n          let lastFullSyncStartedAt;\n          let syncInterval;\n          let start;\n          let syncDuration;\n          let lastStartedAt;\n          await new Promise((resolve, reject) => {\n            if (!this.runningProcesses.isOpen) resolve();\n            onTerminate.then(() => resolve());\n            syncQueriesSubscription = this.syncQueriesProcessor.start(modelLastSync).subscribe({\n              next: async _ref7 => {\n                let {\n                  namespace,\n                  modelDefinition,\n                  items,\n                  done,\n                  startedAt,\n                  isFullSync\n                } = _ref7;\n                const modelConstructor = this.userModelClasses[modelDefinition.name];\n                if (!count.has(modelConstructor)) {\n                  count.set(modelConstructor, {\n                    new: 0,\n                    updated: 0,\n                    deleted: 0\n                  });\n                  start = getNow();\n                  lastStartedAt = lastStartedAt === undefined ? startedAt : Math.max(lastStartedAt, startedAt);\n                }\n                /**\n                 * If there are mutations in the outbox for a given id, those need to be\n                 * merged individually. Otherwise, we can merge them in batches.\n                 */\n                await this.storage.runExclusive(async storage => {\n                  const idsInOutbox = await this.outbox.getModelIds(storage);\n                  const oneByOne = [];\n                  const page = items.filter(item => {\n                    const itemId = getIdentifierValue(modelDefinition, item);\n                    if (!idsInOutbox.has(itemId)) {\n                      return true;\n                    }\n                    oneByOne.push(item);\n                    return false;\n                  });\n                  const opTypeCount = [];\n                  for (const item of oneByOne) {\n                    const opType = await this.modelMerger.merge(storage, item, modelDefinition);\n                    if (opType !== undefined) {\n                      opTypeCount.push([item, opType]);\n                    }\n                  }\n                  opTypeCount.push(...(await this.modelMerger.mergePage(storage, modelConstructor, page, modelDefinition)));\n                  const counts = count.get(modelConstructor);\n                  opTypeCount.forEach(_ref8 => {\n                    let [, opType] = _ref8;\n                    switch (opType) {\n                      case OpType.INSERT:\n                        counts.new++;\n                        break;\n                      case OpType.UPDATE:\n                        counts.updated++;\n                        break;\n                      case OpType.DELETE:\n                        counts.deleted++;\n                        break;\n                      default:\n                        throw new Error(\"Invalid opType \".concat(opType));\n                    }\n                  });\n                });\n                if (done) {\n                  const {\n                    name: modelName\n                  } = modelDefinition;\n                  //#region update last sync for type\n                  let modelMetadata = await this.getModelMetadata(namespace, modelName);\n                  const {\n                    lastFullSync,\n                    fullSyncInterval\n                  } = modelMetadata;\n                  syncInterval = fullSyncInterval;\n                  lastFullSyncStartedAt = lastFullSyncStartedAt === undefined ? lastFullSync : Math.max(lastFullSyncStartedAt, isFullSync ? startedAt : lastFullSync);\n                  modelMetadata = this.modelClasses.ModelMetadata.copyOf(modelMetadata, draft => {\n                    draft.lastSync = startedAt;\n                    draft.lastFullSync = isFullSync ? startedAt : modelMetadata.lastFullSync;\n                  });\n                  await this.storage.save(modelMetadata, undefined, ownSymbol);\n                  //#endregion\n                  const counts = count.get(modelConstructor);\n                  this.modelSyncedStatus.set(modelConstructor, true);\n                  observer.next({\n                    type: ControlMessage.SYNC_ENGINE_MODEL_SYNCED,\n                    data: {\n                      model: modelConstructor,\n                      isFullSync,\n                      isDeltaSync: !isFullSync,\n                      counts\n                    }\n                  });\n                  paginatingModels.delete(modelDefinition);\n                  if (paginatingModels.size === 0) {\n                    syncDuration = getNow() - start;\n                    resolve();\n                    observer.next({\n                      type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY\n                    });\n                    syncQueriesSubscription.unsubscribe();\n                  }\n                }\n              },\n              error: error => {\n                observer.error(error);\n              }\n            });\n            observer.next({\n              type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_STARTED,\n              data: {\n                models: Array.from(paginatingModels).map(_ref9 => {\n                  let {\n                    name\n                  } = _ref9;\n                  return name;\n                })\n              }\n            });\n          });\n          // null is cast to 0 resulting in unexpected behavior.\n          // undefined in arithmetic operations results in NaN also resulting in unexpected behavior.\n          // If lastFullSyncStartedAt is null this is the first sync.\n          // Assume lastStartedAt is is also newest full sync.\n          let msNextFullSync;\n          if (!lastFullSyncStartedAt) {\n            msNextFullSync = syncInterval - syncDuration;\n          } else {\n            msNextFullSync = lastFullSyncStartedAt + syncInterval - (lastStartedAt + syncDuration);\n          }\n          logger.debug(\"Next fullSync in \".concat(msNextFullSync / 1000, \" seconds. (\").concat(new Date(Date.now() + msNextFullSync), \")\"));\n          // TODO: create `BackgroundProcessManager.sleep()` ... but, need to put\n          // a lot of thought into what that contract looks like to\n          //  support possible use-cases:\n          //\n          //  1. non-cancelable\n          //  2. cancelable, unsleep on exit()\n          //  3. cancelable, throw Error on exit()\n          //  4. cancelable, callback first on exit()?\n          //  5. ... etc. ? ...\n          //\n          // TLDR; this is a lot of complexity here for a sleep(),\n          // but, it's not clear to me yet how to support an\n          // extensible, centralized cancelable `sleep()` elegantly.\n          await this.runningProcesses.add(async onTerminate => {\n            let unsleep;\n            const sleep = new Promise(_unsleep => {\n              unsleep = _unsleep;\n              setTimeout(unsleep, msNextFullSync);\n            });\n            onTerminate.then(() => {\n              terminated = true;\n              this.syncQueriesObservableStartSleeping();\n              unsleep();\n            });\n            this.unsleepSyncQueriesObservable = unsleep;\n            this.syncQueriesObservableStartSleeping();\n            return sleep;\n          }, 'syncQueriesObservable sleep');\n          this.unsleepSyncQueriesObservable = null;\n          this.waitForSleepState = new Promise(resolve => {\n            this.syncQueriesObservableStartSleeping = resolve;\n          });\n        }\n      }, 'syncQueriesObservable main');\n    });\n  }\n  disconnectionHandler() {\n    return msg => {\n      // This implementation is tied to AWSAppSyncRealTimeProvider 'Connection closed', 'Timeout disconnect' msg\n      if (CONTROL_MSG$1.CONNECTION_CLOSED === msg || CONTROL_MSG$1.TIMEOUT_DISCONNECT === msg) {\n        this.datastoreConnectivity.socketDisconnected();\n      }\n    };\n  }\n  unsubscribeConnectivity() {\n    this.datastoreConnectivity.unsubscribe();\n  }\n  /**\n   * Stops all subscription activities and resolves when all activies report\n   * that they're disconnected, done retrying, etc..\n   */\n  async stop() {\n    logger.debug('stopping sync engine');\n    /**\n     * Gracefully disconnecting subscribers first just prevents *more* work\n     * from entering the pipelines.\n     */\n    this.unsubscribeConnectivity();\n    /**\n     * Stop listening for websocket connection disruption\n     */\n    this.stopDisruptionListener && this.stopDisruptionListener();\n    /**\n     * aggressively shut down any lingering background processes.\n     * some of this might be semi-redundant with unsubscribing. however,\n     * unsubscribing doesn't allow us to wait for settling.\n     * (Whereas `stop()` does.)\n     */\n    await this.mutationsProcessor.stop();\n    await this.subscriptionsProcessor.stop();\n    await this.datastoreConnectivity.stop();\n    await this.syncQueriesProcessor.stop();\n    await this.runningProcesses.close();\n    await this.runningProcesses.open();\n    logger.debug('sync engine stopped and ready to restart');\n  }\n  async setupModels(params) {\n    const {\n      fullSyncInterval\n    } = params;\n    const ModelMetadataConstructor = this.modelClasses.ModelMetadata;\n    const models = [];\n    let savedModel;\n    Object.values(this.schema.namespaces).forEach(namespace => {\n      Object.values(namespace.models).filter(_ref10 => {\n        let {\n          syncable\n        } = _ref10;\n        return syncable;\n      }).forEach(model => {\n        models.push([namespace.name, model]);\n        if (namespace.name === USER) {\n          const modelConstructor = this.userModelClasses[model.name];\n          this.modelSyncedStatus.set(modelConstructor, false);\n        }\n      });\n    });\n    const promises = models.map(async _ref11 => {\n      let [namespace, model] = _ref11;\n      const modelMetadata = await this.getModelMetadata(namespace, model.name);\n      const syncPredicate = ModelPredicateCreator.getPredicates(this.syncPredicates.get(model), false);\n      const lastSyncPredicate = syncPredicate ? JSON.stringify(syncPredicate) : null;\n      if (modelMetadata === undefined) {\n        [[savedModel]] = await this.storage.save(this.modelInstanceCreator(ModelMetadataConstructor, {\n          model: model.name,\n          namespace,\n          lastSync: null,\n          fullSyncInterval,\n          lastFullSync: null,\n          lastSyncPredicate\n        }), undefined, ownSymbol);\n      } else {\n        const prevSyncPredicate = modelMetadata.lastSyncPredicate ? modelMetadata.lastSyncPredicate : null;\n        const syncPredicateUpdated = prevSyncPredicate !== lastSyncPredicate;\n        [[savedModel]] = await this.storage.save(ModelMetadataConstructor.copyOf(modelMetadata, draft => {\n          draft.fullSyncInterval = fullSyncInterval;\n          // perform a base sync if the syncPredicate changed in between calls to DataStore.start\n          // ensures that the local store contains all the data specified by the syncExpression\n          if (syncPredicateUpdated) {\n            draft.lastSync = null;\n            draft.lastFullSync = null;\n            draft.lastSyncPredicate = lastSyncPredicate;\n          }\n        }));\n      }\n      return savedModel;\n    });\n    const result = {};\n    for (const modelMetadata of await Promise.all(promises)) {\n      const {\n        model: modelName\n      } = modelMetadata;\n      result[modelName] = modelMetadata;\n    }\n    return result;\n  }\n  async getModelsMetadata() {\n    const ModelMetadata = this.modelClasses.ModelMetadata;\n    const modelsMetadata = await this.storage.query(ModelMetadata);\n    return modelsMetadata;\n  }\n  async getModelMetadata(namespace, model) {\n    const ModelMetadata = this.modelClasses.ModelMetadata;\n    const predicate = ModelPredicateCreator.createFromAST(this.schema.namespaces[SYNC].models[ModelMetadata.name], {\n      and: [{\n        namespace: {\n          eq: namespace\n        }\n      }, {\n        model: {\n          eq: model\n        }\n      }]\n    });\n    const [modelMetadata] = await this.storage.query(ModelMetadata, predicate, {\n      page: 0,\n      limit: 1\n    });\n    return modelMetadata;\n  }\n  getModelDefinition(modelConstructor) {\n    const namespaceName = this.namespaceResolver(modelConstructor);\n    const modelDefinition = this.schema.namespaces[namespaceName].models[modelConstructor.name];\n    return modelDefinition;\n  }\n  static getNamespace() {\n    const namespace = {\n      name: SYNC,\n      relationships: {},\n      enums: {\n        OperationType: {\n          name: 'OperationType',\n          values: ['CREATE', 'UPDATE', 'DELETE']\n        }\n      },\n      nonModels: {},\n      models: {\n        MutationEvent: {\n          name: 'MutationEvent',\n          pluralName: 'MutationEvents',\n          syncable: false,\n          fields: {\n            id: {\n              name: 'id',\n              type: 'ID',\n              isRequired: true,\n              isArray: false\n            },\n            model: {\n              name: 'model',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            data: {\n              name: 'data',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            modelId: {\n              name: 'modelId',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            operation: {\n              name: 'operation',\n              type: {\n                enum: 'Operationtype'\n              },\n              isArray: false,\n              isRequired: true\n            },\n            condition: {\n              name: 'condition',\n              type: 'String',\n              isArray: false,\n              isRequired: true\n            }\n          }\n        },\n        ModelMetadata: {\n          name: 'ModelMetadata',\n          pluralName: 'ModelsMetadata',\n          syncable: false,\n          fields: {\n            id: {\n              name: 'id',\n              type: 'ID',\n              isRequired: true,\n              isArray: false\n            },\n            namespace: {\n              name: 'namespace',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            model: {\n              name: 'model',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            lastSync: {\n              name: 'lastSync',\n              type: 'Int',\n              isRequired: false,\n              isArray: false\n            },\n            lastFullSync: {\n              name: 'lastFullSync',\n              type: 'Int',\n              isRequired: false,\n              isArray: false\n            },\n            fullSyncInterval: {\n              name: 'fullSyncInterval',\n              type: 'Int',\n              isRequired: true,\n              isArray: false\n            },\n            lastSyncPredicate: {\n              name: 'lastSyncPredicate',\n              type: 'String',\n              isRequired: false,\n              isArray: false\n            }\n          }\n        }\n      }\n    };\n    return namespace;\n  }\n  /**\n   * listen for websocket connection disruption\n   *\n   * May indicate there was a period of time where messages\n   * from AppSync were missed. A sync needs to be triggered to\n   * retrieve the missed data.\n   */\n  startDisruptionListener() {\n    return Hub.listen('api', data => {\n      if (data.source === 'PubSub' && data.payload.event === CONNECTION_STATE_CHANGE) {\n        const connectionState = data.payload.data.connectionState;\n        switch (connectionState) {\n          // Do not need to listen for ConnectionDisruptedPendingNetwork\n          // Normal network reconnection logic will handle the sync\n          case ConnectionState.ConnectionDisrupted:\n            this.connectionDisrupted = true;\n            break;\n          case ConnectionState.Connected:\n            if (this.connectionDisrupted) {\n              this.scheduleSync();\n            }\n            this.connectionDisrupted = false;\n            break;\n        }\n      }\n    });\n  }\n  /*\n   * Schedule a sync to start when syncQueriesObservable enters sleep state\n   * Start sync immediately if syncQueriesObservable is already in sleep state\n   */\n  scheduleSync() {\n    return this.runningProcesses.isOpen && this.runningProcesses.add(() => this.waitForSleepState.then(() => {\n      // unsleepSyncQueriesObservable will be set if waitForSleepState has resolved\n      this.unsleepSyncQueriesObservable();\n    }));\n  }\n}\nexport { ControlMessage, SyncEngine };","map":{"version":3,"names":["logger","ConsoleLogger","ownSymbol","Symbol","ControlMessage","SyncEngine","getModelSyncedStatus","modelConstructor","modelSyncedStatus","get","constructor","schema","namespaceResolver","modelClasses","userModelClasses","storage","modelInstanceCreator","conflictHandler","errorHandler","syncPredicates","amplifyConfig","arguments","length","undefined","authModeStrategy","amplifyContext","connectivityMonitor","online","WeakMap","connectionDisrupted","runningProcesses","BackgroundProcessManager","waitForSleepState","Promise","resolve","syncQueriesObservableStartSleeping","MutationEvent","outbox","MutationEventOutbox","modelMerger","ModelMerger","syncQueriesProcessor","SyncProcessor","subscriptionsProcessor","SubscriptionProcessor","mutationsProcessor","MutationProcessor","datastoreConnectivity","DataStoreConnectivity","start","params","Observable","observer","log","subscriptions","add","setupModels","err","error","startPromise","doneStarting","failedStarting","status","subscribe","_ref","isOpen","onTerminate","next","type","SYNC_ENGINE_NETWORK_STATUS","data","active","ctlSubsObservable","dataSubsObservable","stopDisruptionListener","startDisruptionListener","reject","then","ctlSubsSubscription","msg","CONTROL_MSG","CONNECTED","handleDisconnect","disconnectionHandler","push","SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED","syncQuerySubscription","syncQueriesObservable","message","SYNC_ENGINE_SYNC_QUERIES_READY","complete","_ref2","modelDefinition","model","item","hasMore","name","runExclusive","merge","SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED","element","SYNC_ENGINE_OUTBOX_STATUS","isEmpty","_ref3","_transformerMutationType","forEach","sub","unsubscribe","observe","pipe","filter","_ref4","getModelDefinition","syncable","_ref5","opType","condition","namespace","namespaces","MutationEventConstructor","graphQLCondition","predicateToGraphQLCondition","mutationEvent","createMutationInstanceFromModelOperation","relationships","enqueue","SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED","resume","SYNC_ENGINE_STORAGE_SUBSCRIBED","hasMutationsInOutbox","peek","SYNC_ENGINE_READY","getModelsMetadataWithNextFullSync","currentTimeStamp","modelLastSync","Map","getModelsMetadata","map","_ref6","lastSync","lastFullSync","fullSyncInterval","lastSyncPredicate","nextFullSync","syncFrom","models","of","syncQueriesSubscription","terminated","closed","count","Date","now","paginatingModels","Set","keys","lastFullSyncStartedAt","syncInterval","syncDuration","lastStartedAt","_ref7","items","done","startedAt","isFullSync","has","set","new","updated","deleted","getNow","Math","max","idsInOutbox","getModelIds","oneByOne","page","itemId","getIdentifierValue","opTypeCount","mergePage","counts","_ref8","OpType","INSERT","UPDATE","DELETE","Error","concat","modelName","modelMetadata","getModelMetadata","ModelMetadata","copyOf","draft","save","SYNC_ENGINE_MODEL_SYNCED","isDeltaSync","delete","size","SYNC_ENGINE_SYNC_QUERIES_STARTED","Array","from","_ref9","msNextFullSync","debug","unsleep","sleep","_unsleep","setTimeout","unsleepSyncQueriesObservable","CONTROL_MSG$1","CONNECTION_CLOSED","TIMEOUT_DISCONNECT","socketDisconnected","unsubscribeConnectivity","stop","close","open","ModelMetadataConstructor","savedModel","Object","values","_ref10","USER","promises","_ref11","syncPredicate","ModelPredicateCreator","getPredicates","JSON","stringify","prevSyncPredicate","syncPredicateUpdated","result","all","modelsMetadata","query","predicate","createFromAST","SYNC","and","eq","limit","namespaceName","getNamespace","enums","OperationType","nonModels","pluralName","fields","id","isRequired","isArray","modelId","operation","enum","Hub","listen","source","payload","event","CONNECTION_STATE_CHANGE","connectionState","ConnectionState","ConnectionDisrupted","Connected","scheduleSync"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/sync/index.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { BackgroundProcessManager } from '@aws-amplify/core/internals/utils';\nimport { Hub, ConsoleLogger } from '@aws-amplify/core';\nimport { filter, Observable, of } from 'rxjs';\nimport { ModelPredicateCreator } from '../predicates';\nimport { OpType, } from '../types';\nimport { getNow, SYNC, USER } from '../util';\nimport DataStoreConnectivity from './datastoreConnectivity';\nimport { ModelMerger } from './merger';\nimport { MutationEventOutbox } from './outbox';\nimport { MutationProcessor } from './processors/mutation';\nimport { CONTROL_MSG, SubscriptionProcessor } from './processors/subscription';\nimport { SyncProcessor } from './processors/sync';\nimport { createMutationInstanceFromModelOperation, getIdentifierValue, predicateToGraphQLCondition, } from './utils';\nimport { CONTROL_MSG as PUBSUB_CONTROL_MSG, ConnectionState, CONNECTION_STATE_CHANGE as PUBSUB_CONNECTION_STATE_CHANGE, } from '@aws-amplify/api-graphql';\nconst logger = new ConsoleLogger('DataStore');\nconst ownSymbol = Symbol('sync');\nexport var ControlMessage;\n(function (ControlMessage) {\n    ControlMessage[\"SYNC_ENGINE_STORAGE_SUBSCRIBED\"] = \"storageSubscribed\";\n    ControlMessage[\"SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\"] = \"subscriptionsEstablished\";\n    ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_STARTED\"] = \"syncQueriesStarted\";\n    ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_READY\"] = \"syncQueriesReady\";\n    ControlMessage[\"SYNC_ENGINE_MODEL_SYNCED\"] = \"modelSynced\";\n    ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED\"] = \"outboxMutationEnqueued\";\n    ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED\"] = \"outboxMutationProcessed\";\n    ControlMessage[\"SYNC_ENGINE_OUTBOX_STATUS\"] = \"outboxStatus\";\n    ControlMessage[\"SYNC_ENGINE_NETWORK_STATUS\"] = \"networkStatus\";\n    ControlMessage[\"SYNC_ENGINE_READY\"] = \"ready\";\n})(ControlMessage || (ControlMessage = {}));\nexport class SyncEngine {\n    getModelSyncedStatus(modelConstructor) {\n        return this.modelSyncedStatus.get(modelConstructor);\n    }\n    constructor(schema, namespaceResolver, modelClasses, userModelClasses, storage, modelInstanceCreator, conflictHandler, errorHandler, syncPredicates, amplifyConfig = {}, authModeStrategy, amplifyContext, connectivityMonitor) {\n        this.schema = schema;\n        this.namespaceResolver = namespaceResolver;\n        this.modelClasses = modelClasses;\n        this.userModelClasses = userModelClasses;\n        this.storage = storage;\n        this.modelInstanceCreator = modelInstanceCreator;\n        this.syncPredicates = syncPredicates;\n        this.amplifyConfig = amplifyConfig;\n        this.authModeStrategy = authModeStrategy;\n        this.amplifyContext = amplifyContext;\n        this.connectivityMonitor = connectivityMonitor;\n        this.online = false;\n        this.modelSyncedStatus = new WeakMap();\n        this.connectionDisrupted = false;\n        this.runningProcesses = new BackgroundProcessManager();\n        this.waitForSleepState = new Promise(resolve => {\n            this.syncQueriesObservableStartSleeping = resolve;\n        });\n        const MutationEvent = this.modelClasses['MutationEvent'];\n        this.outbox = new MutationEventOutbox(this.schema, MutationEvent, modelInstanceCreator, ownSymbol);\n        this.modelMerger = new ModelMerger(this.outbox, ownSymbol);\n        this.syncQueriesProcessor = new SyncProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n        this.subscriptionsProcessor = new SubscriptionProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n        this.mutationsProcessor = new MutationProcessor(this.schema, this.storage, this.userModelClasses, this.outbox, this.modelInstanceCreator, MutationEvent, this.amplifyConfig, this.authModeStrategy, errorHandler, conflictHandler, this.amplifyContext);\n        this.datastoreConnectivity =\n            this.connectivityMonitor || new DataStoreConnectivity();\n    }\n    start(params) {\n        return new Observable(observer => {\n            logger.log('starting sync engine...');\n            let subscriptions = [];\n            this.runningProcesses.add(async () => {\n                try {\n                    await this.setupModels(params);\n                }\n                catch (err) {\n                    observer.error(err);\n                    return;\n                }\n                // this is awaited at the bottom. so, we don't need to register\n                // this explicitly with the context. it's already contained.\n                const startPromise = new Promise((doneStarting, failedStarting) => {\n                    this.datastoreConnectivity.status().subscribe(async ({ online }) => this.runningProcesses.isOpen &&\n                        this.runningProcesses.add(async (onTerminate) => {\n                            // From offline to online\n                            if (online && !this.online) {\n                                this.online = online;\n                                observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                                    data: {\n                                        active: this.online,\n                                    },\n                                });\n                                let ctlSubsObservable;\n                                let dataSubsObservable;\n                                this.stopDisruptionListener =\n                                    this.startDisruptionListener();\n                                //#region GraphQL Subscriptions\n                                [ctlSubsObservable, dataSubsObservable] =\n                                    this.subscriptionsProcessor.start();\n                                try {\n                                    await new Promise((resolve, reject) => {\n                                        onTerminate.then(reject);\n                                        const ctlSubsSubscription = ctlSubsObservable.subscribe({\n                                            next: msg => {\n                                                if (msg === CONTROL_MSG.CONNECTED) {\n                                                    resolve();\n                                                }\n                                            },\n                                            error: err => {\n                                                reject(err);\n                                                const handleDisconnect = this.disconnectionHandler();\n                                                handleDisconnect(err);\n                                            },\n                                        });\n                                        subscriptions.push(ctlSubsSubscription);\n                                    });\n                                }\n                                catch (err) {\n                                    observer.error(err);\n                                    failedStarting();\n                                    return;\n                                }\n                                logger.log('Realtime ready');\n                                observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED,\n                                });\n                                //#endregion\n                                //#region Base & Sync queries\n                                try {\n                                    await new Promise((resolve, reject) => {\n                                        const syncQuerySubscription = this.syncQueriesObservable().subscribe({\n                                            next: message => {\n                                                const { type } = message;\n                                                if (type ===\n                                                    ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY) {\n                                                    resolve();\n                                                }\n                                                observer.next(message);\n                                            },\n                                            complete: () => {\n                                                resolve();\n                                            },\n                                            error: error => {\n                                                reject(error);\n                                            },\n                                        });\n                                        if (syncQuerySubscription) {\n                                            subscriptions.push(syncQuerySubscription);\n                                        }\n                                    });\n                                }\n                                catch (error) {\n                                    observer.error(error);\n                                    failedStarting();\n                                    return;\n                                }\n                                //#endregion\n                                //#region process mutations (outbox)\n                                subscriptions.push(this.mutationsProcessor\n                                    .start()\n                                    .subscribe(({ modelDefinition, model: item, hasMore }) => this.runningProcesses.add(async () => {\n                                    const modelConstructor = this.userModelClasses[modelDefinition.name];\n                                    const model = this.modelInstanceCreator(modelConstructor, item);\n                                    await this.storage.runExclusive(storage => this.modelMerger.merge(storage, model, modelDefinition));\n                                    observer.next({\n                                        type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED,\n                                        data: {\n                                            model: modelConstructor,\n                                            element: model,\n                                        },\n                                    });\n                                    observer.next({\n                                        type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                                        data: {\n                                            isEmpty: !hasMore,\n                                        },\n                                    });\n                                }, 'mutation processor event')));\n                                //#endregion\n                                //#region Merge subscriptions buffer\n                                subscriptions.push(dataSubsObservable.subscribe(([_transformerMutationType, modelDefinition, item]) => this.runningProcesses.add(async () => {\n                                    const modelConstructor = this.userModelClasses[modelDefinition.name];\n                                    const model = this.modelInstanceCreator(modelConstructor, item);\n                                    await this.storage.runExclusive(storage => this.modelMerger.merge(storage, model, modelDefinition));\n                                }, 'subscription dataSubsObservable event')));\n                                //#endregion\n                            }\n                            else if (!online) {\n                                this.online = online;\n                                observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                                    data: {\n                                        active: this.online,\n                                    },\n                                });\n                                subscriptions.forEach(sub => sub.unsubscribe());\n                                subscriptions = [];\n                            }\n                            doneStarting();\n                        }, 'datastore connectivity event'));\n                });\n                this.storage\n                    .observe(null, null, ownSymbol)\n                    .pipe(filter(({ model }) => {\n                    const modelDefinition = this.getModelDefinition(model);\n                    return modelDefinition.syncable === true;\n                }))\n                    .subscribe({\n                    next: async ({ opType, model, element, condition }) => this.runningProcesses.add(async () => {\n                        const namespace = this.schema.namespaces[this.namespaceResolver(model)];\n                        const MutationEventConstructor = this.modelClasses['MutationEvent'];\n                        const modelDefinition = this.getModelDefinition(model);\n                        const graphQLCondition = predicateToGraphQLCondition(condition, modelDefinition);\n                        const mutationEvent = createMutationInstanceFromModelOperation(namespace.relationships, this.getModelDefinition(model), opType, model, element, graphQLCondition, MutationEventConstructor, this.modelInstanceCreator);\n                        await this.outbox.enqueue(this.storage, mutationEvent);\n                        observer.next({\n                            type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED,\n                            data: {\n                                model,\n                                element,\n                            },\n                        });\n                        observer.next({\n                            type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                            data: {\n                                isEmpty: false,\n                            },\n                        });\n                        await startPromise;\n                        // Set by the this.datastoreConnectivity.status().subscribe() loop\n                        if (this.online) {\n                            this.mutationsProcessor.resume();\n                        }\n                    }, 'storage event'),\n                });\n                observer.next({\n                    type: ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED,\n                });\n                const hasMutationsInOutbox = (await this.outbox.peek(this.storage)) === undefined;\n                observer.next({\n                    type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                    data: {\n                        isEmpty: hasMutationsInOutbox,\n                    },\n                });\n                await startPromise;\n                observer.next({\n                    type: ControlMessage.SYNC_ENGINE_READY,\n                });\n            }, 'sync start');\n        });\n    }\n    async getModelsMetadataWithNextFullSync(currentTimeStamp) {\n        const modelLastSync = new Map((await this.runningProcesses.add(() => this.getModelsMetadata(), 'sync/index getModelsMetadataWithNextFullSync')).map(({ namespace, model, lastSync, lastFullSync, fullSyncInterval, lastSyncPredicate, }) => {\n            const nextFullSync = lastFullSync + fullSyncInterval;\n            const syncFrom = !lastFullSync || nextFullSync < currentTimeStamp\n                ? 0 // perform full sync if expired\n                : lastSync; // perform delta sync\n            return [\n                this.schema.namespaces[namespace].models[model],\n                [namespace, syncFrom],\n            ];\n        }));\n        return modelLastSync;\n    }\n    syncQueriesObservable() {\n        if (!this.online) {\n            return of({}); // TODO(v6): fix this\n        }\n        return new Observable(observer => {\n            let syncQueriesSubscription;\n            this.runningProcesses.isOpen &&\n                this.runningProcesses.add(async (onTerminate) => {\n                    let terminated = false;\n                    while (!observer.closed && !terminated) {\n                        const count = new WeakMap();\n                        const modelLastSync = await this.getModelsMetadataWithNextFullSync(Date.now());\n                        const paginatingModels = new Set(modelLastSync.keys());\n                        let lastFullSyncStartedAt;\n                        let syncInterval;\n                        let start;\n                        let syncDuration;\n                        let lastStartedAt;\n                        await new Promise((resolve, reject) => {\n                            if (!this.runningProcesses.isOpen)\n                                resolve();\n                            onTerminate.then(() => resolve());\n                            syncQueriesSubscription = this.syncQueriesProcessor\n                                .start(modelLastSync)\n                                .subscribe({\n                                next: async ({ namespace, modelDefinition, items, done, startedAt, isFullSync, }) => {\n                                    const modelConstructor = this.userModelClasses[modelDefinition.name];\n                                    if (!count.has(modelConstructor)) {\n                                        count.set(modelConstructor, {\n                                            new: 0,\n                                            updated: 0,\n                                            deleted: 0,\n                                        });\n                                        start = getNow();\n                                        lastStartedAt =\n                                            lastStartedAt === undefined\n                                                ? startedAt\n                                                : Math.max(lastStartedAt, startedAt);\n                                    }\n                                    /**\n                                     * If there are mutations in the outbox for a given id, those need to be\n                                     * merged individually. Otherwise, we can merge them in batches.\n                                     */\n                                    await this.storage.runExclusive(async (storage) => {\n                                        const idsInOutbox = await this.outbox.getModelIds(storage);\n                                        const oneByOne = [];\n                                        const page = items.filter(item => {\n                                            const itemId = getIdentifierValue(modelDefinition, item);\n                                            if (!idsInOutbox.has(itemId)) {\n                                                return true;\n                                            }\n                                            oneByOne.push(item);\n                                            return false;\n                                        });\n                                        const opTypeCount = [];\n                                        for (const item of oneByOne) {\n                                            const opType = await this.modelMerger.merge(storage, item, modelDefinition);\n                                            if (opType !== undefined) {\n                                                opTypeCount.push([item, opType]);\n                                            }\n                                        }\n                                        opTypeCount.push(...(await this.modelMerger.mergePage(storage, modelConstructor, page, modelDefinition)));\n                                        const counts = count.get(modelConstructor);\n                                        opTypeCount.forEach(([, opType]) => {\n                                            switch (opType) {\n                                                case OpType.INSERT:\n                                                    counts.new++;\n                                                    break;\n                                                case OpType.UPDATE:\n                                                    counts.updated++;\n                                                    break;\n                                                case OpType.DELETE:\n                                                    counts.deleted++;\n                                                    break;\n                                                default:\n                                                    throw new Error(`Invalid opType ${opType}`);\n                                            }\n                                        });\n                                    });\n                                    if (done) {\n                                        const { name: modelName } = modelDefinition;\n                                        //#region update last sync for type\n                                        let modelMetadata = await this.getModelMetadata(namespace, modelName);\n                                        const { lastFullSync, fullSyncInterval } = modelMetadata;\n                                        syncInterval = fullSyncInterval;\n                                        lastFullSyncStartedAt =\n                                            lastFullSyncStartedAt === undefined\n                                                ? lastFullSync\n                                                : Math.max(lastFullSyncStartedAt, isFullSync ? startedAt : lastFullSync);\n                                        modelMetadata = this.modelClasses\n                                            .ModelMetadata.copyOf(modelMetadata, draft => {\n                                            draft.lastSync = startedAt;\n                                            draft.lastFullSync = isFullSync\n                                                ? startedAt\n                                                : modelMetadata.lastFullSync;\n                                        });\n                                        await this.storage.save(modelMetadata, undefined, ownSymbol);\n                                        //#endregion\n                                        const counts = count.get(modelConstructor);\n                                        this.modelSyncedStatus.set(modelConstructor, true);\n                                        observer.next({\n                                            type: ControlMessage.SYNC_ENGINE_MODEL_SYNCED,\n                                            data: {\n                                                model: modelConstructor,\n                                                isFullSync,\n                                                isDeltaSync: !isFullSync,\n                                                counts,\n                                            },\n                                        });\n                                        paginatingModels.delete(modelDefinition);\n                                        if (paginatingModels.size === 0) {\n                                            syncDuration = getNow() - start;\n                                            resolve();\n                                            observer.next({\n                                                type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY,\n                                            });\n                                            syncQueriesSubscription.unsubscribe();\n                                        }\n                                    }\n                                },\n                                error: error => {\n                                    observer.error(error);\n                                },\n                            });\n                            observer.next({\n                                type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_STARTED,\n                                data: {\n                                    models: Array.from(paginatingModels).map(({ name }) => name),\n                                },\n                            });\n                        });\n                        // null is cast to 0 resulting in unexpected behavior.\n                        // undefined in arithmetic operations results in NaN also resulting in unexpected behavior.\n                        // If lastFullSyncStartedAt is null this is the first sync.\n                        // Assume lastStartedAt is is also newest full sync.\n                        let msNextFullSync;\n                        if (!lastFullSyncStartedAt) {\n                            msNextFullSync = syncInterval - syncDuration;\n                        }\n                        else {\n                            msNextFullSync =\n                                lastFullSyncStartedAt +\n                                    syncInterval -\n                                    (lastStartedAt + syncDuration);\n                        }\n                        logger.debug(`Next fullSync in ${msNextFullSync / 1000} seconds. (${new Date(Date.now() + msNextFullSync)})`);\n                        // TODO: create `BackgroundProcessManager.sleep()` ... but, need to put\n                        // a lot of thought into what that contract looks like to\n                        //  support possible use-cases:\n                        //\n                        //  1. non-cancelable\n                        //  2. cancelable, unsleep on exit()\n                        //  3. cancelable, throw Error on exit()\n                        //  4. cancelable, callback first on exit()?\n                        //  5. ... etc. ? ...\n                        //\n                        // TLDR; this is a lot of complexity here for a sleep(),\n                        // but, it's not clear to me yet how to support an\n                        // extensible, centralized cancelable `sleep()` elegantly.\n                        await this.runningProcesses.add(async (onTerminate) => {\n                            let sleepTimer;\n                            let unsleep;\n                            const sleep = new Promise(_unsleep => {\n                                unsleep = _unsleep;\n                                sleepTimer = setTimeout(unsleep, msNextFullSync);\n                            });\n                            onTerminate.then(() => {\n                                terminated = true;\n                                this.syncQueriesObservableStartSleeping();\n                                unsleep();\n                            });\n                            this.unsleepSyncQueriesObservable = unsleep;\n                            this.syncQueriesObservableStartSleeping();\n                            return sleep;\n                        }, 'syncQueriesObservable sleep');\n                        this.unsleepSyncQueriesObservable = null;\n                        this.waitForSleepState = new Promise(resolve => {\n                            this.syncQueriesObservableStartSleeping = resolve;\n                        });\n                    }\n                }, 'syncQueriesObservable main');\n        });\n    }\n    disconnectionHandler() {\n        return (msg) => {\n            // This implementation is tied to AWSAppSyncRealTimeProvider 'Connection closed', 'Timeout disconnect' msg\n            if (PUBSUB_CONTROL_MSG.CONNECTION_CLOSED === msg ||\n                PUBSUB_CONTROL_MSG.TIMEOUT_DISCONNECT === msg) {\n                this.datastoreConnectivity.socketDisconnected();\n            }\n        };\n    }\n    unsubscribeConnectivity() {\n        this.datastoreConnectivity.unsubscribe();\n    }\n    /**\n     * Stops all subscription activities and resolves when all activies report\n     * that they're disconnected, done retrying, etc..\n     */\n    async stop() {\n        logger.debug('stopping sync engine');\n        /**\n         * Gracefully disconnecting subscribers first just prevents *more* work\n         * from entering the pipelines.\n         */\n        this.unsubscribeConnectivity();\n        /**\n         * Stop listening for websocket connection disruption\n         */\n        this.stopDisruptionListener && this.stopDisruptionListener();\n        /**\n         * aggressively shut down any lingering background processes.\n         * some of this might be semi-redundant with unsubscribing. however,\n         * unsubscribing doesn't allow us to wait for settling.\n         * (Whereas `stop()` does.)\n         */\n        await this.mutationsProcessor.stop();\n        await this.subscriptionsProcessor.stop();\n        await this.datastoreConnectivity.stop();\n        await this.syncQueriesProcessor.stop();\n        await this.runningProcesses.close();\n        await this.runningProcesses.open();\n        logger.debug('sync engine stopped and ready to restart');\n    }\n    async setupModels(params) {\n        const { fullSyncInterval } = params;\n        const ModelMetadataConstructor = this.modelClasses\n            .ModelMetadata;\n        const models = [];\n        let savedModel;\n        Object.values(this.schema.namespaces).forEach(namespace => {\n            Object.values(namespace.models)\n                .filter(({ syncable }) => syncable)\n                .forEach(model => {\n                models.push([namespace.name, model]);\n                if (namespace.name === USER) {\n                    const modelConstructor = this.userModelClasses[model.name];\n                    this.modelSyncedStatus.set(modelConstructor, false);\n                }\n            });\n        });\n        const promises = models.map(async ([namespace, model]) => {\n            const modelMetadata = await this.getModelMetadata(namespace, model.name);\n            const syncPredicate = ModelPredicateCreator.getPredicates(this.syncPredicates.get(model), false);\n            const lastSyncPredicate = syncPredicate\n                ? JSON.stringify(syncPredicate)\n                : null;\n            if (modelMetadata === undefined) {\n                [[savedModel]] = await this.storage.save(this.modelInstanceCreator(ModelMetadataConstructor, {\n                    model: model.name,\n                    namespace,\n                    lastSync: null,\n                    fullSyncInterval,\n                    lastFullSync: null,\n                    lastSyncPredicate,\n                }), undefined, ownSymbol);\n            }\n            else {\n                const prevSyncPredicate = modelMetadata.lastSyncPredicate\n                    ? modelMetadata.lastSyncPredicate\n                    : null;\n                const syncPredicateUpdated = prevSyncPredicate !== lastSyncPredicate;\n                [[savedModel]] = await this.storage.save(ModelMetadataConstructor.copyOf(modelMetadata, draft => {\n                    draft.fullSyncInterval = fullSyncInterval;\n                    // perform a base sync if the syncPredicate changed in between calls to DataStore.start\n                    // ensures that the local store contains all the data specified by the syncExpression\n                    if (syncPredicateUpdated) {\n                        draft.lastSync = null;\n                        draft.lastFullSync = null;\n                        draft.lastSyncPredicate = lastSyncPredicate;\n                    }\n                }));\n            }\n            return savedModel;\n        });\n        const result = {};\n        for (const modelMetadata of await Promise.all(promises)) {\n            const { model: modelName } = modelMetadata;\n            result[modelName] = modelMetadata;\n        }\n        return result;\n    }\n    async getModelsMetadata() {\n        const ModelMetadata = this.modelClasses\n            .ModelMetadata;\n        const modelsMetadata = await this.storage.query(ModelMetadata);\n        return modelsMetadata;\n    }\n    async getModelMetadata(namespace, model) {\n        const ModelMetadata = this.modelClasses\n            .ModelMetadata;\n        const predicate = ModelPredicateCreator.createFromAST(this.schema.namespaces[SYNC].models[ModelMetadata.name], { and: [{ namespace: { eq: namespace } }, { model: { eq: model } }] });\n        const [modelMetadata] = await this.storage.query(ModelMetadata, predicate, {\n            page: 0,\n            limit: 1,\n        });\n        return modelMetadata;\n    }\n    getModelDefinition(modelConstructor) {\n        const namespaceName = this.namespaceResolver(modelConstructor);\n        const modelDefinition = this.schema.namespaces[namespaceName].models[modelConstructor.name];\n        return modelDefinition;\n    }\n    static getNamespace() {\n        const namespace = {\n            name: SYNC,\n            relationships: {},\n            enums: {\n                OperationType: {\n                    name: 'OperationType',\n                    values: ['CREATE', 'UPDATE', 'DELETE'],\n                },\n            },\n            nonModels: {},\n            models: {\n                MutationEvent: {\n                    name: 'MutationEvent',\n                    pluralName: 'MutationEvents',\n                    syncable: false,\n                    fields: {\n                        id: {\n                            name: 'id',\n                            type: 'ID',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        model: {\n                            name: 'model',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        data: {\n                            name: 'data',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        modelId: {\n                            name: 'modelId',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        operation: {\n                            name: 'operation',\n                            type: {\n                                enum: 'Operationtype',\n                            },\n                            isArray: false,\n                            isRequired: true,\n                        },\n                        condition: {\n                            name: 'condition',\n                            type: 'String',\n                            isArray: false,\n                            isRequired: true,\n                        },\n                    },\n                },\n                ModelMetadata: {\n                    name: 'ModelMetadata',\n                    pluralName: 'ModelsMetadata',\n                    syncable: false,\n                    fields: {\n                        id: {\n                            name: 'id',\n                            type: 'ID',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        namespace: {\n                            name: 'namespace',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        model: {\n                            name: 'model',\n                            type: 'String',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        lastSync: {\n                            name: 'lastSync',\n                            type: 'Int',\n                            isRequired: false,\n                            isArray: false,\n                        },\n                        lastFullSync: {\n                            name: 'lastFullSync',\n                            type: 'Int',\n                            isRequired: false,\n                            isArray: false,\n                        },\n                        fullSyncInterval: {\n                            name: 'fullSyncInterval',\n                            type: 'Int',\n                            isRequired: true,\n                            isArray: false,\n                        },\n                        lastSyncPredicate: {\n                            name: 'lastSyncPredicate',\n                            type: 'String',\n                            isRequired: false,\n                            isArray: false,\n                        },\n                    },\n                },\n            },\n        };\n        return namespace;\n    }\n    /**\n     * listen for websocket connection disruption\n     *\n     * May indicate there was a period of time where messages\n     * from AppSync were missed. A sync needs to be triggered to\n     * retrieve the missed data.\n     */\n    startDisruptionListener() {\n        return Hub.listen('api', (data) => {\n            if (data.source === 'PubSub' &&\n                data.payload.event === PUBSUB_CONNECTION_STATE_CHANGE) {\n                const connectionState = data.payload.data\n                    .connectionState;\n                switch (connectionState) {\n                    // Do not need to listen for ConnectionDisruptedPendingNetwork\n                    // Normal network reconnection logic will handle the sync\n                    case ConnectionState.ConnectionDisrupted:\n                        this.connectionDisrupted = true;\n                        break;\n                    case ConnectionState.Connected:\n                        if (this.connectionDisrupted) {\n                            this.scheduleSync();\n                        }\n                        this.connectionDisrupted = false;\n                        break;\n                }\n            }\n        });\n    }\n    /*\n     * Schedule a sync to start when syncQueriesObservable enters sleep state\n     * Start sync immediately if syncQueriesObservable is already in sleep state\n     */\n    scheduleSync() {\n        return (this.runningProcesses.isOpen &&\n            this.runningProcesses.add(() => this.waitForSleepState.then(() => {\n                // unsleepSyncQueriesObservable will be set if waitForSleepState has resolved\n                this.unsleepSyncQueriesObservable();\n            })));\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}