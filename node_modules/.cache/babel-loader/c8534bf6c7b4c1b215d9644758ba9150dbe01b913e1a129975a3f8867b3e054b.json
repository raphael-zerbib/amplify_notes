{"ast":null,"code":"import { OpType, QueryOne } from '../../types.mjs';\nimport { monotonicUlidFactory, indexNameFromKeys, DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR } from '../../util.mjs';\nimport { createInMemoryStore } from './InMemoryStore.mjs';\nconst DB_NAME = '@AmplifyDatastore';\nconst COLLECTION = 'Collection';\nconst DATA = 'Data';\nconst monotonicFactoriesMap = new Map();\nclass AsyncStorageDatabase {\n  constructor() {\n    /**\n     * Maps storeNames to a map of ulid->id\n     */\n    this._collectionInMemoryIndex = new Map();\n    this.storage = createInMemoryStore();\n  }\n  /**\n   * Collection index is map of stores (i.e. sync, metadata, mutation event, and data)\n   * @param storeName {string} - Name of the store\n   * @returns Map of ulid->id\n   */\n  getCollectionIndex(storeName) {\n    if (!this._collectionInMemoryIndex.has(storeName)) {\n      this._collectionInMemoryIndex.set(storeName, new Map());\n    }\n    return this._collectionInMemoryIndex.get(storeName);\n  }\n  /**\n   * Return ULID for store if it exists, otherwise create a new one\n   * @param storeName {string} - Name of the store\n   * @returns ulid\n   */\n  getMonotonicFactory(storeName) {\n    if (!monotonicFactoriesMap.has(storeName)) {\n      monotonicFactoriesMap.set(storeName, monotonicUlidFactory());\n    }\n    return monotonicFactoriesMap.get(storeName);\n  }\n  async init() {\n    this._collectionInMemoryIndex.clear();\n    const allKeys = await this.storage.getAllKeys();\n    const keysForCollectionEntries = [];\n    for (const key of allKeys) {\n      const [dbName, storeName, recordType, ulidOrId, id] = key.split('::');\n      if (dbName === DB_NAME) {\n        if (recordType === DATA) {\n          let ulid;\n          if (id === undefined) {\n            // It is an old entry (without ulid). Need to migrate to new key format\n            const id = ulidOrId;\n            const newUlid = this.getMonotonicFactory(storeName)();\n            const oldKey = this.getLegacyKeyForItem(storeName, id);\n            const newKey = this.getKeyForItem(storeName, id, newUlid);\n            const item = await this.storage.getItem(oldKey);\n            await this.storage.setItem(newKey, item);\n            await this.storage.removeItem(oldKey);\n            ulid = newUlid;\n          } else {\n            ulid = ulidOrId;\n          }\n          this.getCollectionIndex(storeName).set(id, ulid);\n        } else if (recordType === COLLECTION) {\n          keysForCollectionEntries.push(key);\n        }\n      }\n    }\n    if (keysForCollectionEntries.length > 0) {\n      await this.storage.multiRemove(keysForCollectionEntries);\n    }\n  }\n  async save(item, storeName, keys, keyValuesPath) {\n    var _this$getCollectionIn, _this$getCollectionIn2;\n    const idxName = indexNameFromKeys(keys);\n    const ulid = ((_this$getCollectionIn = this.getCollectionIndex(storeName)) === null || _this$getCollectionIn === void 0 ? void 0 : _this$getCollectionIn.get(idxName)) || this.getMonotonicFactory(storeName)();\n    // Retrieve db key for item\n    const itemKey = this.getKeyForItem(storeName, keyValuesPath, ulid);\n    // Set key in collection index\n    (_this$getCollectionIn2 = this.getCollectionIndex(storeName)) === null || _this$getCollectionIn2 === void 0 || _this$getCollectionIn2.set(keyValuesPath, ulid);\n    // Save item in db\n    await this.storage.setItem(itemKey, JSON.stringify(item));\n  }\n  async batchSave(storeName, items, keys) {\n    if (items.length === 0) {\n      return [];\n    }\n    const result = [];\n    const collection = this.getCollectionIndex(storeName);\n    const keysToDelete = new Set();\n    const keysToSave = new Set();\n    const allItemsKeys = [];\n    const itemsMap = {};\n    /* Populate allItemKeys, keysToDelete, and keysToSave */\n    for (const item of items) {\n      // Extract keys from concatenated key path, map to item values\n      const keyValues = keys.map(field => item[field]);\n      const {\n        _deleted\n      } = item;\n      // If id is in the store, retrieve, otherwise generate new ULID\n      const ulid = collection.get(keyValues.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR)) || this.getMonotonicFactory(storeName)();\n      // Generate the \"longer key\" for the item\n      const key = this.getKeyForItem(storeName, keyValues.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR), ulid);\n      allItemsKeys.push(key);\n      itemsMap[key] = {\n        ulid,\n        model: item\n      };\n      if (_deleted) {\n        keysToDelete.add(key);\n      } else {\n        keysToSave.add(key);\n      }\n    }\n    const existingRecordsMap = await this.storage.multiGet(allItemsKeys);\n    const existingRecordsKeys = existingRecordsMap.filter(_ref => {\n      let [, v] = _ref;\n      return !!v;\n    }).reduce((set, _ref2) => {\n      let [k] = _ref2;\n      return set.add(k);\n    }, new Set());\n    // Delete\n    await new Promise((resolve, reject) => {\n      if (keysToDelete.size === 0) {\n        resolve();\n        return;\n      }\n      const keysToDeleteArray = Array.from(keysToDelete);\n      keysToDeleteArray.forEach(key => {\n        // key: full db key\n        // keys: PK and/or SK keys\n        const primaryKeyValues = keys.map(field => itemsMap[key].model[field]).join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n        collection.delete(primaryKeyValues);\n      });\n      this.storage.multiRemove(keysToDeleteArray, errors => {\n        if (errors && errors.length > 0) {\n          reject(errors);\n        } else {\n          resolve();\n        }\n      });\n    });\n    // Save\n    await new Promise((resolve, reject) => {\n      if (keysToSave.size === 0) {\n        resolve();\n        return;\n      }\n      const entriesToSet = Array.from(keysToSave).map(key => [key, JSON.stringify(itemsMap[key].model)]);\n      keysToSave.forEach(key => {\n        const {\n          model,\n          ulid\n        } = itemsMap[key];\n        // Retrieve values from model, use as key for collection index\n        const keyValues = keys.map(field => model[field]).join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n        collection.set(keyValues, ulid);\n      });\n      this.storage.multiSet(entriesToSet, errors => {\n        if (errors && errors.length > 0) {\n          reject(errors);\n        } else {\n          resolve();\n        }\n      });\n    });\n    for (const key of allItemsKeys) {\n      if (keysToDelete.has(key) && existingRecordsKeys.has(key)) {\n        result.push([itemsMap[key].model, OpType.DELETE]);\n      } else if (keysToSave.has(key)) {\n        result.push([itemsMap[key].model, existingRecordsKeys.has(key) ? OpType.UPDATE : OpType.INSERT]);\n      }\n    }\n    return result;\n  }\n  async get(keyValuePath, storeName) {\n    const ulid = this.getCollectionIndex(storeName).get(keyValuePath);\n    const itemKey = this.getKeyForItem(storeName, keyValuePath, ulid);\n    const recordAsString = await this.storage.getItem(itemKey);\n    const record = recordAsString && JSON.parse(recordAsString);\n    return record;\n  }\n  async getOne(firstOrLast, storeName) {\n    const collection = this.getCollectionIndex(storeName);\n    const [itemId, ulid] = firstOrLast === QueryOne.FIRST ? (() => {\n      let id, ulid;\n      for ([id, ulid] of collection) break; // Get first element of the set\n      return [id, ulid];\n    })() : (() => {\n      let id, ulid;\n      for ([id, ulid] of collection); // Get last element of the set\n      return [id, ulid];\n    })();\n    const itemKey = this.getKeyForItem(storeName, itemId, ulid);\n    const itemString = itemKey && (await this.storage.getItem(itemKey));\n    const result = itemString ? JSON.parse(itemString) || undefined : undefined;\n    return result;\n  }\n  /**\n   * This function gets all the records stored in async storage for a particular storeName\n   * It then loads all the records for that filtered set of keys using multiGet()\n   */\n  async getAll(storeName, pagination) {\n    const collection = this.getCollectionIndex(storeName);\n    const {\n      page = 0,\n      limit = 0\n    } = pagination || {};\n    const start = Math.max(0, page * limit) || 0;\n    const end = limit > 0 ? start + limit : undefined;\n    const keysForStore = [];\n    let count = 0;\n    for (const [id, ulid] of collection) {\n      count++;\n      if (count <= start) {\n        continue;\n      }\n      keysForStore.push(this.getKeyForItem(storeName, id, ulid));\n      if (count === end) {\n        break;\n      }\n    }\n    const storeRecordStrings = await this.storage.multiGet(keysForStore);\n    const records = storeRecordStrings.filter(_ref3 => {\n      let [, value] = _ref3;\n      return value;\n    }).map(_ref4 => {\n      let [, value] = _ref4;\n      return JSON.parse(value);\n    });\n    return records;\n  }\n  async delete(key, storeName) {\n    const ulid = this.getCollectionIndex(storeName).get(key);\n    const itemKey = this.getKeyForItem(storeName, key, ulid);\n    this.getCollectionIndex(storeName).delete(key);\n    await this.storage.removeItem(itemKey);\n  }\n  /**\n   * Clear the AsyncStorage of all DataStore entries\n   */\n  async clear() {\n    const allKeys = await this.storage.getAllKeys();\n    const allDataStoreKeys = allKeys.filter(key => key.startsWith(DB_NAME));\n    await this.storage.multiRemove(allDataStoreKeys);\n    this._collectionInMemoryIndex.clear();\n  }\n  getKeyForItem(storeName, id, ulid) {\n    return \"\".concat(this.getKeyPrefixForStoreItems(storeName), \"::\").concat(ulid, \"::\").concat(id);\n  }\n  getLegacyKeyForItem(storeName, id) {\n    return \"\".concat(this.getKeyPrefixForStoreItems(storeName), \"::\").concat(id);\n  }\n  getKeyPrefixForStoreItems(storeName) {\n    return \"\".concat(DB_NAME, \"::\").concat(storeName, \"::\").concat(DATA);\n  }\n}\nexport { AsyncStorageDatabase as default };","map":{"version":3,"names":["DB_NAME","COLLECTION","DATA","monotonicFactoriesMap","Map","AsyncStorageDatabase","constructor","_collectionInMemoryIndex","storage","createInMemoryStore","getCollectionIndex","storeName","has","set","get","getMonotonicFactory","monotonicUlidFactory","init","clear","allKeys","getAllKeys","keysForCollectionEntries","key","dbName","recordType","ulidOrId","id","split","ulid","undefined","newUlid","oldKey","getLegacyKeyForItem","newKey","getKeyForItem","item","getItem","setItem","removeItem","push","length","multiRemove","save","keys","keyValuesPath","_this$getCollectionIn","_this$getCollectionIn2","idxName","indexNameFromKeys","itemKey","JSON","stringify","batchSave","items","result","collection","keysToDelete","Set","keysToSave","allItemsKeys","itemsMap","keyValues","map","field","_deleted","join","DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR","model","add","existingRecordsMap","multiGet","existingRecordsKeys","filter","_ref","v","reduce","_ref2","k","Promise","resolve","reject","size","keysToDeleteArray","Array","from","forEach","primaryKeyValues","delete","errors","entriesToSet","multiSet","OpType","DELETE","UPDATE","INSERT","keyValuePath","recordAsString","record","parse","getOne","firstOrLast","itemId","QueryOne","FIRST","itemString","getAll","pagination","page","limit","start","Math","max","end","keysForStore","count","storeRecordStrings","records","_ref3","value","_ref4","allDataStoreKeys","startsWith","concat","getKeyPrefixForStoreItems"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/storage/adapter/AsyncStorageDatabase.ts"],"sourcesContent":["import { OpType, QueryOne, } from '../../types';\nimport { DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR, indexNameFromKeys, monotonicUlidFactory, } from '../../util';\nimport { createInMemoryStore } from './InMemoryStore';\nconst DB_NAME = '@AmplifyDatastore';\nconst COLLECTION = 'Collection';\nconst DATA = 'Data';\nconst monotonicFactoriesMap = new Map();\nclass AsyncStorageDatabase {\n    constructor() {\n        /**\n         * Maps storeNames to a map of ulid->id\n         */\n        this._collectionInMemoryIndex = new Map();\n        this.storage = createInMemoryStore();\n    }\n    /**\n     * Collection index is map of stores (i.e. sync, metadata, mutation event, and data)\n     * @param storeName {string} - Name of the store\n     * @returns Map of ulid->id\n     */\n    getCollectionIndex(storeName) {\n        if (!this._collectionInMemoryIndex.has(storeName)) {\n            this._collectionInMemoryIndex.set(storeName, new Map());\n        }\n        return this._collectionInMemoryIndex.get(storeName);\n    }\n    /**\n     * Return ULID for store if it exists, otherwise create a new one\n     * @param storeName {string} - Name of the store\n     * @returns ulid\n     */\n    getMonotonicFactory(storeName) {\n        if (!monotonicFactoriesMap.has(storeName)) {\n            monotonicFactoriesMap.set(storeName, monotonicUlidFactory());\n        }\n        return monotonicFactoriesMap.get(storeName);\n    }\n    async init() {\n        this._collectionInMemoryIndex.clear();\n        const allKeys = await this.storage.getAllKeys();\n        const keysForCollectionEntries = [];\n        for (const key of allKeys) {\n            const [dbName, storeName, recordType, ulidOrId, id] = key.split('::');\n            if (dbName === DB_NAME) {\n                if (recordType === DATA) {\n                    let ulid;\n                    if (id === undefined) {\n                        // It is an old entry (without ulid). Need to migrate to new key format\n                        const id = ulidOrId;\n                        const newUlid = this.getMonotonicFactory(storeName)();\n                        const oldKey = this.getLegacyKeyForItem(storeName, id);\n                        const newKey = this.getKeyForItem(storeName, id, newUlid);\n                        const item = await this.storage.getItem(oldKey);\n                        await this.storage.setItem(newKey, item);\n                        await this.storage.removeItem(oldKey);\n                        ulid = newUlid;\n                    }\n                    else {\n                        ulid = ulidOrId;\n                    }\n                    this.getCollectionIndex(storeName).set(id, ulid);\n                }\n                else if (recordType === COLLECTION) {\n                    keysForCollectionEntries.push(key);\n                }\n            }\n        }\n        if (keysForCollectionEntries.length > 0) {\n            await this.storage.multiRemove(keysForCollectionEntries);\n        }\n    }\n    async save(item, storeName, keys, keyValuesPath) {\n        const idxName = indexNameFromKeys(keys);\n        const ulid = this.getCollectionIndex(storeName)?.get(idxName) ||\n            this.getMonotonicFactory(storeName)();\n        // Retrieve db key for item\n        const itemKey = this.getKeyForItem(storeName, keyValuesPath, ulid);\n        // Set key in collection index\n        this.getCollectionIndex(storeName)?.set(keyValuesPath, ulid);\n        // Save item in db\n        await this.storage.setItem(itemKey, JSON.stringify(item));\n    }\n    async batchSave(storeName, items, keys) {\n        if (items.length === 0) {\n            return [];\n        }\n        const result = [];\n        const collection = this.getCollectionIndex(storeName);\n        const keysToDelete = new Set();\n        const keysToSave = new Set();\n        const allItemsKeys = [];\n        const itemsMap = {};\n        /* Populate allItemKeys, keysToDelete, and keysToSave */\n        for (const item of items) {\n            // Extract keys from concatenated key path, map to item values\n            const keyValues = keys.map(field => item[field]);\n            const { _deleted } = item;\n            // If id is in the store, retrieve, otherwise generate new ULID\n            const ulid = collection.get(keyValues.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR)) ||\n                this.getMonotonicFactory(storeName)();\n            // Generate the \"longer key\" for the item\n            const key = this.getKeyForItem(storeName, keyValues.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR), ulid);\n            allItemsKeys.push(key);\n            itemsMap[key] = { ulid, model: item };\n            if (_deleted) {\n                keysToDelete.add(key);\n            }\n            else {\n                keysToSave.add(key);\n            }\n        }\n        const existingRecordsMap = await this.storage.multiGet(allItemsKeys);\n        const existingRecordsKeys = existingRecordsMap\n            .filter(([, v]) => !!v)\n            .reduce((set, [k]) => set.add(k), new Set());\n        // Delete\n        await new Promise((resolve, reject) => {\n            if (keysToDelete.size === 0) {\n                resolve();\n                return;\n            }\n            const keysToDeleteArray = Array.from(keysToDelete);\n            keysToDeleteArray.forEach(key => {\n                // key: full db key\n                // keys: PK and/or SK keys\n                const primaryKeyValues = keys\n                    .map(field => itemsMap[key].model[field])\n                    .join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n                collection.delete(primaryKeyValues);\n            });\n            this.storage.multiRemove(keysToDeleteArray, (errors) => {\n                if (errors && errors.length > 0) {\n                    reject(errors);\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n        // Save\n        await new Promise((resolve, reject) => {\n            if (keysToSave.size === 0) {\n                resolve();\n                return;\n            }\n            const entriesToSet = Array.from(keysToSave).map(key => [\n                key,\n                JSON.stringify(itemsMap[key].model),\n            ]);\n            keysToSave.forEach(key => {\n                const { model, ulid } = itemsMap[key];\n                // Retrieve values from model, use as key for collection index\n                const keyValues = keys\n                    .map(field => model[field])\n                    .join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n                collection.set(keyValues, ulid);\n            });\n            this.storage.multiSet(entriesToSet, (errors) => {\n                if (errors && errors.length > 0) {\n                    reject(errors);\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n        for (const key of allItemsKeys) {\n            if (keysToDelete.has(key) && existingRecordsKeys.has(key)) {\n                result.push([itemsMap[key].model, OpType.DELETE]);\n            }\n            else if (keysToSave.has(key)) {\n                result.push([\n                    itemsMap[key].model,\n                    existingRecordsKeys.has(key) ? OpType.UPDATE : OpType.INSERT,\n                ]);\n            }\n        }\n        return result;\n    }\n    async get(keyValuePath, storeName) {\n        const ulid = this.getCollectionIndex(storeName).get(keyValuePath);\n        const itemKey = this.getKeyForItem(storeName, keyValuePath, ulid);\n        const recordAsString = await this.storage.getItem(itemKey);\n        const record = recordAsString && JSON.parse(recordAsString);\n        return record;\n    }\n    async getOne(firstOrLast, storeName) {\n        const collection = this.getCollectionIndex(storeName);\n        const [itemId, ulid] = firstOrLast === QueryOne.FIRST\n            ? (() => {\n                let id, ulid;\n                for ([id, ulid] of collection)\n                    break; // Get first element of the set\n                return [id, ulid];\n            })()\n            : (() => {\n                let id, ulid;\n                for ([id, ulid] of collection)\n                    ; // Get last element of the set\n                return [id, ulid];\n            })();\n        const itemKey = this.getKeyForItem(storeName, itemId, ulid);\n        const itemString = itemKey && (await this.storage.getItem(itemKey));\n        const result = itemString ? JSON.parse(itemString) || undefined : undefined;\n        return result;\n    }\n    /**\n     * This function gets all the records stored in async storage for a particular storeName\n     * It then loads all the records for that filtered set of keys using multiGet()\n     */\n    async getAll(storeName, pagination) {\n        const collection = this.getCollectionIndex(storeName);\n        const { page = 0, limit = 0 } = pagination || {};\n        const start = Math.max(0, page * limit) || 0;\n        const end = limit > 0 ? start + limit : undefined;\n        const keysForStore = [];\n        let count = 0;\n        for (const [id, ulid] of collection) {\n            count++;\n            if (count <= start) {\n                continue;\n            }\n            keysForStore.push(this.getKeyForItem(storeName, id, ulid));\n            if (count === end) {\n                break;\n            }\n        }\n        const storeRecordStrings = await this.storage.multiGet(keysForStore);\n        const records = storeRecordStrings\n            .filter(([, value]) => value)\n            .map(([, value]) => JSON.parse(value));\n        return records;\n    }\n    async delete(key, storeName) {\n        const ulid = this.getCollectionIndex(storeName).get(key);\n        const itemKey = this.getKeyForItem(storeName, key, ulid);\n        this.getCollectionIndex(storeName).delete(key);\n        await this.storage.removeItem(itemKey);\n    }\n    /**\n     * Clear the AsyncStorage of all DataStore entries\n     */\n    async clear() {\n        const allKeys = await this.storage.getAllKeys();\n        const allDataStoreKeys = allKeys.filter(key => key.startsWith(DB_NAME));\n        await this.storage.multiRemove(allDataStoreKeys);\n        this._collectionInMemoryIndex.clear();\n    }\n    getKeyForItem(storeName, id, ulid) {\n        return `${this.getKeyPrefixForStoreItems(storeName)}::${ulid}::${id}`;\n    }\n    getLegacyKeyForItem(storeName, id) {\n        return `${this.getKeyPrefixForStoreItems(storeName)}::${id}`;\n    }\n    getKeyPrefixForStoreItems(storeName) {\n        return `${DB_NAME}::${storeName}::${DATA}`;\n    }\n}\nexport default AsyncStorageDatabase;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}