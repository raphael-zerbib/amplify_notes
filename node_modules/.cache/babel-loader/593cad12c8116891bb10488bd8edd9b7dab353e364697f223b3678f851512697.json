{"ast":null,"code":"import { Subject, filter, map } from 'rxjs';\nimport { ModelPredicateCreator } from '../predicates/index.mjs';\nimport { QueryOne, OpType, isTargetNameAssociation } from '../types.mjs';\nimport { isModelConstructor, validatePredicate, valuesEqual, STORAGE } from '../util.mjs';\nimport { getIdentifierValue } from '../sync/utils.mjs';\nimport getDefaultAdapter from './adapter/getDefaultAdapter/index.mjs';\nimport { Mutex } from '@aws-amplify/core/internals/utils';\nimport { ConsoleLogger } from '@aws-amplify/core';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('DataStore');\nclass StorageClass {\n  constructor(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, adapter, sessionId) {\n    this.schema = schema;\n    this.namespaceResolver = namespaceResolver;\n    this.getModelConstructorByModelName = getModelConstructorByModelName;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.adapter = adapter;\n    this.sessionId = sessionId;\n    this.adapter = this.adapter || getDefaultAdapter();\n    this.pushStream = new Subject();\n  }\n  static getNamespace() {\n    const namespace = {\n      name: STORAGE,\n      relationships: {},\n      enums: {},\n      models: {},\n      nonModels: {}\n    };\n    return namespace;\n  }\n  async init() {\n    if (this.initialized !== undefined) {\n      await this.initialized;\n      return;\n    }\n    logger.debug('Starting Storage');\n    let resolve;\n    let reject;\n    this.initialized = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    this.adapter.setUp(this.schema, this.namespaceResolver, this.modelInstanceCreator, this.getModelConstructorByModelName, this.sessionId).then(resolve, reject);\n    await this.initialized;\n  }\n  async save(model, condition, mutator, patchesTuple) {\n    await this.init();\n    if (!this.adapter) {\n      throw new Error('Storage adapter is missing');\n    }\n    const result = await this.adapter.save(model, condition);\n    result.forEach(r => {\n      const [savedElement, opType] = r;\n      // truthy when save is called by the Merger\n      const syncResponse = !!mutator;\n      let updateMutationInput;\n      // don't attempt to calc mutation input when storage.save\n      // is called by Merger, i.e., when processing an AppSync response\n      if ((opType === OpType.UPDATE || opType === OpType.INSERT) && !syncResponse) {\n        //\n        // TODO: LOOK!!!\n        // the `model` used here is in effect regardless of what model\n        // comes back from adapter.save().\n        // Prior to fix, SQLite adapter had been returning two models\n        // of different types, resulting in invalid outbox entries.\n        //\n        // the bug is essentially fixed in SQLite adapter.\n        // leaving as-is, because it's currently unclear whether anything\n        // depends on this remaining as-is.\n        //\n        updateMutationInput = this.getChangedFieldsInput(model, savedElement, patchesTuple);\n        // // an update without changed user fields\n        // => don't create mutationEvent\n        if (updateMutationInput === null) {\n          return result;\n        }\n      }\n      const element = updateMutationInput || savedElement;\n      const modelConstructor = Object.getPrototypeOf(savedElement).constructor;\n      this.pushStream.next({\n        model: modelConstructor,\n        opType,\n        element,\n        mutator,\n        condition: condition && ModelPredicateCreator.getPredicates(condition, false) || null,\n        savedElement\n      });\n    });\n    return result;\n  }\n  async delete(modelOrModelConstructor, condition, mutator) {\n    await this.init();\n    if (!this.adapter) {\n      throw new Error('Storage adapter is missing');\n    }\n    let models;\n    let deleted;\n    [models, deleted] = await this.adapter.delete(modelOrModelConstructor, condition);\n    const modelConstructor = isModelConstructor(modelOrModelConstructor) ? modelOrModelConstructor : Object.getPrototypeOf(modelOrModelConstructor || {}).constructor;\n    const namespaceName = this.namespaceResolver(modelConstructor);\n    const modelDefinition = this.schema.namespaces[namespaceName].models[modelConstructor.name];\n    const modelIds = new Set(models.map(model => {\n      const modelId = getIdentifierValue(modelDefinition, model);\n      return modelId;\n    }));\n    if (!isModelConstructor(modelOrModelConstructor) && !Array.isArray(deleted)) {\n      deleted = [deleted];\n    }\n    deleted.forEach(model => {\n      const modelConstructor = Object.getPrototypeOf(model).constructor;\n      let theCondition;\n      if (!isModelConstructor(modelOrModelConstructor)) {\n        const modelId = getIdentifierValue(modelDefinition, model);\n        theCondition = modelIds.has(modelId) ? ModelPredicateCreator.getPredicates(condition, false) : undefined;\n      }\n      this.pushStream.next({\n        model: modelConstructor,\n        opType: OpType.DELETE,\n        element: model,\n        mutator,\n        condition: theCondition || null\n      });\n    });\n    return [models, deleted];\n  }\n  async query(modelConstructor, predicate, pagination) {\n    await this.init();\n    if (!this.adapter) {\n      throw new Error('Storage adapter is missing');\n    }\n    return await this.adapter.query(modelConstructor, predicate, pagination);\n  }\n  async queryOne(modelConstructor, firstOrLast = QueryOne.FIRST) {\n    await this.init();\n    if (!this.adapter) {\n      throw new Error('Storage adapter is missing');\n    }\n    return await this.adapter.queryOne(modelConstructor, firstOrLast);\n  }\n  observe(modelConstructor, predicate, skipOwn) {\n    const listenToAll = !modelConstructor;\n    const {\n      predicates,\n      type\n    } = predicate && ModelPredicateCreator.getPredicates(predicate, false) || {};\n    let result = this.pushStream.pipe(filter(({\n      mutator\n    }) => {\n      return !skipOwn || mutator !== skipOwn;\n    })).pipe(map(({\n      mutator: _mutator,\n      ...message\n    }) => message));\n    if (!listenToAll) {\n      result = result.pipe(filter(({\n        model,\n        element\n      }) => {\n        if (modelConstructor !== model) {\n          return false;\n        }\n        if (!!predicates && !!type) {\n          return validatePredicate(element, type, predicates);\n        }\n        return true;\n      }));\n    }\n    return result;\n  }\n  async clear(completeObservable = true) {\n    this.initialized = undefined;\n    if (!this.adapter) {\n      throw new Error('Storage adapter is missing');\n    }\n    await this.adapter.clear();\n    if (completeObservable) {\n      this.pushStream.complete();\n    }\n  }\n  async batchSave(modelConstructor, items, mutator) {\n    await this.init();\n    if (!this.adapter) {\n      throw new Error('Storage adapter is missing');\n    }\n    const result = await this.adapter.batchSave(modelConstructor, items);\n    result.forEach(([element, opType]) => {\n      this.pushStream.next({\n        model: modelConstructor,\n        opType,\n        element,\n        mutator,\n        condition: null\n      });\n    });\n    return result;\n  }\n  // returns null if no user fields were changed (determined by value comparison)\n  getChangedFieldsInput(model, originalElement, patchesTuple) {\n    const containsPatches = patchesTuple && patchesTuple.length;\n    if (!containsPatches) {\n      return null;\n    }\n    const [patches, source] = patchesTuple;\n    const updatedElement = {};\n    // extract array of updated fields from patches\n    const updatedFields = patches.map(patch => patch.path && patch.path[0]);\n    // check model def for association and replace with targetName if exists\n    const modelConstructor = Object.getPrototypeOf(model).constructor;\n    const namespace = this.namespaceResolver(modelConstructor);\n    const {\n      fields\n    } = this.schema.namespaces[namespace].models[modelConstructor.name];\n    const {\n      primaryKey,\n      compositeKeys = []\n    } = this.schema.namespaces[namespace].keys?.[modelConstructor.name] || {};\n    // set original values for these fields\n    updatedFields.forEach(field => {\n      const targetNames = isTargetNameAssociation(fields[field]?.association);\n      if (Array.isArray(targetNames)) {\n        // if field refers to a belongsTo relation, use the target field instead\n        for (const targetName of targetNames) {\n          // check field values by value. Ignore unchanged fields\n          if (!valuesEqual(source[targetName], originalElement[targetName])) {\n            // if the field was updated to 'undefined', replace with 'null' for compatibility with JSON and GraphQL\n            updatedElement[targetName] = originalElement[targetName] === undefined ? null : originalElement[targetName];\n            for (const fieldSet of compositeKeys) {\n              // include all of the fields that comprise the composite key\n              if (fieldSet.has(targetName)) {\n                for (const compositeField of fieldSet) {\n                  updatedElement[compositeField] = originalElement[compositeField];\n                }\n              }\n            }\n          }\n        }\n      } else {\n        // Backwards compatibility pre-CPK\n        // if field refers to a belongsTo relation, use the target field instead\n        const key = targetNames || field;\n        // check field values by value. Ignore unchanged fields\n        if (!valuesEqual(source[key], originalElement[key])) {\n          // if the field was updated to 'undefined', replace with 'null' for compatibility with JSON and GraphQL\n          updatedElement[key] = originalElement[key] === undefined ? null : originalElement[key];\n          for (const fieldSet of compositeKeys) {\n            // include all of the fields that comprise the composite key\n            if (fieldSet.has(key)) {\n              for (const compositeField of fieldSet) {\n                updatedElement[compositeField] = originalElement[compositeField];\n              }\n            }\n          }\n        }\n      }\n    });\n    // Exit early when there are no changes introduced in the update mutation\n    if (Object.keys(updatedElement).length === 0) {\n      return null;\n    }\n    // include field(s) from custom PK if one is specified for the model\n    if (primaryKey && primaryKey.length) {\n      for (const pkField of primaryKey) {\n        updatedElement[pkField] = originalElement[pkField];\n      }\n    }\n    const {\n      id,\n      _version,\n      _lastChangedAt,\n      _deleted\n    } = originalElement;\n    // For update mutations we only want to send fields with changes\n    // and the required internal fields\n    return {\n      ...updatedElement,\n      id,\n      _version,\n      _lastChangedAt,\n      _deleted\n    };\n  }\n}\nclass ExclusiveStorage {\n  constructor(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, adapter, sessionId) {\n    this.mutex = new Mutex();\n    this.storage = new StorageClass(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, adapter, sessionId);\n  }\n  runExclusive(fn) {\n    return this.mutex.runExclusive(fn.bind(this, this.storage));\n  }\n  async save(model, condition, mutator, patchesTuple) {\n    return this.runExclusive(storage => storage.save(model, condition, mutator, patchesTuple));\n  }\n  async delete(modelOrModelConstructor, condition, mutator) {\n    return this.runExclusive(storage => {\n      if (isModelConstructor(modelOrModelConstructor)) {\n        const modelConstructor = modelOrModelConstructor;\n        return storage.delete(modelConstructor, condition, mutator);\n      } else {\n        const model = modelOrModelConstructor;\n        return storage.delete(model, condition, mutator);\n      }\n    });\n  }\n  async query(modelConstructor, predicate, pagination) {\n    return this.runExclusive(storage => storage.query(modelConstructor, predicate, pagination));\n  }\n  async queryOne(modelConstructor, firstOrLast = QueryOne.FIRST) {\n    return this.runExclusive(storage => storage.queryOne(modelConstructor, firstOrLast));\n  }\n  static getNamespace() {\n    return StorageClass.getNamespace();\n  }\n  observe(modelConstructor, predicate, skipOwn) {\n    return this.storage.observe(modelConstructor, predicate, skipOwn);\n  }\n  async clear() {\n    await this.runExclusive(storage => storage.clear());\n  }\n  batchSave(modelConstructor, items) {\n    return this.storage.batchSave(modelConstructor, items);\n  }\n  async init() {\n    return this.storage.init();\n  }\n}\nexport { ExclusiveStorage };","map":{"version":3,"names":["logger","ConsoleLogger","StorageClass","constructor","schema","namespaceResolver","getModelConstructorByModelName","modelInstanceCreator","adapter","sessionId","getDefaultAdapter","pushStream","Subject","getNamespace","namespace","name","STORAGE","relationships","enums","models","nonModels","init","initialized","undefined","debug","resolve","reject","Promise","res","rej","setUp","then","save","model","condition","mutator","patchesTuple","Error","result","forEach","r","savedElement","opType","syncResponse","updateMutationInput","OpType","UPDATE","INSERT","getChangedFieldsInput","element","modelConstructor","Object","getPrototypeOf","next","ModelPredicateCreator","getPredicates","delete","modelOrModelConstructor","deleted","isModelConstructor","namespaceName","modelDefinition","namespaces","modelIds","Set","map","modelId","getIdentifierValue","Array","isArray","theCondition","has","DELETE","query","predicate","pagination","queryOne","firstOrLast","QueryOne","FIRST","observe","skipOwn","listenToAll","predicates","type","pipe","filter","_mutator","message","validatePredicate","clear","completeObservable","complete","batchSave","items","originalElement","containsPatches","length","patches","source","updatedElement","updatedFields","patch","path","fields","primaryKey","compositeKeys","keys","field","targetNames","isTargetNameAssociation","association","targetName","valuesEqual","fieldSet","compositeField","key","pkField","id","_version","_lastChangedAt","_deleted","ExclusiveStorage","mutex","Mutex","storage","runExclusive","fn","bind"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/storage/storage.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { filter, map, Subject } from 'rxjs';\nimport { ModelPredicateCreator } from '../predicates';\nimport { OpType, QueryOne, isTargetNameAssociation, } from '../types';\nimport { isModelConstructor, STORAGE, validatePredicate, valuesEqual, } from '../util';\nimport { getIdentifierValue } from '../sync/utils';\nimport getDefaultAdapter from './adapter/getDefaultAdapter';\nimport { Mutex } from '@aws-amplify/core/internals/utils';\nimport { ConsoleLogger } from '@aws-amplify/core';\nconst logger = new ConsoleLogger('DataStore');\nclass StorageClass {\n    constructor(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, adapter, sessionId) {\n        this.schema = schema;\n        this.namespaceResolver = namespaceResolver;\n        this.getModelConstructorByModelName = getModelConstructorByModelName;\n        this.modelInstanceCreator = modelInstanceCreator;\n        this.adapter = adapter;\n        this.sessionId = sessionId;\n        this.adapter = this.adapter || getDefaultAdapter();\n        this.pushStream = new Subject();\n    }\n    static getNamespace() {\n        const namespace = {\n            name: STORAGE,\n            relationships: {},\n            enums: {},\n            models: {},\n            nonModels: {},\n        };\n        return namespace;\n    }\n    async init() {\n        if (this.initialized !== undefined) {\n            await this.initialized;\n            return;\n        }\n        logger.debug('Starting Storage');\n        let resolve;\n        let reject;\n        this.initialized = new Promise((res, rej) => {\n            resolve = res;\n            reject = rej;\n        });\n        this.adapter.setUp(this.schema, this.namespaceResolver, this.modelInstanceCreator, this.getModelConstructorByModelName, this.sessionId).then(resolve, reject);\n        await this.initialized;\n    }\n    async save(model, condition, mutator, patchesTuple) {\n        await this.init();\n        if (!this.adapter) {\n            throw new Error('Storage adapter is missing');\n        }\n        const result = await this.adapter.save(model, condition);\n        result.forEach(r => {\n            const [savedElement, opType] = r;\n            // truthy when save is called by the Merger\n            const syncResponse = !!mutator;\n            let updateMutationInput;\n            // don't attempt to calc mutation input when storage.save\n            // is called by Merger, i.e., when processing an AppSync response\n            if ((opType === OpType.UPDATE || opType === OpType.INSERT) &&\n                !syncResponse) {\n                //\n                // TODO: LOOK!!!\n                // the `model` used here is in effect regardless of what model\n                // comes back from adapter.save().\n                // Prior to fix, SQLite adapter had been returning two models\n                // of different types, resulting in invalid outbox entries.\n                //\n                // the bug is essentially fixed in SQLite adapter.\n                // leaving as-is, because it's currently unclear whether anything\n                // depends on this remaining as-is.\n                //\n                updateMutationInput = this.getChangedFieldsInput(model, savedElement, patchesTuple);\n                // // an update without changed user fields\n                // => don't create mutationEvent\n                if (updateMutationInput === null) {\n                    return result;\n                }\n            }\n            const element = updateMutationInput || savedElement;\n            const modelConstructor = Object.getPrototypeOf(savedElement)\n                .constructor;\n            this.pushStream.next({\n                model: modelConstructor,\n                opType,\n                element,\n                mutator,\n                condition: (condition &&\n                    ModelPredicateCreator.getPredicates(condition, false)) ||\n                    null,\n                savedElement,\n            });\n        });\n        return result;\n    }\n    async delete(modelOrModelConstructor, condition, mutator) {\n        await this.init();\n        if (!this.adapter) {\n            throw new Error('Storage adapter is missing');\n        }\n        let models;\n        let deleted;\n        [models, deleted] = await this.adapter.delete(modelOrModelConstructor, condition);\n        const modelConstructor = isModelConstructor(modelOrModelConstructor)\n            ? modelOrModelConstructor\n            : Object.getPrototypeOf(modelOrModelConstructor || {})\n                .constructor;\n        const namespaceName = this.namespaceResolver(modelConstructor);\n        const modelDefinition = this.schema.namespaces[namespaceName].models[modelConstructor.name];\n        const modelIds = new Set(models.map(model => {\n            const modelId = getIdentifierValue(modelDefinition, model);\n            return modelId;\n        }));\n        if (!isModelConstructor(modelOrModelConstructor) &&\n            !Array.isArray(deleted)) {\n            deleted = [deleted];\n        }\n        deleted.forEach(model => {\n            const modelConstructor = Object.getPrototypeOf(model)\n                .constructor;\n            let theCondition;\n            if (!isModelConstructor(modelOrModelConstructor)) {\n                const modelId = getIdentifierValue(modelDefinition, model);\n                theCondition = modelIds.has(modelId)\n                    ? ModelPredicateCreator.getPredicates(condition, false)\n                    : undefined;\n            }\n            this.pushStream.next({\n                model: modelConstructor,\n                opType: OpType.DELETE,\n                element: model,\n                mutator,\n                condition: theCondition || null,\n            });\n        });\n        return [models, deleted];\n    }\n    async query(modelConstructor, predicate, pagination) {\n        await this.init();\n        if (!this.adapter) {\n            throw new Error('Storage adapter is missing');\n        }\n        return await this.adapter.query(modelConstructor, predicate, pagination);\n    }\n    async queryOne(modelConstructor, firstOrLast = QueryOne.FIRST) {\n        await this.init();\n        if (!this.adapter) {\n            throw new Error('Storage adapter is missing');\n        }\n        return await this.adapter.queryOne(modelConstructor, firstOrLast);\n    }\n    observe(modelConstructor, predicate, skipOwn) {\n        const listenToAll = !modelConstructor;\n        const { predicates, type } = (predicate && ModelPredicateCreator.getPredicates(predicate, false)) ||\n            {};\n        let result = this.pushStream\n            .pipe(filter(({ mutator }) => {\n            return !skipOwn || mutator !== skipOwn;\n        }))\n            .pipe(map(({ mutator: _mutator, ...message }) => message));\n        if (!listenToAll) {\n            result = result.pipe(filter(({ model, element }) => {\n                if (modelConstructor !== model) {\n                    return false;\n                }\n                if (!!predicates && !!type) {\n                    return validatePredicate(element, type, predicates);\n                }\n                return true;\n            }));\n        }\n        return result;\n    }\n    async clear(completeObservable = true) {\n        this.initialized = undefined;\n        if (!this.adapter) {\n            throw new Error('Storage adapter is missing');\n        }\n        await this.adapter.clear();\n        if (completeObservable) {\n            this.pushStream.complete();\n        }\n    }\n    async batchSave(modelConstructor, items, mutator) {\n        await this.init();\n        if (!this.adapter) {\n            throw new Error('Storage adapter is missing');\n        }\n        const result = await this.adapter.batchSave(modelConstructor, items);\n        result.forEach(([element, opType]) => {\n            this.pushStream.next({\n                model: modelConstructor,\n                opType,\n                element,\n                mutator,\n                condition: null,\n            });\n        });\n        return result;\n    }\n    // returns null if no user fields were changed (determined by value comparison)\n    getChangedFieldsInput(model, originalElement, patchesTuple) {\n        const containsPatches = patchesTuple && patchesTuple.length;\n        if (!containsPatches) {\n            return null;\n        }\n        const [patches, source] = patchesTuple;\n        const updatedElement = {};\n        // extract array of updated fields from patches\n        const updatedFields = (patches.map(patch => patch.path && patch.path[0]));\n        // check model def for association and replace with targetName if exists\n        const modelConstructor = Object.getPrototypeOf(model)\n            .constructor;\n        const namespace = this.namespaceResolver(modelConstructor);\n        const { fields } = this.schema.namespaces[namespace].models[modelConstructor.name];\n        const { primaryKey, compositeKeys = [] } = this.schema.namespaces[namespace].keys?.[modelConstructor.name] || {};\n        // set original values for these fields\n        updatedFields.forEach((field) => {\n            const targetNames = isTargetNameAssociation(fields[field]?.association);\n            if (Array.isArray(targetNames)) {\n                // if field refers to a belongsTo relation, use the target field instead\n                for (const targetName of targetNames) {\n                    // check field values by value. Ignore unchanged fields\n                    if (!valuesEqual(source[targetName], originalElement[targetName])) {\n                        // if the field was updated to 'undefined', replace with 'null' for compatibility with JSON and GraphQL\n                        updatedElement[targetName] =\n                            originalElement[targetName] === undefined\n                                ? null\n                                : originalElement[targetName];\n                        for (const fieldSet of compositeKeys) {\n                            // include all of the fields that comprise the composite key\n                            if (fieldSet.has(targetName)) {\n                                for (const compositeField of fieldSet) {\n                                    updatedElement[compositeField] =\n                                        originalElement[compositeField];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                // Backwards compatibility pre-CPK\n                // if field refers to a belongsTo relation, use the target field instead\n                const key = targetNames || field;\n                // check field values by value. Ignore unchanged fields\n                if (!valuesEqual(source[key], originalElement[key])) {\n                    // if the field was updated to 'undefined', replace with 'null' for compatibility with JSON and GraphQL\n                    updatedElement[key] =\n                        originalElement[key] === undefined ? null : originalElement[key];\n                    for (const fieldSet of compositeKeys) {\n                        // include all of the fields that comprise the composite key\n                        if (fieldSet.has(key)) {\n                            for (const compositeField of fieldSet) {\n                                updatedElement[compositeField] =\n                                    originalElement[compositeField];\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        // Exit early when there are no changes introduced in the update mutation\n        if (Object.keys(updatedElement).length === 0) {\n            return null;\n        }\n        // include field(s) from custom PK if one is specified for the model\n        if (primaryKey && primaryKey.length) {\n            for (const pkField of primaryKey) {\n                updatedElement[pkField] = originalElement[pkField];\n            }\n        }\n        const { id, _version, _lastChangedAt, _deleted } = originalElement;\n        // For update mutations we only want to send fields with changes\n        // and the required internal fields\n        return {\n            ...updatedElement,\n            id,\n            _version,\n            _lastChangedAt,\n            _deleted,\n        };\n    }\n}\nclass ExclusiveStorage {\n    constructor(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, adapter, sessionId) {\n        this.mutex = new Mutex();\n        this.storage = new StorageClass(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, adapter, sessionId);\n    }\n    runExclusive(fn) {\n        return this.mutex.runExclusive(fn.bind(this, this.storage));\n    }\n    async save(model, condition, mutator, patchesTuple) {\n        return this.runExclusive(storage => storage.save(model, condition, mutator, patchesTuple));\n    }\n    async delete(modelOrModelConstructor, condition, mutator) {\n        return this.runExclusive(storage => {\n            if (isModelConstructor(modelOrModelConstructor)) {\n                const modelConstructor = modelOrModelConstructor;\n                return storage.delete(modelConstructor, condition, mutator);\n            }\n            else {\n                const model = modelOrModelConstructor;\n                return storage.delete(model, condition, mutator);\n            }\n        });\n    }\n    async query(modelConstructor, predicate, pagination) {\n        return this.runExclusive(storage => storage.query(modelConstructor, predicate, pagination));\n    }\n    async queryOne(modelConstructor, firstOrLast = QueryOne.FIRST) {\n        return this.runExclusive(storage => storage.queryOne(modelConstructor, firstOrLast));\n    }\n    static getNamespace() {\n        return StorageClass.getNamespace();\n    }\n    observe(modelConstructor, predicate, skipOwn) {\n        return this.storage.observe(modelConstructor, predicate, skipOwn);\n    }\n    async clear() {\n        await this.runExclusive(storage => storage.clear());\n    }\n    batchSave(modelConstructor, items) {\n        return this.storage.batchSave(modelConstructor, items);\n    }\n    async init() {\n        return this.storage.init();\n    }\n}\nexport { ExclusiveStorage };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}