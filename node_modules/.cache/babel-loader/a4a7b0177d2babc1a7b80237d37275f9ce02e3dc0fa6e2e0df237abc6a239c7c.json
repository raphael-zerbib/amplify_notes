{"ast":null,"code":"import { Amplify } from '@aws-amplify/core';\nimport { StorageAction } from '@aws-amplify/core/internals/utils';\nimport '@smithy/md5-js';\nimport '@aws-amplify/core/internals/aws-client-utils';\nimport '../../../utils/client/runtime/s3TransferHandler/fetch.mjs';\nimport 'fast-xml-parser';\nimport '../../../utils/client/runtime/s3TransferHandler/xhr.mjs';\nimport 'buffer';\nimport { StorageError } from '../../../../../errors/StorageError.mjs';\nimport { resolveS3ConfigAndInput } from '../../../utils/resolveS3ConfigAndInput.mjs';\nimport { CanceledError } from '../../../../../errors/CanceledError.mjs';\nimport '../../../../../errors/types/validation.mjs';\nimport { logger } from '../../../../../utils/logger.mjs';\nimport { DEFAULT_QUEUE_SIZE, DEFAULT_ACCESS_LEVEL } from '../../../utils/constants.mjs';\nimport '../../../utils/client/base.mjs';\nimport '../../../utils/client/getObject.mjs';\nimport '../../../utils/client/listObjectsV2.mjs';\nimport '../../../utils/client/putObject.mjs';\nimport '../../../utils/client/createMultipartUpload.mjs';\nimport '../../../utils/client/uploadPart.mjs';\nimport { completeMultipartUpload } from '../../../utils/client/completeMultipartUpload.mjs';\nimport '../../../utils/client/listParts.mjs';\nimport { abortMultipartUpload } from '../../../utils/client/abortMultipartUpload.mjs';\nimport '../../../utils/client/copyObject.mjs';\nimport { headObject } from '../../../utils/client/headObject.mjs';\nimport '../../../utils/client/deleteObject.mjs';\nimport { getStorageUserAgentValue } from '../../../utils/userAgent.mjs';\nimport { uploadPartExecutor } from './uploadPartExecutor.mjs';\nimport { getUploadsCacheKey, removeCachedUpload } from './uploadCache.mjs';\nimport { getConcurrentUploadsProgressTracker } from './progressTracker.mjs';\nimport { loadOrCreateMultipartUpload } from './initialUpload.mjs';\nimport { getDataChunker } from './getDataChunker.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Create closure hiding the multipart upload implementation details and expose the upload job and control functions(\n * onPause, onResume, onCancel).\n *\n * @internal\n */\nconst getMultipartUploadHandlers = (_ref, size) => {\n  let {\n    options: uploadDataOptions,\n    key,\n    data\n  } = _ref;\n  let resolveCallback;\n  let rejectCallback;\n  let inProgressUpload;\n  let resolvedS3Config;\n  let abortController;\n  let resolvedBucket;\n  let resolvedKeyPrefix;\n  let uploadCacheKey;\n  // Special flag that differentiates HTTP requests abort error caused by pause() from ones caused by cancel().\n  // The former one should NOT cause the upload job to throw, but cancels any pending HTTP requests.\n  // This should be replaced by a special abort reason. However,the support of this API is lagged behind.\n  let isAbortSignalFromPause = false;\n  const startUpload = async () => {\n    const resolvedS3Options = await resolveS3ConfigAndInput(Amplify, uploadDataOptions);\n    resolvedS3Config = resolvedS3Options.s3Config;\n    resolvedBucket = resolvedS3Options.bucket;\n    resolvedKeyPrefix = resolvedS3Options.keyPrefix;\n    abortController = new AbortController();\n    isAbortSignalFromPause = false;\n    const {\n      contentDisposition,\n      contentEncoding,\n      contentType = 'application/octet-stream',\n      metadata,\n      accessLevel,\n      onProgress\n    } = uploadDataOptions !== null && uploadDataOptions !== void 0 ? uploadDataOptions : {};\n    if (!inProgressUpload) {\n      const {\n        uploadId,\n        cachedParts\n      } = await loadOrCreateMultipartUpload({\n        s3Config: resolvedS3Config,\n        accessLevel: resolveAccessLevel(accessLevel),\n        bucket: resolvedBucket,\n        keyPrefix: resolvedKeyPrefix,\n        key,\n        contentType,\n        contentDisposition,\n        contentEncoding,\n        metadata,\n        data,\n        size,\n        abortSignal: abortController.signal\n      });\n      inProgressUpload = {\n        uploadId,\n        completedParts: cachedParts\n      };\n    }\n    const finalKey = resolvedKeyPrefix + key;\n    uploadCacheKey = size ? getUploadsCacheKey({\n      file: data instanceof File ? data : undefined,\n      accessLevel: resolveAccessLevel(uploadDataOptions === null || uploadDataOptions === void 0 ? void 0 : uploadDataOptions.accessLevel),\n      contentType: uploadDataOptions === null || uploadDataOptions === void 0 ? void 0 : uploadDataOptions.contentType,\n      bucket: resolvedBucket,\n      size,\n      key\n    }) : undefined;\n    const dataChunker = getDataChunker(data, size);\n    const completedPartNumberSet = new Set(inProgressUpload.completedParts.map(_ref2 => {\n      let {\n        PartNumber\n      } = _ref2;\n      return PartNumber;\n    }));\n    const onPartUploadCompletion = (partNumber, eTag) => {\n      var _inProgressUpload;\n      (_inProgressUpload = inProgressUpload) === null || _inProgressUpload === void 0 || _inProgressUpload.completedParts.push({\n        PartNumber: partNumber,\n        ETag: eTag\n      });\n    };\n    const concurrentUploadsProgressTracker = getConcurrentUploadsProgressTracker({\n      size,\n      onProgress\n    });\n    const concurrentUploadPartExecutors = [];\n    for (let index = 0; index < DEFAULT_QUEUE_SIZE; index++) {\n      concurrentUploadPartExecutors.push(uploadPartExecutor({\n        dataChunkerGenerator: dataChunker,\n        completedPartNumberSet,\n        s3Config: resolvedS3Config,\n        abortSignal: abortController.signal,\n        bucket: resolvedBucket,\n        finalKey,\n        uploadId: inProgressUpload.uploadId,\n        onPartUploadCompletion,\n        onProgress: concurrentUploadsProgressTracker.getOnProgressListener(),\n        isObjectLockEnabled: resolvedS3Options.isObjectLockEnabled\n      }));\n    }\n    await Promise.all(concurrentUploadPartExecutors);\n    const {\n      ETag: eTag\n    } = await completeMultipartUpload({\n      ...resolvedS3Config,\n      abortSignal: abortController.signal,\n      userAgentValue: getStorageUserAgentValue(StorageAction.UploadData)\n    }, {\n      Bucket: resolvedBucket,\n      Key: finalKey,\n      UploadId: inProgressUpload.uploadId,\n      MultipartUpload: {\n        Parts: inProgressUpload.completedParts.sort((partA, partB) => partA.PartNumber - partB.PartNumber)\n      }\n    });\n    if (size) {\n      const {\n        ContentLength: uploadedObjectSize\n      } = await headObject(resolvedS3Config, {\n        Bucket: resolvedBucket,\n        Key: finalKey\n      });\n      if (uploadedObjectSize && uploadedObjectSize !== size) {\n        throw new StorageError({\n          name: 'Error',\n          message: \"Upload failed. Expected object size \".concat(size, \", but got \").concat(uploadedObjectSize, \".\")\n        });\n      }\n    }\n    if (uploadCacheKey) {\n      await removeCachedUpload(uploadCacheKey);\n    }\n    return {\n      key,\n      eTag,\n      contentType,\n      metadata\n    };\n  };\n  const startUploadWithResumability = () => startUpload().then(resolveCallback).catch(error => {\n    var _abortController;\n    const abortSignal = (_abortController = abortController) === null || _abortController === void 0 ? void 0 : _abortController.signal;\n    if (abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted && isAbortSignalFromPause) {\n      logger.debug('upload paused.');\n    } else {\n      // Uncaught errors should be exposed to the users.\n      rejectCallback(error);\n    }\n  });\n  const multipartUploadJob = () => new Promise((resolve, reject) => {\n    resolveCallback = resolve;\n    rejectCallback = reject;\n    startUploadWithResumability();\n  });\n  const onPause = () => {\n    var _abortController2;\n    isAbortSignalFromPause = true;\n    (_abortController2 = abortController) === null || _abortController2 === void 0 || _abortController2.abort();\n  };\n  const onResume = () => {\n    startUploadWithResumability();\n  };\n  const onCancel = message => {\n    var _abortController3;\n    // 1. abort in-flight API requests\n    (_abortController3 = abortController) === null || _abortController3 === void 0 || _abortController3.abort(message);\n    const cancelUpload = async () => {\n      var _inProgressUpload2;\n      // 2. clear upload cache.\n      if (uploadCacheKey) {\n        await removeCachedUpload(uploadCacheKey);\n      }\n      // 3. clear multipart upload on server side.\n      await abortMultipartUpload(resolvedS3Config, {\n        Bucket: resolvedBucket,\n        Key: resolvedKeyPrefix + key,\n        UploadId: (_inProgressUpload2 = inProgressUpload) === null || _inProgressUpload2 === void 0 ? void 0 : _inProgressUpload2.uploadId\n      });\n    };\n    cancelUpload().catch(e => {\n      logger.debug('error when cancelling upload task.', e);\n    });\n    rejectCallback(\n    // Internal error that should not be exposed to the users. They should use isCancelError() to check if\n    // the error is caused by cancel().\n    new CanceledError(message ? {\n      message\n    } : undefined));\n  };\n  return {\n    multipartUploadJob,\n    onPause,\n    onResume,\n    onCancel\n  };\n};\nconst resolveAccessLevel = accessLevel => {\n  var _ref3, _Amplify$libraryOptio;\n  return (_ref3 = accessLevel !== null && accessLevel !== void 0 ? accessLevel : (_Amplify$libraryOptio = Amplify.libraryOptions.Storage) === null || _Amplify$libraryOptio === void 0 || (_Amplify$libraryOptio = _Amplify$libraryOptio.S3) === null || _Amplify$libraryOptio === void 0 ? void 0 : _Amplify$libraryOptio.defaultAccessLevel) !== null && _ref3 !== void 0 ? _ref3 : DEFAULT_ACCESS_LEVEL;\n};\nexport { getMultipartUploadHandlers };","map":{"version":3,"names":["getMultipartUploadHandlers","_ref","size","options","uploadDataOptions","key","data","resolveCallback","rejectCallback","inProgressUpload","resolvedS3Config","abortController","resolvedBucket","resolvedKeyPrefix","uploadCacheKey","isAbortSignalFromPause","startUpload","resolvedS3Options","resolveS3ConfigAndInput","Amplify","s3Config","bucket","keyPrefix","AbortController","contentDisposition","contentEncoding","contentType","metadata","accessLevel","onProgress","uploadId","cachedParts","loadOrCreateMultipartUpload","resolveAccessLevel","abortSignal","signal","completedParts","finalKey","getUploadsCacheKey","file","File","undefined","dataChunker","getDataChunker","completedPartNumberSet","Set","map","_ref2","PartNumber","onPartUploadCompletion","partNumber","eTag","_inProgressUpload","push","ETag","concurrentUploadsProgressTracker","getConcurrentUploadsProgressTracker","concurrentUploadPartExecutors","index","DEFAULT_QUEUE_SIZE","uploadPartExecutor","dataChunkerGenerator","getOnProgressListener","isObjectLockEnabled","Promise","all","completeMultipartUpload","userAgentValue","getStorageUserAgentValue","StorageAction","UploadData","Bucket","Key","UploadId","MultipartUpload","Parts","sort","partA","partB","ContentLength","uploadedObjectSize","headObject","StorageError","name","message","concat","removeCachedUpload","startUploadWithResumability","then","catch","error","_abortController","aborted","logger","debug","multipartUploadJob","resolve","reject","onPause","_abortController2","abort","onResume","onCancel","_abortController3","cancelUpload","_inProgressUpload2","abortMultipartUpload","e","CanceledError","_ref3","_Amplify$libraryOptio","libraryOptions","Storage","S3","defaultAccessLevel","DEFAULT_ACCESS_LEVEL"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/storage/src/providers/s3/apis/uploadData/multipart/uploadHandlers.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Amplify } from '@aws-amplify/core';\nimport { StorageAction } from '@aws-amplify/core/internals/utils';\nimport { resolveS3ConfigAndInput } from '../../../utils';\nimport { DEFAULT_ACCESS_LEVEL, DEFAULT_QUEUE_SIZE, } from '../../../utils/constants';\nimport { StorageError } from '../../../../../errors/StorageError';\nimport { CanceledError } from '../../../../../errors/CanceledError';\nimport { abortMultipartUpload, completeMultipartUpload, headObject, } from '../../../utils/client';\nimport { getStorageUserAgentValue } from '../../../utils/userAgent';\nimport { logger } from '../../../../../utils';\nimport { uploadPartExecutor } from './uploadPartExecutor';\nimport { getUploadsCacheKey, removeCachedUpload } from './uploadCache';\nimport { getConcurrentUploadsProgressTracker } from './progressTracker';\nimport { loadOrCreateMultipartUpload } from './initialUpload';\nimport { getDataChunker } from './getDataChunker';\n/**\n * Create closure hiding the multipart upload implementation details and expose the upload job and control functions(\n * onPause, onResume, onCancel).\n *\n * @internal\n */\nexport const getMultipartUploadHandlers = ({ options: uploadDataOptions, key, data }, size) => {\n    let resolveCallback;\n    let rejectCallback;\n    let inProgressUpload;\n    let resolvedS3Config;\n    let abortController;\n    let resolvedBucket;\n    let resolvedKeyPrefix;\n    let uploadCacheKey;\n    // Special flag that differentiates HTTP requests abort error caused by pause() from ones caused by cancel().\n    // The former one should NOT cause the upload job to throw, but cancels any pending HTTP requests.\n    // This should be replaced by a special abort reason. However,the support of this API is lagged behind.\n    let isAbortSignalFromPause = false;\n    const startUpload = async () => {\n        const resolvedS3Options = await resolveS3ConfigAndInput(Amplify, uploadDataOptions);\n        resolvedS3Config = resolvedS3Options.s3Config;\n        resolvedBucket = resolvedS3Options.bucket;\n        resolvedKeyPrefix = resolvedS3Options.keyPrefix;\n        abortController = new AbortController();\n        isAbortSignalFromPause = false;\n        const { contentDisposition, contentEncoding, contentType = 'application/octet-stream', metadata, accessLevel, onProgress, } = uploadDataOptions ?? {};\n        if (!inProgressUpload) {\n            const { uploadId, cachedParts } = await loadOrCreateMultipartUpload({\n                s3Config: resolvedS3Config,\n                accessLevel: resolveAccessLevel(accessLevel),\n                bucket: resolvedBucket,\n                keyPrefix: resolvedKeyPrefix,\n                key,\n                contentType,\n                contentDisposition,\n                contentEncoding,\n                metadata,\n                data,\n                size,\n                abortSignal: abortController.signal,\n            });\n            inProgressUpload = {\n                uploadId,\n                completedParts: cachedParts,\n            };\n        }\n        const finalKey = resolvedKeyPrefix + key;\n        uploadCacheKey = size\n            ? getUploadsCacheKey({\n                file: data instanceof File ? data : undefined,\n                accessLevel: resolveAccessLevel(uploadDataOptions?.accessLevel),\n                contentType: uploadDataOptions?.contentType,\n                bucket: resolvedBucket,\n                size,\n                key,\n            })\n            : undefined;\n        const dataChunker = getDataChunker(data, size);\n        const completedPartNumberSet = new Set(inProgressUpload.completedParts.map(({ PartNumber }) => PartNumber));\n        const onPartUploadCompletion = (partNumber, eTag) => {\n            inProgressUpload?.completedParts.push({\n                PartNumber: partNumber,\n                ETag: eTag,\n            });\n        };\n        const concurrentUploadsProgressTracker = getConcurrentUploadsProgressTracker({\n            size,\n            onProgress,\n        });\n        const concurrentUploadPartExecutors = [];\n        for (let index = 0; index < DEFAULT_QUEUE_SIZE; index++) {\n            concurrentUploadPartExecutors.push(uploadPartExecutor({\n                dataChunkerGenerator: dataChunker,\n                completedPartNumberSet,\n                s3Config: resolvedS3Config,\n                abortSignal: abortController.signal,\n                bucket: resolvedBucket,\n                finalKey,\n                uploadId: inProgressUpload.uploadId,\n                onPartUploadCompletion,\n                onProgress: concurrentUploadsProgressTracker.getOnProgressListener(),\n                isObjectLockEnabled: resolvedS3Options.isObjectLockEnabled,\n            }));\n        }\n        await Promise.all(concurrentUploadPartExecutors);\n        const { ETag: eTag } = await completeMultipartUpload({\n            ...resolvedS3Config,\n            abortSignal: abortController.signal,\n            userAgentValue: getStorageUserAgentValue(StorageAction.UploadData),\n        }, {\n            Bucket: resolvedBucket,\n            Key: finalKey,\n            UploadId: inProgressUpload.uploadId,\n            MultipartUpload: {\n                Parts: inProgressUpload.completedParts.sort((partA, partB) => partA.PartNumber - partB.PartNumber),\n            },\n        });\n        if (size) {\n            const { ContentLength: uploadedObjectSize } = await headObject(resolvedS3Config, {\n                Bucket: resolvedBucket,\n                Key: finalKey,\n            });\n            if (uploadedObjectSize && uploadedObjectSize !== size) {\n                throw new StorageError({\n                    name: 'Error',\n                    message: `Upload failed. Expected object size ${size}, but got ${uploadedObjectSize}.`,\n                });\n            }\n        }\n        if (uploadCacheKey) {\n            await removeCachedUpload(uploadCacheKey);\n        }\n        return {\n            key,\n            eTag,\n            contentType,\n            metadata,\n        };\n    };\n    const startUploadWithResumability = () => startUpload()\n        .then(resolveCallback)\n        .catch(error => {\n        const abortSignal = abortController?.signal;\n        if (abortSignal?.aborted && isAbortSignalFromPause) {\n            logger.debug('upload paused.');\n        }\n        else {\n            // Uncaught errors should be exposed to the users.\n            rejectCallback(error);\n        }\n    });\n    const multipartUploadJob = () => new Promise((resolve, reject) => {\n        resolveCallback = resolve;\n        rejectCallback = reject;\n        startUploadWithResumability();\n    });\n    const onPause = () => {\n        isAbortSignalFromPause = true;\n        abortController?.abort();\n    };\n    const onResume = () => {\n        startUploadWithResumability();\n    };\n    const onCancel = (message) => {\n        // 1. abort in-flight API requests\n        abortController?.abort(message);\n        const cancelUpload = async () => {\n            // 2. clear upload cache.\n            if (uploadCacheKey) {\n                await removeCachedUpload(uploadCacheKey);\n            }\n            // 3. clear multipart upload on server side.\n            await abortMultipartUpload(resolvedS3Config, {\n                Bucket: resolvedBucket,\n                Key: resolvedKeyPrefix + key,\n                UploadId: inProgressUpload?.uploadId,\n            });\n        };\n        cancelUpload().catch(e => {\n            logger.debug('error when cancelling upload task.', e);\n        });\n        rejectCallback(\n        // Internal error that should not be exposed to the users. They should use isCancelError() to check if\n        // the error is caused by cancel().\n        new CanceledError(message ? { message } : undefined));\n    };\n    return {\n        multipartUploadJob,\n        onPause,\n        onResume,\n        onCancel,\n    };\n};\nconst resolveAccessLevel = (accessLevel) => accessLevel ??\n    Amplify.libraryOptions.Storage?.S3?.defaultAccessLevel ??\n    DEFAULT_ACCESS_LEVEL;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}