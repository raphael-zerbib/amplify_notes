{"ast":null,"code":"import { PredicateInternalsKey } from '../types.mjs';\nimport { comparisonKeys, ModelPredicateCreator } from './index.mjs';\nimport { ModelRelationship } from '../storage/relationship.mjs';\nimport { asyncSome, asyncEvery } from '../util.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst ops = [...comparisonKeys];\n/**\n * A map from keys (exposed to customers) to the internal predicate data\n * structures invoking code should not muck with.\n */\nconst predicateInternalsMap = new Map();\n/**\n * Creates a link between a key (and generates a key if needed) and an internal\n * `GroupCondition`, which allows us to return a key object instead of the gory\n * conditions details to customers/invoking code.\n *\n * @param condition The internal condition to keep hidden.\n * @param key The object DataStore will use to find the internal condition.\n * If no key is given, an empty one is created.\n */\nconst registerPredicateInternals = (condition, key) => {\n  const finalKey = key || new PredicateInternalsKey();\n  predicateInternalsMap.set(finalKey, condition);\n  return finalKey;\n};\n/**\n * Takes a key object from `registerPredicateInternals()` to fetch an internal\n * `GroupCondition` object, which can then be used to query storage or\n * test/match objects.\n *\n * This indirection exists to hide `GroupCondition` from public interfaces, since\n * `GroupCondition` contains extra methods and properties that public callers\n * should not use.\n *\n * @param key A key object previously returned by `registerPredicateInternals()`\n */\nconst internals = key => {\n  if (!predicateInternalsMap.has(key)) {\n    throw new Error(\"Invalid predicate. Terminate your predicate with a valid condition (e.g., `p => p.field.eq('value')`) or pass `Predicates.ALL`.\");\n  }\n  return predicateInternalsMap.get(key);\n};\n/**\n * Maps operators to negated operators.\n * Used to facilitate propagation of negation down a tree of conditions.\n */\nconst negations = {\n  and: 'or',\n  or: 'and',\n  not: 'and',\n  eq: 'ne',\n  ne: 'eq',\n  gt: 'le',\n  ge: 'lt',\n  lt: 'ge',\n  le: 'gt',\n  contains: 'notContains',\n  notContains: 'contains'\n};\n/**\n * A condition that can operate against a single \"primitive\" field of a model or item.\n * @member field The field of *some record* to test against.\n * @member operator The equality or comparison operator to use.\n * @member operands The operands for the equality/comparison check.\n */\nclass FieldCondition {\n  constructor(field, operator, operands) {\n    this.field = field;\n    this.operator = operator;\n    this.operands = operands;\n    this.validate();\n  }\n  /**\n   * Creates a copy of self.\n   * @param extract Not used. Present only to fulfill the `UntypedCondition` interface.\n   * @returns A new, identitical `FieldCondition`.\n   */\n  copy(extract) {\n    return [new FieldCondition(this.field, this.operator, [...this.operands]), undefined];\n  }\n  /**\n   * Produces a tree structure similar to a graphql condition. The returned\n   * structure is \"dumb\" and is intended for another query/condition\n   * generation mechanism to interpret, such as the cloud or storage query\n   * builders.\n   *\n   * E.g.,\n   *\n   * ```json\n   * {\n   * \t\"name\": {\n   * \t\t\"eq\": \"robert\"\n   * \t}\n   * }\n   * ```\n   */\n  toAST() {\n    return {\n      [this.field]: {\n        [this.operator]: this.operator === 'between' ? [this.operands[0], this.operands[1]] : this.operands[0]\n      }\n    };\n  }\n  /**\n   * Produces a new condition (`FieldCondition` or `GroupCondition`) that\n   * matches the opposite of this condition.\n   *\n   * Intended to be used when applying De Morgan's Law, which can be done to\n   * produce more efficient queries against the storage layer if a negation\n   * appears in the query tree.\n   *\n   * For example:\n   *\n   * 1. `name.eq('robert')` becomes `name.ne('robert')`\n   * 2. `price.between(100, 200)` becomes `m => m.or(m => [m.price.lt(100), m.price.gt(200)])`\n   *\n   * @param model The model meta to use when construction a new `GroupCondition`\n   * for cases where the negation requires multiple `FieldCondition`'s.\n   */\n  negated(model) {\n    if (this.operator === 'between') {\n      return new GroupCondition(model, undefined, undefined, 'or', [new FieldCondition(this.field, 'lt', [this.operands[0]]), new FieldCondition(this.field, 'gt', [this.operands[1]])]);\n    } else if (this.operator === 'beginsWith') {\n      // beginsWith negation doesn't have a good, safe optimation right now.\n      // just re-wrap it in negation. The adapter will have to scan-and-filter,\n      // as is likely optimal for negated beginsWith conditions *anyway*.\n      return new GroupCondition(model, undefined, undefined, 'not', [new FieldCondition(this.field, 'beginsWith', [this.operands[0]])]);\n    } else {\n      return new FieldCondition(this.field, negations[this.operator], this.operands);\n    }\n  }\n  /**\n   * Not implemented. Not needed. GroupCondition instead consumes FieldConditions and\n   * transforms them into legacy predicates. (*For now.*)\n   * @param storage N/A. If ever implemented, the storage adapter to query.\n   * @returns N/A. If ever implemented, return items from `storage` that match.\n   */\n  async fetch(storage) {\n    return Promise.reject('No implementation needed [yet].');\n  }\n  /**\n   * Determins whether a given item matches the expressed condition.\n   * @param item The item to test.\n   * @returns `Promise<boolean>`, `true` if matches; `false` otherwise.\n   */\n  async matches(item) {\n    const v = item[this.field];\n    const operations = {\n      eq: () => v === this.operands[0],\n      ne: () => v !== this.operands[0],\n      gt: () => v > this.operands[0],\n      ge: () => v >= this.operands[0],\n      lt: () => v < this.operands[0],\n      le: () => v <= this.operands[0],\n      contains: () => v?.indexOf(this.operands[0]) > -1,\n      notContains: () => !v ? true : v.indexOf(this.operands[0]) === -1,\n      beginsWith: () => v?.startsWith(this.operands[0]),\n      between: () => v >= this.operands[0] && v <= this.operands[1]\n    };\n    const operation = operations[this.operator];\n    if (operation) {\n      const result = operation();\n      return result;\n    } else {\n      throw new Error(`Invalid operator given: ${this.operator}`);\n    }\n  }\n  /**\n   * Checks `this.operands` for compatibility with `this.operator`.\n   */\n  validate() {\n    /**\n     * Creates a validator that checks for a particular `operands` count.\n     * Throws an exception if the `count` disagrees with `operands.length`.\n     * @param count The number of `operands` expected.\n     */\n    const argumentCount = count => {\n      const argsClause = count === 1 ? 'argument is' : 'arguments are';\n      return () => {\n        if (this.operands.length !== count) {\n          return `Exactly ${count} ${argsClause} required.`;\n        }\n      };\n    };\n    // NOTE: validations should return a message on failure.\n    // hence, they should be \"joined\" together with logical OR's\n    // as seen in the `between:` entry.\n    const validations = {\n      eq: argumentCount(1),\n      ne: argumentCount(1),\n      gt: argumentCount(1),\n      ge: argumentCount(1),\n      lt: argumentCount(1),\n      le: argumentCount(1),\n      contains: argumentCount(1),\n      notContains: argumentCount(1),\n      beginsWith: argumentCount(1),\n      between: () => argumentCount(2)() || (this.operands[0] > this.operands[1] ? 'The first argument must be less than or equal to the second argument.' : null)\n    };\n    const validate = validations[this.operator];\n    if (validate) {\n      const e = validate();\n      if (typeof e === 'string') throw new Error(`Incorrect usage of \\`${this.operator}()\\`: ${e}`);\n    } else {\n      throw new Error(`Non-existent operator: \\`${this.operator}()\\``);\n    }\n  }\n}\n/**\n * Small utility function to generate a monotonically increasing ID.\n * Used by GroupCondition to help keep track of which group is doing what,\n * when, and where during troubleshooting.\n */\nconst getGroupId = (() => {\n  let seed = 1;\n  return () => `group_${seed++}`;\n})();\n/**\n * A set of sub-conditions to operate against a model, optionally scoped to\n * a specific field, combined with the given operator (one of `and`, `or`, or `not`).\n * @member groupId Used to distinguish between GroupCondition instances for\n * debugging and troublehsooting.\n * @member model A metadata object that tells GroupCondition what to query and how.\n * @member field The field on the model that the sub-conditions apply to.\n * @member operator How to group child conditions together.\n * @member operands The child conditions.\n */\nclass GroupCondition {\n  constructor(\n  /**\n   * The `ModelMeta` of the model to query and/or filter against.\n   * Expected to contain:\n   *\n   * ```js\n   * {\n   * \tbuilder: ModelConstructor,\n   * \tschema: SchemaModel,\n   * \tpkField: string[]\n   * }\n   * ```\n   */\n  model,\n  /**\n   * If populated, this group specifices a condition on a relationship.\n   *\n   * If `field` does *not* point to a related model, that's an error. It\n   * could indicate that the `GroupCondition` was instantiated with bad\n   * data, or that the model metadata is incorrect.\n   */\n  field,\n  /**\n   * If a `field` is given, whether the relationship is a `HAS_ONE`,\n   * 'HAS_MANY`, or `BELONGS_TO`.\n   *\n   * TODO: Remove this and replace with derivation using\n   * `ModelRelationship.from(this.model, this.field).relationship`;\n   */\n  relationshipType,\n  /**\n   *\n   */\n  operator,\n  /**\n   *\n   */\n  operands,\n  /**\n   * Whether this GroupCondition is the result of an optimize call.\n   *\n   * This is used to guard against infinitely fetch -> optimize -> fetch\n   * recursion.\n   */\n  isOptimized = false) {\n    this.model = model;\n    this.field = field;\n    this.relationshipType = relationshipType;\n    this.operator = operator;\n    this.operands = operands;\n    this.isOptimized = isOptimized;\n    // `groupId` was used for development/debugging.\n    // Should we leave this in for future troubleshooting?\n    this.groupId = getGroupId();\n  }\n  /**\n   * Returns a copy of a GroupCondition, which also returns the copy of a\n   * given reference node to \"extract\".\n   * @param extract A node of interest. Its copy will *also* be returned if the node exists.\n   * @returns [The full copy, the copy of `extract` | undefined]\n   */\n  copy(extract) {\n    const copied = new GroupCondition(this.model, this.field, this.relationshipType, this.operator, []);\n    let extractedCopy = extract === this ? copied : undefined;\n    this.operands.forEach(o => {\n      const [operandCopy, extractedFromOperand] = o.copy(extract);\n      copied.operands.push(operandCopy);\n      extractedCopy = extractedCopy || extractedFromOperand;\n    });\n    return [copied, extractedCopy];\n  }\n  /**\n   * Creates a new `GroupCondition` that contains only the local field conditions,\n   * omitting related model conditions. That resulting `GroupCondition` can be\n   * used to produce predicates that are compatible with the storage adapters and\n   * Cloud storage.\n   *\n   * @param negate Whether the condition tree should be negated according\n   * to De Morgan's law.\n   */\n  withFieldConditionsOnly(negate) {\n    const negateChildren = negate !== (this.operator === 'not');\n    return new GroupCondition(this.model, undefined, undefined, negate ? negations[this.operator] : this.operator, this.operands.filter(o => o instanceof FieldCondition).map(o => negateChildren ? o.negated(this.model) : o));\n  }\n  /**\n   * Returns a version of the predicate tree with unnecessary logical groups\n   * condensed and merged together. This is intended to create a dense tree\n   * with leaf nodes (`FieldCondition`'s) aggregated under as few group conditions\n   * as possible for the most efficient fetching possible -- it allows `fetch()`.\n   *\n   * E.g. a grouping like this:\n   *\n   * ```yaml\n   * and:\n   * \tand:\n   * \t\tid:\n   * \t\t\teq: \"abc\"\n   * \tand:\n   * \t\tname:\n   * \t\t\teq: \"xyz\"\n   * ```\n   *\n   * Will become this:\n   *\n   * ```yaml\n   * and:\n   * \tid:\n   * \t\teq: \"abc\"\n   * \tname:\n   * \t\teq: \"xyz\"\n   * ```\n   *\n   * This allows `fetch()` to pass both the `id` and `name` conditions to the adapter\n   * together, which can then decide what index to use based on both fields together.\n   *\n   * @param preserveNode Whether to preserve the current node and to explicitly not eliminate\n   * it during optimization. Used internally to preserve the root node and children of\n   * `not` groups. `not` groups will always have a single child, so there's nothing to\n   * optimize below a `not` (for now), and it makes the query logic simpler later.\n   */\n  optimized(preserveNode = true) {\n    const operands = this.operands.map(o => o instanceof GroupCondition ? o.optimized(this.operator === 'not') : o);\n    // we're only collapsing and/or groups that contains a single child for now,\n    // because they're much more common and much more trivial to collapse. basically,\n    // an `and`/`or` that contains a single child doesn't require the layer of\n    // logical grouping.\n    if (!preserveNode && ['and', 'or'].includes(this.operator) && !this.field && operands.length === 1) {\n      const operand = operands[0];\n      if (operand instanceof FieldCondition) {\n        // between conditions should NOT be passed up the chain. if they\n        // need to be *negated* later, it is important that they be properly\n        // contained in an AND group. when de morgan's law is applied, the\n        // conditions are reversed and the AND group flips to an OR. this\n        // doesn't work right if the a `between` doesn't live in an AND group.\n        if (operand.operator !== 'between') {\n          return operand;\n        }\n      } else {\n        return operand;\n      }\n    }\n    return new GroupCondition(this.model, this.field, this.relationshipType, this.operator, operands, true);\n  }\n  /**\n   * Fetches matching records from a given storage adapter using legacy predicates (for now).\n   * @param storage The storage adapter this predicate will query against.\n   * @param breadcrumb For debugging/troubleshooting. A list of the `groupId`'s this\n   * GroupdCondition.fetch is nested within.\n   * @param negate Whether to match on the `NOT` of `this`.\n   * @returns An `Promise` of `any[]` from `storage` matching the child conditions.\n   */\n  async fetch(storage, breadcrumb = [], negate = false) {\n    if (!this.isOptimized) {\n      return this.optimized().fetch(storage);\n    }\n    const resultGroups = [];\n    const operator = negate ? negations[this.operator] : this.operator;\n    const negateChildren = negate !== (this.operator === 'not');\n    /**\n     * Conditions that must be branched out and used to generate a base, \"candidate\"\n     * result set.\n     *\n     * If `field` is populated, these groups select *related* records, and the base,\n     * candidate results are selected to match those.\n     */\n    const groups = this.operands.filter(op => op instanceof GroupCondition);\n    /**\n     * Simple conditions that must match the target model of `this`.\n     */\n    const conditions = this.operands.filter(op => op instanceof FieldCondition);\n    for (const g of groups) {\n      const relatives = await g.fetch(storage, [...breadcrumb, this.groupId], negateChildren);\n      // no relatives -> no need to attempt to perform a \"join\" query for\n      // candidate results:\n      //\n      // select a.* from a,b where b.id in EMPTY_SET ==> EMPTY_SET\n      //\n      // Additionally, the entire (sub)-query can be short-circuited if\n      // the operator is `AND`. Illustrated in SQL:\n      //\n      // select a.* from a where\n      //   id in [a,b,c]\n      //     AND                        <\n      //   id in EMTPY_SET            <<< Look!\n      //     AND                        <\n      //   id in [x,y,z]\n      //\n      // YIELDS: EMPTY_SET           // <-- Easy peasy. Lemon squeezy.\n      //\n      if (relatives.length === 0) {\n        // aggressively short-circuit as soon as we know the group condition will fail\n        if (operator === 'and') {\n          return [];\n        }\n        // less aggressive short-circuit if we know the relatives will produce no\n        // candidate results; but aren't sure yet how this affects the group condition.\n        resultGroups.push([]);\n        continue;\n      }\n      if (g.field) {\n        // `relatives` are actual relatives. We'll skim them for FK query values.\n        // Use the relatives to add candidate result sets (`resultGroups`)\n        const relationship = ModelRelationship.from(this.model, g.field);\n        if (relationship) {\n          const allJoinConditions = [];\n          for (const relative of relatives) {\n            const relativeConditions = [];\n            for (let i = 0; i < relationship.localJoinFields.length; i++) {\n              relativeConditions.push({\n                [relationship.localJoinFields[i]]: {\n                  eq: relative[relationship.remoteJoinFields[i]]\n                }\n              });\n            }\n            allJoinConditions.push({\n              and: relativeConditions\n            });\n          }\n          const predicate = ModelPredicateCreator.createFromAST(this.model.schema, {\n            or: allJoinConditions\n          });\n          resultGroups.push(await storage.query(this.model.builder, predicate));\n        } else {\n          throw new Error('Missing field metadata.');\n        }\n      } else {\n        // relatives are not actually relatives. they're candidate results.\n        resultGroups.push(relatives);\n      }\n    }\n    // if conditions is empty at this point, child predicates found no matches.\n    // i.e., we can stop looking and return empty.\n    if (conditions.length > 0) {\n      const predicate = this.withFieldConditionsOnly(negateChildren).toStoragePredicate();\n      resultGroups.push(await storage.query(this.model.builder, predicate));\n    } else if (conditions.length === 0 && resultGroups.length === 0) {\n      resultGroups.push(await storage.query(this.model.builder));\n    }\n    // PK might be a single field, like `id`, or it might be several fields.\n    // so, we'll need to extract the list of PK fields from an object\n    // and stringify the list for easy comparison / merging.\n    const getPKValue = item => JSON.stringify(this.model.pkField.map(name => item[name]));\n    // will be used for intersecting or unioning results\n    let resultIndex;\n    if (operator === 'and') {\n      if (resultGroups.length === 0) {\n        return [];\n      }\n      // for each group, we intersect, removing items from the result index\n      // that aren't present in each subsequent group.\n      for (const group of resultGroups) {\n        if (resultIndex === undefined) {\n          resultIndex = new Map(group.map(item => [getPKValue(item), item]));\n        } else {\n          const intersectWith = new Map(group.map(item => [getPKValue(item), item]));\n          for (const k of resultIndex.keys()) {\n            if (!intersectWith.has(k)) {\n              resultIndex.delete(k);\n            }\n          }\n        }\n      }\n    } else if (operator === 'or' || operator === 'not') {\n      // it's OK to handle NOT here, because NOT must always only negate\n      // a single child predicate. NOT logic will have been distributed down\n      // to the leaf conditions already.\n      resultIndex = new Map();\n      // just merge the groups, performing DISTINCT-ification by ID.\n      for (const group of resultGroups) {\n        for (const item of group) {\n          resultIndex.set(getPKValue(item), item);\n        }\n      }\n    }\n    return Array.from(resultIndex?.values() || []);\n  }\n  /**\n   * Determines whether a single item matches the conditions of `this`.\n   * When checking the target `item`'s properties, each property will be `await`'d\n   * to ensure lazy-loading is respected where applicable.\n   * @param item The item to match against.\n   * @param ignoreFieldName Tells `match()` that the field name has already been dereferenced.\n   * (Used for iterating over children on HAS_MANY checks.)\n   * @returns A boolean (promise): `true` if matched, `false` otherwise.\n   */\n  async matches(item, ignoreFieldName = false) {\n    const itemToCheck = this.field && !ignoreFieldName ? await item[this.field] : item;\n    // if there is no item to check, we can stop recursing immediately.\n    // a condition cannot match against an item that does not exist. this\n    // can occur when `item.field` is optional in the schema.\n    if (!itemToCheck) {\n      return false;\n    }\n    if (this.relationshipType === 'HAS_MANY' && typeof itemToCheck[Symbol.asyncIterator] === 'function') {\n      for await (const singleItem of itemToCheck) {\n        if (await this.matches(singleItem, true)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    if (this.operator === 'or') {\n      return asyncSome(this.operands, c => c.matches(itemToCheck));\n    } else if (this.operator === 'and') {\n      return asyncEvery(this.operands, c => c.matches(itemToCheck));\n    } else if (this.operator === 'not') {\n      if (this.operands.length !== 1) {\n        throw new Error('Invalid arguments! `not()` accepts exactly one predicate expression.');\n      }\n      return !(await this.operands[0].matches(itemToCheck));\n    } else {\n      throw new Error('Invalid group operator!');\n    }\n  }\n  /**\n   * Tranfsorm to a AppSync GraphQL compatible AST.\n   * (Does not support filtering in nested types.)\n   */\n  toAST() {\n    if (this.field) throw new Error('Nested type conditions are not supported!');\n    return {\n      [this.operator]: this.operands.map(operand => operand.toAST())\n    };\n  }\n  /**\n   * Turn this predicate group into something a storage adapter\n   * understands how to use.\n   */\n  toStoragePredicate() {\n    return ModelPredicateCreator.createFromAST(this.model.schema, this.toAST());\n  }\n  /**\n   * A JSON representation that's good for debugging.\n   */\n  toJSON() {\n    return {\n      ...this,\n      model: this.model.schema.name\n    };\n  }\n}\n/**\n * Creates a \"seed\" predicate that can be used to build an executable condition.\n * This is used in `query()`, for example, to seed customer- E.g.,\n *\n * ```\n * const p = predicateFor({builder: modelConstructor, schema: modelSchema, pkField: string[]});\n * p.and(child => [\n *   child.field.eq('whatever'),\n *   child.childModel.childField.eq('whatever else'),\n *   child.childModel.or(child => [\n *     child.otherField.contains('x'),\n *     child.otherField.contains('y'),\n *     child.otherField.contains('z'),\n *   ])\n * ])\n * ```\n *\n * `predicateFor()` returns objecst with recursive getters. To facilitate this,\n * a `query` and `tail` can be provided to \"accumulate\" nested conditions.\n *\n * @param ModelType The ModelMeta used to build child properties.\n * @param field Scopes the query branch to a field.\n * @param query A base query to build on. Omit to start a new query.\n * @param tail The point in an existing `query` to attach new conditions to.\n * @returns A ModelPredicate (builder) that customers can create queries with.\n * (As shown in function description.)\n */\nfunction recursivePredicateFor(ModelType, allowRecursion = true, field, query, tail) {\n  // to be used if we don't have a base query or tail to build onto\n  const starter = new GroupCondition(ModelType, field, undefined, 'and', []);\n  const baseCondition = query && tail ? query : starter;\n  const tailCondition = query && tail ? tail : starter;\n  // our eventual return object, which can be built upon.\n  // next steps will be to add or(), and(), not(), and field.op() methods.\n  const link = {};\n  // so it can be looked up later with in the internals when processing conditions.\n  registerPredicateInternals(baseCondition, link);\n  const copyLink = () => {\n    const [query, newTail] = baseCondition.copy(tailCondition);\n    const newLink = recursivePredicateFor(ModelType, allowRecursion, undefined, query, newTail);\n    return {\n      query,\n      newTail,\n      newLink\n    };\n  };\n  // Adds .or() and .and() methods to the link.\n  // TODO: If revisiting this code, consider writing a Proxy instead.\n  ['and', 'or'].forEach(op => {\n    link[op] = builder => {\n      // or() and and() will return a copy of the original link\n      // to head off mutability concerns.\n      const {\n        query,\n        newTail\n      } = copyLink();\n      const childConditions = builder(recursivePredicateFor(ModelType, allowRecursion));\n      if (!Array.isArray(childConditions)) {\n        throw new Error(`Invalid predicate. \\`${op}\\` groups must return an array of child conditions.`);\n      }\n      // the customer will supply a child predicate, which apply to the `model.field`\n      // of the tail GroupCondition.\n      newTail?.operands.push(new GroupCondition(ModelType, field, undefined, op, childConditions.map(c => internals(c))));\n      // FinalPredicate\n      return registerPredicateInternals(query);\n    };\n  });\n  // TODO: If revisiting this code, consider proxy.\n  link.not = builder => {\n    // not() will return a copy of the original link\n    // to head off mutability concerns.\n    const {\n      query,\n      newTail\n    } = copyLink();\n    // unlike and() and or(), the customer will supply a \"singular\" child predicate.\n    // the difference being: not() does not accept an array of predicate-like objects.\n    // it negates only a *single* predicate subtree.\n    newTail?.operands.push(new GroupCondition(ModelType, field, undefined, 'not', [internals(builder(recursivePredicateFor(ModelType, allowRecursion)))]));\n    // A `FinalModelPredicate`.\n    // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n    // or query storage: `.__query.fetch(storage)`.\n    return registerPredicateInternals(query);\n  };\n  // For each field on the model schema, we want to add a getter\n  // that creates the appropriate new `link` in the query chain.\n  // TODO: If revisiting, consider a proxy.\n  for (const fieldName in ModelType.schema.allFields) {\n    Object.defineProperty(link, fieldName, {\n      enumerable: true,\n      get: () => {\n        const def = ModelType.schema.allFields[fieldName];\n        if (!def.association) {\n          // we're looking at a value field. we need to return a\n          // \"field matcher object\", which contains all of the comparison\n          // functions ('eq', 'ne', 'gt', etc.), scoped to operate\n          // against the target field (fieldName).\n          return ops.reduce((fieldMatcher, operator) => {\n            return {\n              ...fieldMatcher,\n              // each operator on the fieldMatcher objcect is a function.\n              // when the customer calls the function, it returns a new link\n              // in the chain -- for now -- this is the \"leaf\" link that\n              // cannot be further extended.\n              [operator]: (...operands) => {\n                // build off a fresh copy of the existing `link`, just in case\n                // the same link is being used elsewhere by the customer.\n                const {\n                  query,\n                  newTail\n                } = copyLink();\n                // normalize operands. if any of the values are `undefiend`, use\n                // `null` instead, because that's what will be stored cross-platform.\n                const normalizedOperands = operands.map(o => o === undefined ? null : o);\n                // add the given condition to the link's TAIL node.\n                // remember: the base link might go N nodes deep! e.g.,\n                newTail?.operands.push(new FieldCondition(fieldName, operator, normalizedOperands));\n                // A `FinalModelPredicate`.\n                // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n                // or query storage: `.__query.fetch(storage)`.\n                return registerPredicateInternals(query);\n              }\n            };\n          }, {});\n        } else {\n          if (!allowRecursion) {\n            throw new Error('Predication on releated models is not supported in this context.');\n          } else if (def.association.connectionType === 'BELONGS_TO' || def.association.connectionType === 'HAS_ONE' || def.association.connectionType === 'HAS_MANY') {\n            // the use has just typed '.someRelatedModel'. we need to given them\n            // back a predicate chain.\n            const relatedMeta = def.type.modelConstructor;\n            if (!relatedMeta) {\n              throw new Error('Related model metadata is missing. This is a bug! Please report it.');\n            }\n            // `Model.reletedModelField` returns a copy of the original link,\n            // and will contains copies of internal GroupConditions\n            // to head off mutability concerns.\n            const [newquery, oldtail] = baseCondition.copy(tailCondition);\n            const newtail = new GroupCondition(relatedMeta, fieldName, def.association.connectionType, 'and', []);\n            // `oldtail` here refers to the *copy* of the old tail.\n            // so, it's safe to modify at this point. and we need to modify\n            // it to push the *new* tail onto the end of it.\n            oldtail.operands.push(newtail);\n            const newlink = recursivePredicateFor(relatedMeta, allowRecursion, undefined, newquery, newtail);\n            return newlink;\n          } else {\n            throw new Error(\"Related model definition doesn't have a typedef. This is a bug! Please report it.\");\n          }\n        }\n      }\n    });\n  }\n  return link;\n}\nfunction predicateFor(ModelType) {\n  // the cast here is just a cheap way to reduce the surface area from\n  // the recursive type.\n  return recursivePredicateFor(ModelType, false);\n}\nexport { FieldCondition, GroupCondition, internals, predicateFor, recursivePredicateFor };","map":{"version":3,"names":["ops","comparisonKeys","predicateInternalsMap","Map","registerPredicateInternals","condition","key","finalKey","PredicateInternalsKey","set","internals","has","Error","get","negations","and","or","not","eq","ne","gt","ge","lt","le","contains","notContains","FieldCondition","constructor","field","operator","operands","validate","copy","extract","undefined","toAST","negated","model","GroupCondition","fetch","storage","Promise","reject","matches","item","v","operations","indexOf","beginsWith","startsWith","between","operation","result","argumentCount","count","argsClause","length","validations","e","getGroupId","seed","relationshipType","isOptimized","groupId","copied","extractedCopy","forEach","o","operandCopy","extractedFromOperand","push","withFieldConditionsOnly","negate","negateChildren","filter","map","optimized","preserveNode","includes","operand","breadcrumb","resultGroups","groups","op","conditions","g","relatives","relationship","ModelRelationship","from","allJoinConditions","relative","relativeConditions","i","localJoinFields","remoteJoinFields","predicate","ModelPredicateCreator","createFromAST","schema","query","builder","toStoragePredicate","getPKValue","JSON","stringify","pkField","name","resultIndex","group","intersectWith","k","keys","delete","Array","values","ignoreFieldName","itemToCheck","Symbol","asyncIterator","singleItem","asyncSome","c","asyncEvery","toJSON","recursivePredicateFor","ModelType","allowRecursion","tail","starter","baseCondition","tailCondition","link","copyLink","newTail","newLink","childConditions","isArray","fieldName","allFields","Object","defineProperty","enumerable","def","association","reduce","fieldMatcher","normalizedOperands","connectionType","relatedMeta","type","modelConstructor","newquery","oldtail","newtail","newlink","predicateFor"],"sources":["/Users/raphaperso/Documents/Hub/FreeCodeCamp/amplify_notes/node_modules/@aws-amplify/datastore/src/predicates/next.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { PredicateInternalsKey, } from '../types';\nimport { ModelPredicateCreator as FlatModelPredicateCreator, comparisonKeys, } from './index';\nimport { ModelRelationship } from '../storage/relationship';\nimport { asyncSome, asyncEvery } from '../util';\nconst ops = [...comparisonKeys];\n/**\n * A map from keys (exposed to customers) to the internal predicate data\n * structures invoking code should not muck with.\n */\nconst predicateInternalsMap = new Map();\n/**\n * Creates a link between a key (and generates a key if needed) and an internal\n * `GroupCondition`, which allows us to return a key object instead of the gory\n * conditions details to customers/invoking code.\n *\n * @param condition The internal condition to keep hidden.\n * @param key The object DataStore will use to find the internal condition.\n * If no key is given, an empty one is created.\n */\nconst registerPredicateInternals = (condition, key) => {\n    const finalKey = key || new PredicateInternalsKey();\n    predicateInternalsMap.set(finalKey, condition);\n    return finalKey;\n};\n/**\n * Takes a key object from `registerPredicateInternals()` to fetch an internal\n * `GroupCondition` object, which can then be used to query storage or\n * test/match objects.\n *\n * This indirection exists to hide `GroupCondition` from public interfaces, since\n * `GroupCondition` contains extra methods and properties that public callers\n * should not use.\n *\n * @param key A key object previously returned by `registerPredicateInternals()`\n */\nexport const internals = (key) => {\n    if (!predicateInternalsMap.has(key)) {\n        throw new Error(\"Invalid predicate. Terminate your predicate with a valid condition (e.g., `p => p.field.eq('value')`) or pass `Predicates.ALL`.\");\n    }\n    return predicateInternalsMap.get(key);\n};\n/**\n * Maps operators to negated operators.\n * Used to facilitate propagation of negation down a tree of conditions.\n */\nconst negations = {\n    and: 'or',\n    or: 'and',\n    not: 'and',\n    eq: 'ne',\n    ne: 'eq',\n    gt: 'le',\n    ge: 'lt',\n    lt: 'ge',\n    le: 'gt',\n    contains: 'notContains',\n    notContains: 'contains',\n};\n/**\n * A condition that can operate against a single \"primitive\" field of a model or item.\n * @member field The field of *some record* to test against.\n * @member operator The equality or comparison operator to use.\n * @member operands The operands for the equality/comparison check.\n */\nexport class FieldCondition {\n    constructor(field, operator, operands) {\n        this.field = field;\n        this.operator = operator;\n        this.operands = operands;\n        this.validate();\n    }\n    /**\n     * Creates a copy of self.\n     * @param extract Not used. Present only to fulfill the `UntypedCondition` interface.\n     * @returns A new, identitical `FieldCondition`.\n     */\n    copy(extract) {\n        return [\n            new FieldCondition(this.field, this.operator, [...this.operands]),\n            undefined,\n        ];\n    }\n    /**\n     * Produces a tree structure similar to a graphql condition. The returned\n     * structure is \"dumb\" and is intended for another query/condition\n     * generation mechanism to interpret, such as the cloud or storage query\n     * builders.\n     *\n     * E.g.,\n     *\n     * ```json\n     * {\n     * \t\"name\": {\n     * \t\t\"eq\": \"robert\"\n     * \t}\n     * }\n     * ```\n     */\n    toAST() {\n        return {\n            [this.field]: {\n                [this.operator]: this.operator === 'between'\n                    ? [this.operands[0], this.operands[1]]\n                    : this.operands[0],\n            },\n        };\n    }\n    /**\n     * Produces a new condition (`FieldCondition` or `GroupCondition`) that\n     * matches the opposite of this condition.\n     *\n     * Intended to be used when applying De Morgan's Law, which can be done to\n     * produce more efficient queries against the storage layer if a negation\n     * appears in the query tree.\n     *\n     * For example:\n     *\n     * 1. `name.eq('robert')` becomes `name.ne('robert')`\n     * 2. `price.between(100, 200)` becomes `m => m.or(m => [m.price.lt(100), m.price.gt(200)])`\n     *\n     * @param model The model meta to use when construction a new `GroupCondition`\n     * for cases where the negation requires multiple `FieldCondition`'s.\n     */\n    negated(model) {\n        if (this.operator === 'between') {\n            return new GroupCondition(model, undefined, undefined, 'or', [\n                new FieldCondition(this.field, 'lt', [this.operands[0]]),\n                new FieldCondition(this.field, 'gt', [this.operands[1]]),\n            ]);\n        }\n        else if (this.operator === 'beginsWith') {\n            // beginsWith negation doesn't have a good, safe optimation right now.\n            // just re-wrap it in negation. The adapter will have to scan-and-filter,\n            // as is likely optimal for negated beginsWith conditions *anyway*.\n            return new GroupCondition(model, undefined, undefined, 'not', [\n                new FieldCondition(this.field, 'beginsWith', [this.operands[0]]),\n            ]);\n        }\n        else {\n            return new FieldCondition(this.field, negations[this.operator], this.operands);\n        }\n    }\n    /**\n     * Not implemented. Not needed. GroupCondition instead consumes FieldConditions and\n     * transforms them into legacy predicates. (*For now.*)\n     * @param storage N/A. If ever implemented, the storage adapter to query.\n     * @returns N/A. If ever implemented, return items from `storage` that match.\n     */\n    async fetch(storage) {\n        return Promise.reject('No implementation needed [yet].');\n    }\n    /**\n     * Determins whether a given item matches the expressed condition.\n     * @param item The item to test.\n     * @returns `Promise<boolean>`, `true` if matches; `false` otherwise.\n     */\n    async matches(item) {\n        const v = item[this.field];\n        const operations = {\n            eq: () => v === this.operands[0],\n            ne: () => v !== this.operands[0],\n            gt: () => v > this.operands[0],\n            ge: () => v >= this.operands[0],\n            lt: () => v < this.operands[0],\n            le: () => v <= this.operands[0],\n            contains: () => v?.indexOf(this.operands[0]) > -1,\n            notContains: () => (!v ? true : v.indexOf(this.operands[0]) === -1),\n            beginsWith: () => v?.startsWith(this.operands[0]),\n            between: () => v >= this.operands[0] && v <= this.operands[1],\n        };\n        const operation = operations[this.operator];\n        if (operation) {\n            const result = operation();\n            return result;\n        }\n        else {\n            throw new Error(`Invalid operator given: ${this.operator}`);\n        }\n    }\n    /**\n     * Checks `this.operands` for compatibility with `this.operator`.\n     */\n    validate() {\n        /**\n         * Creates a validator that checks for a particular `operands` count.\n         * Throws an exception if the `count` disagrees with `operands.length`.\n         * @param count The number of `operands` expected.\n         */\n        const argumentCount = count => {\n            const argsClause = count === 1 ? 'argument is' : 'arguments are';\n            return () => {\n                if (this.operands.length !== count) {\n                    return `Exactly ${count} ${argsClause} required.`;\n                }\n            };\n        };\n        // NOTE: validations should return a message on failure.\n        // hence, they should be \"joined\" together with logical OR's\n        // as seen in the `between:` entry.\n        const validations = {\n            eq: argumentCount(1),\n            ne: argumentCount(1),\n            gt: argumentCount(1),\n            ge: argumentCount(1),\n            lt: argumentCount(1),\n            le: argumentCount(1),\n            contains: argumentCount(1),\n            notContains: argumentCount(1),\n            beginsWith: argumentCount(1),\n            between: () => argumentCount(2)() ||\n                (this.operands[0] > this.operands[1]\n                    ? 'The first argument must be less than or equal to the second argument.'\n                    : null),\n        };\n        const validate = validations[this.operator];\n        if (validate) {\n            const e = validate();\n            if (typeof e === 'string')\n                throw new Error(`Incorrect usage of \\`${this.operator}()\\`: ${e}`);\n        }\n        else {\n            throw new Error(`Non-existent operator: \\`${this.operator}()\\``);\n        }\n    }\n}\n/**\n * Small utility function to generate a monotonically increasing ID.\n * Used by GroupCondition to help keep track of which group is doing what,\n * when, and where during troubleshooting.\n */\nconst getGroupId = (() => {\n    let seed = 1;\n    return () => `group_${seed++}`;\n})();\n/**\n * A set of sub-conditions to operate against a model, optionally scoped to\n * a specific field, combined with the given operator (one of `and`, `or`, or `not`).\n * @member groupId Used to distinguish between GroupCondition instances for\n * debugging and troublehsooting.\n * @member model A metadata object that tells GroupCondition what to query and how.\n * @member field The field on the model that the sub-conditions apply to.\n * @member operator How to group child conditions together.\n * @member operands The child conditions.\n */\nexport class GroupCondition {\n    constructor(\n    /**\n     * The `ModelMeta` of the model to query and/or filter against.\n     * Expected to contain:\n     *\n     * ```js\n     * {\n     * \tbuilder: ModelConstructor,\n     * \tschema: SchemaModel,\n     * \tpkField: string[]\n     * }\n     * ```\n     */\n    model, \n    /**\n     * If populated, this group specifices a condition on a relationship.\n     *\n     * If `field` does *not* point to a related model, that's an error. It\n     * could indicate that the `GroupCondition` was instantiated with bad\n     * data, or that the model metadata is incorrect.\n     */\n    field, \n    /**\n     * If a `field` is given, whether the relationship is a `HAS_ONE`,\n     * 'HAS_MANY`, or `BELONGS_TO`.\n     *\n     * TODO: Remove this and replace with derivation using\n     * `ModelRelationship.from(this.model, this.field).relationship`;\n     */\n    relationshipType, \n    /**\n     *\n     */\n    operator, \n    /**\n     *\n     */\n    operands, \n    /**\n     * Whether this GroupCondition is the result of an optimize call.\n     *\n     * This is used to guard against infinitely fetch -> optimize -> fetch\n     * recursion.\n     */\n    isOptimized = false) {\n        this.model = model;\n        this.field = field;\n        this.relationshipType = relationshipType;\n        this.operator = operator;\n        this.operands = operands;\n        this.isOptimized = isOptimized;\n        // `groupId` was used for development/debugging.\n        // Should we leave this in for future troubleshooting?\n        this.groupId = getGroupId();\n    }\n    /**\n     * Returns a copy of a GroupCondition, which also returns the copy of a\n     * given reference node to \"extract\".\n     * @param extract A node of interest. Its copy will *also* be returned if the node exists.\n     * @returns [The full copy, the copy of `extract` | undefined]\n     */\n    copy(extract) {\n        const copied = new GroupCondition(this.model, this.field, this.relationshipType, this.operator, []);\n        let extractedCopy = extract === this ? copied : undefined;\n        this.operands.forEach(o => {\n            const [operandCopy, extractedFromOperand] = o.copy(extract);\n            copied.operands.push(operandCopy);\n            extractedCopy = extractedCopy || extractedFromOperand;\n        });\n        return [copied, extractedCopy];\n    }\n    /**\n     * Creates a new `GroupCondition` that contains only the local field conditions,\n     * omitting related model conditions. That resulting `GroupCondition` can be\n     * used to produce predicates that are compatible with the storage adapters and\n     * Cloud storage.\n     *\n     * @param negate Whether the condition tree should be negated according\n     * to De Morgan's law.\n     */\n    withFieldConditionsOnly(negate) {\n        const negateChildren = negate !== (this.operator === 'not');\n        return new GroupCondition(this.model, undefined, undefined, (negate ? negations[this.operator] : this.operator), this.operands\n            .filter(o => o instanceof FieldCondition)\n            .map(o => negateChildren ? o.negated(this.model) : o));\n    }\n    /**\n     * Returns a version of the predicate tree with unnecessary logical groups\n     * condensed and merged together. This is intended to create a dense tree\n     * with leaf nodes (`FieldCondition`'s) aggregated under as few group conditions\n     * as possible for the most efficient fetching possible -- it allows `fetch()`.\n     *\n     * E.g. a grouping like this:\n     *\n     * ```yaml\n     * and:\n     * \tand:\n     * \t\tid:\n     * \t\t\teq: \"abc\"\n     * \tand:\n     * \t\tname:\n     * \t\t\teq: \"xyz\"\n     * ```\n     *\n     * Will become this:\n     *\n     * ```yaml\n     * and:\n     * \tid:\n     * \t\teq: \"abc\"\n     * \tname:\n     * \t\teq: \"xyz\"\n     * ```\n     *\n     * This allows `fetch()` to pass both the `id` and `name` conditions to the adapter\n     * together, which can then decide what index to use based on both fields together.\n     *\n     * @param preserveNode Whether to preserve the current node and to explicitly not eliminate\n     * it during optimization. Used internally to preserve the root node and children of\n     * `not` groups. `not` groups will always have a single child, so there's nothing to\n     * optimize below a `not` (for now), and it makes the query logic simpler later.\n     */\n    optimized(preserveNode = true) {\n        const operands = this.operands.map(o => o instanceof GroupCondition ? o.optimized(this.operator === 'not') : o);\n        // we're only collapsing and/or groups that contains a single child for now,\n        // because they're much more common and much more trivial to collapse. basically,\n        // an `and`/`or` that contains a single child doesn't require the layer of\n        // logical grouping.\n        if (!preserveNode &&\n            ['and', 'or'].includes(this.operator) &&\n            !this.field &&\n            operands.length === 1) {\n            const operand = operands[0];\n            if (operand instanceof FieldCondition) {\n                // between conditions should NOT be passed up the chain. if they\n                // need to be *negated* later, it is important that they be properly\n                // contained in an AND group. when de morgan's law is applied, the\n                // conditions are reversed and the AND group flips to an OR. this\n                // doesn't work right if the a `between` doesn't live in an AND group.\n                if (operand.operator !== 'between') {\n                    return operand;\n                }\n            }\n            else {\n                return operand;\n            }\n        }\n        return new GroupCondition(this.model, this.field, this.relationshipType, this.operator, operands, true);\n    }\n    /**\n     * Fetches matching records from a given storage adapter using legacy predicates (for now).\n     * @param storage The storage adapter this predicate will query against.\n     * @param breadcrumb For debugging/troubleshooting. A list of the `groupId`'s this\n     * GroupdCondition.fetch is nested within.\n     * @param negate Whether to match on the `NOT` of `this`.\n     * @returns An `Promise` of `any[]` from `storage` matching the child conditions.\n     */\n    async fetch(storage, breadcrumb = [], negate = false) {\n        if (!this.isOptimized) {\n            return this.optimized().fetch(storage);\n        }\n        const resultGroups = [];\n        const operator = (negate ? negations[this.operator] : this.operator);\n        const negateChildren = negate !== (this.operator === 'not');\n        /**\n         * Conditions that must be branched out and used to generate a base, \"candidate\"\n         * result set.\n         *\n         * If `field` is populated, these groups select *related* records, and the base,\n         * candidate results are selected to match those.\n         */\n        const groups = this.operands.filter(op => op instanceof GroupCondition);\n        /**\n         * Simple conditions that must match the target model of `this`.\n         */\n        const conditions = this.operands.filter(op => op instanceof FieldCondition);\n        for (const g of groups) {\n            const relatives = await g.fetch(storage, [...breadcrumb, this.groupId], negateChildren);\n            // no relatives -> no need to attempt to perform a \"join\" query for\n            // candidate results:\n            //\n            // select a.* from a,b where b.id in EMPTY_SET ==> EMPTY_SET\n            //\n            // Additionally, the entire (sub)-query can be short-circuited if\n            // the operator is `AND`. Illustrated in SQL:\n            //\n            // select a.* from a where\n            //   id in [a,b,c]\n            //     AND                        <\n            //   id in EMTPY_SET            <<< Look!\n            //     AND                        <\n            //   id in [x,y,z]\n            //\n            // YIELDS: EMPTY_SET           // <-- Easy peasy. Lemon squeezy.\n            //\n            if (relatives.length === 0) {\n                // aggressively short-circuit as soon as we know the group condition will fail\n                if (operator === 'and') {\n                    return [];\n                }\n                // less aggressive short-circuit if we know the relatives will produce no\n                // candidate results; but aren't sure yet how this affects the group condition.\n                resultGroups.push([]);\n                continue;\n            }\n            if (g.field) {\n                // `relatives` are actual relatives. We'll skim them for FK query values.\n                // Use the relatives to add candidate result sets (`resultGroups`)\n                const relationship = ModelRelationship.from(this.model, g.field);\n                if (relationship) {\n                    const allJoinConditions = [];\n                    for (const relative of relatives) {\n                        const relativeConditions = [];\n                        for (let i = 0; i < relationship.localJoinFields.length; i++) {\n                            relativeConditions.push({\n                                [relationship.localJoinFields[i]]: {\n                                    eq: relative[relationship.remoteJoinFields[i]],\n                                },\n                            });\n                        }\n                        allJoinConditions.push({ and: relativeConditions });\n                    }\n                    const predicate = FlatModelPredicateCreator.createFromAST(this.model.schema, {\n                        or: allJoinConditions,\n                    });\n                    resultGroups.push(await storage.query(this.model.builder, predicate));\n                }\n                else {\n                    throw new Error('Missing field metadata.');\n                }\n            }\n            else {\n                // relatives are not actually relatives. they're candidate results.\n                resultGroups.push(relatives);\n            }\n        }\n        // if conditions is empty at this point, child predicates found no matches.\n        // i.e., we can stop looking and return empty.\n        if (conditions.length > 0) {\n            const predicate = this.withFieldConditionsOnly(negateChildren).toStoragePredicate();\n            resultGroups.push(await storage.query(this.model.builder, predicate));\n        }\n        else if (conditions.length === 0 && resultGroups.length === 0) {\n            resultGroups.push(await storage.query(this.model.builder));\n        }\n        // PK might be a single field, like `id`, or it might be several fields.\n        // so, we'll need to extract the list of PK fields from an object\n        // and stringify the list for easy comparison / merging.\n        const getPKValue = item => JSON.stringify(this.model.pkField.map(name => item[name]));\n        // will be used for intersecting or unioning results\n        let resultIndex;\n        if (operator === 'and') {\n            if (resultGroups.length === 0) {\n                return [];\n            }\n            // for each group, we intersect, removing items from the result index\n            // that aren't present in each subsequent group.\n            for (const group of resultGroups) {\n                if (resultIndex === undefined) {\n                    resultIndex = new Map(group.map(item => [getPKValue(item), item]));\n                }\n                else {\n                    const intersectWith = new Map(group.map(item => [getPKValue(item), item]));\n                    for (const k of resultIndex.keys()) {\n                        if (!intersectWith.has(k)) {\n                            resultIndex.delete(k);\n                        }\n                    }\n                }\n            }\n        }\n        else if (operator === 'or' || operator === 'not') {\n            // it's OK to handle NOT here, because NOT must always only negate\n            // a single child predicate. NOT logic will have been distributed down\n            // to the leaf conditions already.\n            resultIndex = new Map();\n            // just merge the groups, performing DISTINCT-ification by ID.\n            for (const group of resultGroups) {\n                for (const item of group) {\n                    resultIndex.set(getPKValue(item), item);\n                }\n            }\n        }\n        return Array.from(resultIndex?.values() || []);\n    }\n    /**\n     * Determines whether a single item matches the conditions of `this`.\n     * When checking the target `item`'s properties, each property will be `await`'d\n     * to ensure lazy-loading is respected where applicable.\n     * @param item The item to match against.\n     * @param ignoreFieldName Tells `match()` that the field name has already been dereferenced.\n     * (Used for iterating over children on HAS_MANY checks.)\n     * @returns A boolean (promise): `true` if matched, `false` otherwise.\n     */\n    async matches(item, ignoreFieldName = false) {\n        const itemToCheck = this.field && !ignoreFieldName ? await item[this.field] : item;\n        // if there is no item to check, we can stop recursing immediately.\n        // a condition cannot match against an item that does not exist. this\n        // can occur when `item.field` is optional in the schema.\n        if (!itemToCheck) {\n            return false;\n        }\n        if (this.relationshipType === 'HAS_MANY' &&\n            typeof itemToCheck[Symbol.asyncIterator] === 'function') {\n            for await (const singleItem of itemToCheck) {\n                if (await this.matches(singleItem, true)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (this.operator === 'or') {\n            return asyncSome(this.operands, c => c.matches(itemToCheck));\n        }\n        else if (this.operator === 'and') {\n            return asyncEvery(this.operands, c => c.matches(itemToCheck));\n        }\n        else if (this.operator === 'not') {\n            if (this.operands.length !== 1) {\n                throw new Error('Invalid arguments! `not()` accepts exactly one predicate expression.');\n            }\n            return !(await this.operands[0].matches(itemToCheck));\n        }\n        else {\n            throw new Error('Invalid group operator!');\n        }\n    }\n    /**\n     * Tranfsorm to a AppSync GraphQL compatible AST.\n     * (Does not support filtering in nested types.)\n     */\n    toAST() {\n        if (this.field)\n            throw new Error('Nested type conditions are not supported!');\n        return {\n            [this.operator]: this.operands.map(operand => operand.toAST()),\n        };\n    }\n    /**\n     * Turn this predicate group into something a storage adapter\n     * understands how to use.\n     */\n    toStoragePredicate() {\n        return FlatModelPredicateCreator.createFromAST(this.model.schema, this.toAST());\n    }\n    /**\n     * A JSON representation that's good for debugging.\n     */\n    toJSON() {\n        return {\n            ...this,\n            model: this.model.schema.name,\n        };\n    }\n}\n/**\n * Creates a \"seed\" predicate that can be used to build an executable condition.\n * This is used in `query()`, for example, to seed customer- E.g.,\n *\n * ```\n * const p = predicateFor({builder: modelConstructor, schema: modelSchema, pkField: string[]});\n * p.and(child => [\n *   child.field.eq('whatever'),\n *   child.childModel.childField.eq('whatever else'),\n *   child.childModel.or(child => [\n *     child.otherField.contains('x'),\n *     child.otherField.contains('y'),\n *     child.otherField.contains('z'),\n *   ])\n * ])\n * ```\n *\n * `predicateFor()` returns objecst with recursive getters. To facilitate this,\n * a `query` and `tail` can be provided to \"accumulate\" nested conditions.\n *\n * @param ModelType The ModelMeta used to build child properties.\n * @param field Scopes the query branch to a field.\n * @param query A base query to build on. Omit to start a new query.\n * @param tail The point in an existing `query` to attach new conditions to.\n * @returns A ModelPredicate (builder) that customers can create queries with.\n * (As shown in function description.)\n */\nexport function recursivePredicateFor(ModelType, allowRecursion = true, field, query, tail) {\n    // to be used if we don't have a base query or tail to build onto\n    const starter = new GroupCondition(ModelType, field, undefined, 'and', []);\n    const baseCondition = query && tail ? query : starter;\n    const tailCondition = query && tail ? tail : starter;\n    // our eventual return object, which can be built upon.\n    // next steps will be to add or(), and(), not(), and field.op() methods.\n    const link = {};\n    // so it can be looked up later with in the internals when processing conditions.\n    registerPredicateInternals(baseCondition, link);\n    const copyLink = () => {\n        const [query, newTail] = baseCondition.copy(tailCondition);\n        const newLink = recursivePredicateFor(ModelType, allowRecursion, undefined, query, newTail);\n        return { query, newTail, newLink };\n    };\n    // Adds .or() and .and() methods to the link.\n    // TODO: If revisiting this code, consider writing a Proxy instead.\n    ['and', 'or'].forEach(op => {\n        link[op] = (builder) => {\n            // or() and and() will return a copy of the original link\n            // to head off mutability concerns.\n            const { query, newTail } = copyLink();\n            const childConditions = builder(recursivePredicateFor(ModelType, allowRecursion));\n            if (!Array.isArray(childConditions)) {\n                throw new Error(`Invalid predicate. \\`${op}\\` groups must return an array of child conditions.`);\n            }\n            // the customer will supply a child predicate, which apply to the `model.field`\n            // of the tail GroupCondition.\n            newTail?.operands.push(new GroupCondition(ModelType, field, undefined, op, childConditions.map(c => internals(c))));\n            // FinalPredicate\n            return registerPredicateInternals(query);\n        };\n    });\n    // TODO: If revisiting this code, consider proxy.\n    link.not = (builder) => {\n        // not() will return a copy of the original link\n        // to head off mutability concerns.\n        const { query, newTail } = copyLink();\n        // unlike and() and or(), the customer will supply a \"singular\" child predicate.\n        // the difference being: not() does not accept an array of predicate-like objects.\n        // it negates only a *single* predicate subtree.\n        newTail?.operands.push(new GroupCondition(ModelType, field, undefined, 'not', [\n            internals(builder(recursivePredicateFor(ModelType, allowRecursion))),\n        ]));\n        // A `FinalModelPredicate`.\n        // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n        // or query storage: `.__query.fetch(storage)`.\n        return registerPredicateInternals(query);\n    };\n    // For each field on the model schema, we want to add a getter\n    // that creates the appropriate new `link` in the query chain.\n    // TODO: If revisiting, consider a proxy.\n    for (const fieldName in ModelType.schema.allFields) {\n        Object.defineProperty(link, fieldName, {\n            enumerable: true,\n            get: () => {\n                const def = ModelType.schema.allFields[fieldName];\n                if (!def.association) {\n                    // we're looking at a value field. we need to return a\n                    // \"field matcher object\", which contains all of the comparison\n                    // functions ('eq', 'ne', 'gt', etc.), scoped to operate\n                    // against the target field (fieldName).\n                    return ops.reduce((fieldMatcher, operator) => {\n                        return {\n                            ...fieldMatcher,\n                            // each operator on the fieldMatcher objcect is a function.\n                            // when the customer calls the function, it returns a new link\n                            // in the chain -- for now -- this is the \"leaf\" link that\n                            // cannot be further extended.\n                            [operator]: (...operands) => {\n                                // build off a fresh copy of the existing `link`, just in case\n                                // the same link is being used elsewhere by the customer.\n                                const { query, newTail } = copyLink();\n                                // normalize operands. if any of the values are `undefiend`, use\n                                // `null` instead, because that's what will be stored cross-platform.\n                                const normalizedOperands = operands.map(o => o === undefined ? null : o);\n                                // add the given condition to the link's TAIL node.\n                                // remember: the base link might go N nodes deep! e.g.,\n                                newTail?.operands.push(new FieldCondition(fieldName, operator, normalizedOperands));\n                                // A `FinalModelPredicate`.\n                                // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n                                // or query storage: `.__query.fetch(storage)`.\n                                return registerPredicateInternals(query);\n                            },\n                        };\n                    }, {});\n                }\n                else {\n                    if (!allowRecursion) {\n                        throw new Error('Predication on releated models is not supported in this context.');\n                    }\n                    else if (def.association.connectionType === 'BELONGS_TO' ||\n                        def.association.connectionType === 'HAS_ONE' ||\n                        def.association.connectionType === 'HAS_MANY') {\n                        // the use has just typed '.someRelatedModel'. we need to given them\n                        // back a predicate chain.\n                        const relatedMeta = def.type.modelConstructor;\n                        if (!relatedMeta) {\n                            throw new Error('Related model metadata is missing. This is a bug! Please report it.');\n                        }\n                        // `Model.reletedModelField` returns a copy of the original link,\n                        // and will contains copies of internal GroupConditions\n                        // to head off mutability concerns.\n                        const [newquery, oldtail] = baseCondition.copy(tailCondition);\n                        const newtail = new GroupCondition(relatedMeta, fieldName, def.association.connectionType, 'and', []);\n                        // `oldtail` here refers to the *copy* of the old tail.\n                        // so, it's safe to modify at this point. and we need to modify\n                        // it to push the *new* tail onto the end of it.\n                        oldtail.operands.push(newtail);\n                        const newlink = recursivePredicateFor(relatedMeta, allowRecursion, undefined, newquery, newtail);\n                        return newlink;\n                    }\n                    else {\n                        throw new Error(\"Related model definition doesn't have a typedef. This is a bug! Please report it.\");\n                    }\n                }\n            },\n        });\n    }\n    return link;\n}\nexport function predicateFor(ModelType) {\n    // the cast here is just a cheap way to reduce the surface area from\n    // the recursive type.\n    return recursivePredicateFor(ModelType, false);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}