{"ast":null,"code":"import { isFieldAssociation } from '../types.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Defines a relationship from a LOCAL model.field to a REMOTE model.field and helps\n * navigate the relationship, providing a simplified peek at the relationship details\n * pertinent to setting FK's and constructing join conditions.\n *\n * Because I mean, relationships are tough.\n *\n */\nclass ModelRelationship {\n  /**\n   * @param modelDefinition The \"local\" model.\n   * @param field The \"local\" model field.\n   */\n  constructor(model, field) {\n    if (!isFieldAssociation(model.schema, field)) {\n      throw new Error(`${model.schema.name}.${field} is not a relationship.`);\n    }\n    this.localModel = model;\n    this._field = field;\n  }\n  /**\n   * Returns a ModelRelationship for the the given model and field if the pair\n   * indicates a relationship to another model. Else, returns `null`.\n   *\n   * @param model The model the relationship field exists in.\n   * @param field The field that may relates the local model to the remote model.\n   */\n  static from(model, field) {\n    if (isFieldAssociation(model.schema, field)) {\n      return new this(model, field);\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Enumerates all valid `ModelRelationship`'s on the given model.\n   *\n   * @param model The model definition to enumerate relationships of.\n   */\n  static allFrom(model) {\n    const relationships = [];\n    for (const field of Object.keys(model.schema.fields)) {\n      const relationship = ModelRelationship.from(model, field);\n      relationship && relationships.push(relationship);\n    }\n    return relationships;\n  }\n  get localDefinition() {\n    return this.localModel.schema;\n  }\n  /**\n   * The virtual/computed field on the local model that should contain\n   * the related model.\n   */\n  get field() {\n    return this._field;\n  }\n  /**\n   * The constructor that can be used to query DataStore or create instance for\n   * the local model.\n   */\n  get localConstructor() {\n    return this.localModel.builder;\n  }\n  /**\n   * The name/type of the relationship the local model has with the remote model\n   * via the defined local model field.\n   */\n  get type() {\n    return this.localAssocation.connectionType;\n  }\n  /**\n   * Raw details about the local FK as-is from the local model's field definition in\n   * the schema. This field requires interpretation.\n   *\n   * @see localJoinFields\n   * @see localAssociatedWith\n   */\n  get localAssocation() {\n    return this.localDefinition.fields[this.field].association;\n  }\n  /**\n   * The field names on the local model that can be used to query or queried to match\n   * with instances of the remote model.\n   *\n   * Fields are returned in-order to match the order of `this.remoteKeyFields`.\n   */\n  get localJoinFields() {\n    /**\n     * This is relatively straightforward, actually.\n     *\n     * If we have explicitly stated targetNames, codegen is telling us authoritatively\n     * to use those fields for this relationship. The local model \"points to\" fields\n     * in the remote one.\n     *\n     * In other cases, the remote model points to this one's\n     */\n    if (this.localAssocation.targetName) {\n      // This case is theoretically unnecessary going forward.\n      return [this.localAssocation.targetName];\n    } else if (this.localAssocation.targetNames) {\n      return this.localAssocation.targetNames;\n    } else {\n      return this.localPKFields;\n    }\n  }\n  /**\n   * The field names on the local model that uniquely identify it.\n   *\n   * These fields may or may not be relevant to the join fields.\n   */\n  get localPKFields() {\n    return this.localModel.pkField;\n  }\n  get remoteDefinition() {\n    return this.remoteModelType.modelConstructor?.schema;\n  }\n  get remoteModelType() {\n    return this.localDefinition.fields[this.field].type;\n  }\n  /**\n   * Constructor that can be used to query DataStore or create instances for\n   * the remote model.\n   */\n  get remoteModelConstructor() {\n    return this.remoteModelType.modelConstructor.builder;\n  }\n  /**\n   * The field names on the remote model that uniquely identify it.\n   *\n   * These fields may or may not be relevant to the join fields.\n   */\n  get remotePKFields() {\n    return this.remoteModelType.modelConstructor?.pkField || ['id'];\n  }\n  /**\n   * The `associatedWith` fields from the local perspective.\n   *\n   * When present, these fields indicate which fields on the remote model to use\n   * when looking for a remote association and/or determining the final remote\n   * key fields.\n   */\n  get localAssociatedWith() {\n    if (this.localAssocation.connectionType === 'HAS_MANY' || this.localAssocation.connectionType === 'HAS_ONE') {\n      // This de-arraying is theoretically unnecessary going forward.\n      return Array.isArray(this.localAssocation.associatedWith) ? this.localAssocation.associatedWith : [this.localAssocation.associatedWith];\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * The `remote` model's associated field's `assocation` metadata, if\n   * present.\n   *\n   * This is used when determining if the remote model's associated field\n   * specifies which FK fields to use. If this value is `undefined`, the\n   * name of the remote field (`this.localAssociatedWith`) *is* the remote\n   * key field.\n   */\n  get explicitRemoteAssociation() {\n    if (this.localAssociatedWith) {\n      if (this.localAssociatedWith.length === 1) {\n        return this.remoteDefinition.fields[this.localAssociatedWith[0]]?.association;\n      } else {\n        return undefined;\n      }\n    }\n  }\n  /**\n   * The field names on the remote model that can used to query or queried to match\n   * with instances of the local model.\n   *\n   * Fields are returned in-order to match the order of `this.localKeyFields`.\n   */\n  get remoteJoinFields() {\n    /**\n     * If the local relationship explicitly names \"associated with\" fields, we\n     * need to see if this points direction to a reciprocating assocation. If it\n     * does, the remote assocation indicates what fields to use.\n     */\n    if (this.explicitRemoteAssociation?.targetName) {\n      // This case is theoretically unnecessary going forward.\n      return [this.explicitRemoteAssociation.targetName];\n    } else if (this.explicitRemoteAssociation?.targetNames) {\n      return this.explicitRemoteAssociation?.targetNames;\n    } else if (this.localAssociatedWith) {\n      return this.localAssociatedWith;\n    } else {\n      return this.remotePKFields;\n    }\n  }\n  /**\n   * Whether this relationship everything necessary to get, set, and query from\n   * the perspective of the local model provided at instantiation.\n   */\n  get isComplete() {\n    return this.localJoinFields.length > 0 && this.remoteJoinFields.length > 0;\n  }\n  /**\n   * Creates an FK mapper object with respect to the given related instance.\n   *\n   * E.g., if the local FK fields are `[parentId, parentName]` and point to\n   * `[customId, name]` on the remote model, `createLocalFKObject(remote)`\n   * will return:\n   *\n   * ```\n   * {\n   * \tparentId: remote.customId,\n   * \tparentName: remote.name\n   * }\n   * ```\n   *\n   * @param remote The remote related instance.\n   */\n  createLocalFKObject(remote) {\n    const fk = {};\n    for (let i = 0; i < this.localJoinFields.length; i++) {\n      fk[this.localJoinFields[i]] = remote[this.remoteJoinFields[i]];\n    }\n    return fk;\n  }\n  /**\n   * Creates an query mapper object to help fetch the remote instance(s) or\n   * `null` if any of the necessary local fields are `null` or `undefined`.\n   *\n   * E.g., if the local FK fields are `[parentId, parentName]` and point to\n   * `[customId, name]` on the remote model, `createLocalFKObject(remote)`\n   * will return:\n   *\n   * ```\n   * {\n   * \tcustomId: local.parentId\n   * \tname: local.parentName\n   * }\n   * ```\n   *\n   * If the local fields are not populated, returns\n   *\n   * @param local The local instance.\n   */\n  createRemoteQueryObject(local) {\n    const query = {};\n    for (let i = 0; i < this.remoteJoinFields.length; i++) {\n      const localValue = local[this.localJoinFields[i]];\n      if (localValue === null || localValue === undefined) return null;\n      query[this.remoteJoinFields[i]] = local[this.localJoinFields[i]];\n    }\n    return query;\n  }\n}\nexport { ModelRelationship };","map":{"version":3,"names":["ModelRelationship","constructor","model","field","isFieldAssociation","schema","Error","name","localModel","_field","from","allFrom","relationships","Object","keys","fields","relationship","push","localDefinition","localConstructor","builder","type","localAssocation","connectionType","association","localJoinFields","targetName","targetNames","localPKFields","pkField","remoteDefinition","remoteModelType","modelConstructor","remoteModelConstructor","remotePKFields","localAssociatedWith","Array","isArray","associatedWith","undefined","explicitRemoteAssociation","length","remoteJoinFields","isComplete","createLocalFKObject","remote","fk","i","createRemoteQueryObject","local","query","localValue"],"sources":["/Users/raphaperso/Documents/Hub/FreeCodeCamp/amplify_notes/node_modules/@aws-amplify/datastore/src/storage/relationship.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { isFieldAssociation } from '../types';\n/**\n * Defines a relationship from a LOCAL model.field to a REMOTE model.field and helps\n * navigate the relationship, providing a simplified peek at the relationship details\n * pertinent to setting FK's and constructing join conditions.\n *\n * Because I mean, relationships are tough.\n *\n */\nexport class ModelRelationship {\n    /**\n     * @param modelDefinition The \"local\" model.\n     * @param field The \"local\" model field.\n     */\n    constructor(model, field) {\n        if (!isFieldAssociation(model.schema, field)) {\n            throw new Error(`${model.schema.name}.${field} is not a relationship.`);\n        }\n        this.localModel = model;\n        this._field = field;\n    }\n    /**\n     * Returns a ModelRelationship for the the given model and field if the pair\n     * indicates a relationship to another model. Else, returns `null`.\n     *\n     * @param model The model the relationship field exists in.\n     * @param field The field that may relates the local model to the remote model.\n     */\n    static from(model, field) {\n        if (isFieldAssociation(model.schema, field)) {\n            return new this(model, field);\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Enumerates all valid `ModelRelationship`'s on the given model.\n     *\n     * @param model The model definition to enumerate relationships of.\n     */\n    static allFrom(model) {\n        const relationships = [];\n        for (const field of Object.keys(model.schema.fields)) {\n            const relationship = ModelRelationship.from(model, field);\n            relationship && relationships.push(relationship);\n        }\n        return relationships;\n    }\n    get localDefinition() {\n        return this.localModel.schema;\n    }\n    /**\n     * The virtual/computed field on the local model that should contain\n     * the related model.\n     */\n    get field() {\n        return this._field;\n    }\n    /**\n     * The constructor that can be used to query DataStore or create instance for\n     * the local model.\n     */\n    get localConstructor() {\n        return this.localModel.builder;\n    }\n    /**\n     * The name/type of the relationship the local model has with the remote model\n     * via the defined local model field.\n     */\n    get type() {\n        return this.localAssocation.connectionType;\n    }\n    /**\n     * Raw details about the local FK as-is from the local model's field definition in\n     * the schema. This field requires interpretation.\n     *\n     * @see localJoinFields\n     * @see localAssociatedWith\n     */\n    get localAssocation() {\n        return this.localDefinition.fields[this.field].association;\n    }\n    /**\n     * The field names on the local model that can be used to query or queried to match\n     * with instances of the remote model.\n     *\n     * Fields are returned in-order to match the order of `this.remoteKeyFields`.\n     */\n    get localJoinFields() {\n        /**\n         * This is relatively straightforward, actually.\n         *\n         * If we have explicitly stated targetNames, codegen is telling us authoritatively\n         * to use those fields for this relationship. The local model \"points to\" fields\n         * in the remote one.\n         *\n         * In other cases, the remote model points to this one's\n         */\n        if (this.localAssocation.targetName) {\n            // This case is theoretically unnecessary going forward.\n            return [this.localAssocation.targetName];\n        }\n        else if (this.localAssocation.targetNames) {\n            return this.localAssocation.targetNames;\n        }\n        else {\n            return this.localPKFields;\n        }\n    }\n    /**\n     * The field names on the local model that uniquely identify it.\n     *\n     * These fields may or may not be relevant to the join fields.\n     */\n    get localPKFields() {\n        return this.localModel.pkField;\n    }\n    get remoteDefinition() {\n        return this.remoteModelType.modelConstructor?.schema;\n    }\n    get remoteModelType() {\n        return this.localDefinition.fields[this.field].type;\n    }\n    /**\n     * Constructor that can be used to query DataStore or create instances for\n     * the remote model.\n     */\n    get remoteModelConstructor() {\n        return this.remoteModelType.modelConstructor.builder;\n    }\n    /**\n     * The field names on the remote model that uniquely identify it.\n     *\n     * These fields may or may not be relevant to the join fields.\n     */\n    get remotePKFields() {\n        return this.remoteModelType.modelConstructor?.pkField || ['id'];\n    }\n    /**\n     * The `associatedWith` fields from the local perspective.\n     *\n     * When present, these fields indicate which fields on the remote model to use\n     * when looking for a remote association and/or determining the final remote\n     * key fields.\n     */\n    get localAssociatedWith() {\n        if (this.localAssocation.connectionType === 'HAS_MANY' ||\n            this.localAssocation.connectionType === 'HAS_ONE') {\n            // This de-arraying is theoretically unnecessary going forward.\n            return Array.isArray(this.localAssocation.associatedWith)\n                ? this.localAssocation.associatedWith\n                : [this.localAssocation.associatedWith];\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * The `remote` model's associated field's `assocation` metadata, if\n     * present.\n     *\n     * This is used when determining if the remote model's associated field\n     * specifies which FK fields to use. If this value is `undefined`, the\n     * name of the remote field (`this.localAssociatedWith`) *is* the remote\n     * key field.\n     */\n    get explicitRemoteAssociation() {\n        if (this.localAssociatedWith) {\n            if (this.localAssociatedWith.length === 1) {\n                return this.remoteDefinition.fields[this.localAssociatedWith[0]]\n                    ?.association;\n            }\n            else {\n                return undefined;\n            }\n        }\n    }\n    /**\n     * The field names on the remote model that can used to query or queried to match\n     * with instances of the local model.\n     *\n     * Fields are returned in-order to match the order of `this.localKeyFields`.\n     */\n    get remoteJoinFields() {\n        /**\n         * If the local relationship explicitly names \"associated with\" fields, we\n         * need to see if this points direction to a reciprocating assocation. If it\n         * does, the remote assocation indicates what fields to use.\n         */\n        if (this.explicitRemoteAssociation?.targetName) {\n            // This case is theoretically unnecessary going forward.\n            return [this.explicitRemoteAssociation.targetName];\n        }\n        else if (this.explicitRemoteAssociation?.targetNames) {\n            return this.explicitRemoteAssociation?.targetNames;\n        }\n        else if (this.localAssociatedWith) {\n            return this.localAssociatedWith;\n        }\n        else {\n            return this.remotePKFields;\n        }\n    }\n    /**\n     * Whether this relationship everything necessary to get, set, and query from\n     * the perspective of the local model provided at instantiation.\n     */\n    get isComplete() {\n        return this.localJoinFields.length > 0 && this.remoteJoinFields.length > 0;\n    }\n    /**\n     * Creates an FK mapper object with respect to the given related instance.\n     *\n     * E.g., if the local FK fields are `[parentId, parentName]` and point to\n     * `[customId, name]` on the remote model, `createLocalFKObject(remote)`\n     * will return:\n     *\n     * ```\n     * {\n     * \tparentId: remote.customId,\n     * \tparentName: remote.name\n     * }\n     * ```\n     *\n     * @param remote The remote related instance.\n     */\n    createLocalFKObject(remote) {\n        const fk = {};\n        for (let i = 0; i < this.localJoinFields.length; i++) {\n            fk[this.localJoinFields[i]] = remote[this.remoteJoinFields[i]];\n        }\n        return fk;\n    }\n    /**\n     * Creates an query mapper object to help fetch the remote instance(s) or\n     * `null` if any of the necessary local fields are `null` or `undefined`.\n     *\n     * E.g., if the local FK fields are `[parentId, parentName]` and point to\n     * `[customId, name]` on the remote model, `createLocalFKObject(remote)`\n     * will return:\n     *\n     * ```\n     * {\n     * \tcustomId: local.parentId\n     * \tname: local.parentName\n     * }\n     * ```\n     *\n     * If the local fields are not populated, returns\n     *\n     * @param local The local instance.\n     */\n    createRemoteQueryObject(local) {\n        const query = {};\n        for (let i = 0; i < this.remoteJoinFields.length; i++) {\n            const localValue = local[this.localJoinFields[i]];\n            if (localValue === null || localValue === undefined)\n                return null;\n            query[this.remoteJoinFields[i]] = local[this.localJoinFields[i]];\n        }\n        return query;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}