{"ast":null,"code":"import { GraphQLAuthError } from '@aws-amplify/api';\nimport { isSchemaModel, isSchemaModelWithAttributes, isGraphQLScalarType, isEnumFieldType, isTargetNameAssociation, isNonModelFieldType, OpType, isPredicateObj, isPredicateGroup, ModelOperation } from '../types.mjs';\nimport { establishRelationAndKeys, extractPrimaryKeyFieldNames, IDENTIFIER_KEY_SEPARATOR } from '../util.mjs';\nimport { ConsoleLogger } from '@aws-amplify/core';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('DataStore');\nvar GraphQLOperationType;\n(function (GraphQLOperationType) {\n  GraphQLOperationType[\"LIST\"] = \"query\";\n  GraphQLOperationType[\"CREATE\"] = \"mutation\";\n  GraphQLOperationType[\"UPDATE\"] = \"mutation\";\n  GraphQLOperationType[\"DELETE\"] = \"mutation\";\n  GraphQLOperationType[\"GET\"] = \"query\";\n})(GraphQLOperationType || (GraphQLOperationType = {}));\nvar TransformerMutationType;\n(function (TransformerMutationType) {\n  TransformerMutationType[\"CREATE\"] = \"Create\";\n  TransformerMutationType[\"UPDATE\"] = \"Update\";\n  TransformerMutationType[\"DELETE\"] = \"Delete\";\n  TransformerMutationType[\"GET\"] = \"Get\";\n})(TransformerMutationType || (TransformerMutationType = {}));\nconst dummyMetadata = {\n  _version: undefined,\n  _lastChangedAt: undefined,\n  _deleted: undefined\n};\nconst metadataFields = Object.keys(dummyMetadata);\nfunction getMetadataFields() {\n  return metadataFields;\n}\nfunction generateSelectionSet(namespace, modelDefinition) {\n  const scalarFields = getScalarFields(modelDefinition);\n  const nonModelFields = getNonModelFields(namespace, modelDefinition);\n  const implicitOwnerField = getImplicitOwnerField(modelDefinition, scalarFields);\n  let scalarAndMetadataFields = Object.values(scalarFields).map(({\n    name\n  }) => name).concat(implicitOwnerField).concat(nonModelFields);\n  if (isSchemaModel(modelDefinition)) {\n    scalarAndMetadataFields = scalarAndMetadataFields.concat(getMetadataFields()).concat(getConnectionFields(modelDefinition, namespace));\n  }\n  const result = scalarAndMetadataFields.join('\\n');\n  return result;\n}\nfunction getImplicitOwnerField(modelDefinition, scalarFields) {\n  const ownerFields = getOwnerFields(modelDefinition);\n  if (!scalarFields.owner && ownerFields.includes('owner')) {\n    return ['owner'];\n  }\n  return [];\n}\nfunction getOwnerFields(modelDefinition) {\n  const ownerFields = [];\n  if (isSchemaModelWithAttributes(modelDefinition)) {\n    modelDefinition.attributes.forEach(attr => {\n      if (attr.properties && attr.properties.rules) {\n        const rule = attr.properties.rules.find(rule => rule.allow === 'owner');\n        if (rule && rule.ownerField) {\n          ownerFields.push(rule.ownerField);\n        }\n      }\n    });\n  }\n  return ownerFields;\n}\nfunction getScalarFields(modelDefinition) {\n  const {\n    fields\n  } = modelDefinition;\n  const result = Object.values(fields).filter(field => {\n    if (isGraphQLScalarType(field.type) || isEnumFieldType(field.type)) {\n      return true;\n    }\n    return false;\n  }).reduce((acc, field) => {\n    acc[field.name] = field;\n    return acc;\n  }, {});\n  return result;\n}\n// Used for generating the selection set for queries and mutations\nfunction getConnectionFields(modelDefinition, namespace) {\n  const result = [];\n  Object.values(modelDefinition.fields).filter(({\n    association\n  }) => association && Object.keys(association).length).forEach(({\n    name,\n    association\n  }) => {\n    const {\n      connectionType\n    } = association || {};\n    switch (connectionType) {\n      case 'HAS_ONE':\n      case 'HAS_MANY':\n        // Intentionally blank\n        break;\n      case 'BELONGS_TO':\n        if (isTargetNameAssociation(association)) {\n          // New codegen (CPK)\n          if (association.targetNames && association.targetNames.length > 0) {\n            // Need to retrieve relations in order to get connected model keys\n            const [relations] = establishRelationAndKeys(namespace);\n            const connectedModelName = modelDefinition.fields[name].type['model'];\n            const byPkIndex = relations[connectedModelName].indexes.find(([name]) => name === 'byPk');\n            const keyFields = byPkIndex && byPkIndex[1];\n            const keyFieldSelectionSet = keyFields?.join(' ');\n            // We rely on `_deleted` when we process the sync query (e.g. in batchSave in the adapters)\n            result.push(`${name} { ${keyFieldSelectionSet} _deleted }`);\n          } else {\n            // backwards-compatability for schema generated prior to custom primary key support\n            result.push(`${name} { id _deleted }`);\n          }\n        }\n        break;\n      default:\n        throw new Error(`Invalid connection type ${connectionType}`);\n    }\n  });\n  return result;\n}\nfunction getNonModelFields(namespace, modelDefinition) {\n  const result = [];\n  Object.values(modelDefinition.fields).forEach(({\n    name,\n    type\n  }) => {\n    if (isNonModelFieldType(type)) {\n      const typeDefinition = namespace.nonModels[type.nonModel];\n      const scalarFields = Object.values(getScalarFields(typeDefinition)).map(({\n        name\n      }) => name);\n      const nested = [];\n      Object.values(typeDefinition.fields).forEach(field => {\n        const {\n          type,\n          name\n        } = field;\n        if (isNonModelFieldType(type)) {\n          const typeDefinition = namespace.nonModels[type.nonModel];\n          nested.push(`${name} { ${generateSelectionSet(namespace, typeDefinition)} }`);\n        }\n      });\n      result.push(`${name} { ${scalarFields.join(' ')} ${nested.join(' ')} }`);\n    }\n  });\n  return result;\n}\nfunction getAuthorizationRules(modelDefinition) {\n  // Searching for owner authorization on attributes\n  const authConfig = [].concat(modelDefinition.attributes || []).find(attr => attr && attr.type === 'auth');\n  const {\n    properties: {\n      rules = []\n    } = {}\n  } = authConfig || {};\n  const resultRules = [];\n  // Multiple rules can be declared for allow: owner\n  rules.forEach(rule => {\n    // setting defaults for backwards compatibility with old cli\n    const {\n      identityClaim = 'cognito:username',\n      ownerField = 'owner',\n      operations = ['create', 'update', 'delete', 'read'],\n      provider = 'userPools',\n      groupClaim = 'cognito:groups',\n      allow: authStrategy = 'iam',\n      groups = [],\n      groupsField = ''\n    } = rule;\n    const isReadAuthorized = operations.includes('read');\n    const isOwnerAuth = authStrategy === 'owner';\n    if (!isReadAuthorized && !isOwnerAuth) {\n      return;\n    }\n    const authRule = {\n      identityClaim,\n      ownerField,\n      provider,\n      groupClaim,\n      authStrategy,\n      groups,\n      groupsField,\n      areSubscriptionsPublic: false\n    };\n    if (isOwnerAuth) {\n      // look for the subscription level override\n      // only pay attention to the public level\n      const modelConfig = [].concat(modelDefinition.attributes || []).find(attr => attr && attr.type === 'model');\n      // find the subscriptions level. ON is default\n      const {\n        properties: {\n          subscriptions: {\n            level = 'on'\n          } = {}\n        } = {}\n      } = modelConfig || {};\n      // treat subscriptions as public for owner auth with unprotected reads\n      // when `read` is omitted from `operations`\n      authRule.areSubscriptionsPublic = !operations.includes('read') || level === 'public';\n    }\n    if (isOwnerAuth) {\n      // owner rules has least priority\n      resultRules.push(authRule);\n      return;\n    }\n    resultRules.unshift(authRule);\n  });\n  return resultRules;\n}\nfunction buildSubscriptionGraphQLOperation(namespace, modelDefinition, transformerMutationType, isOwnerAuthorization, ownerField, filterArg = false) {\n  const selectionSet = generateSelectionSet(namespace, modelDefinition);\n  const {\n    name: typeName\n  } = modelDefinition;\n  const opName = `on${transformerMutationType}${typeName}`;\n  const docArgs = [];\n  const opArgs = [];\n  if (filterArg) {\n    docArgs.push(`$filter: ModelSubscription${typeName}FilterInput`);\n    opArgs.push('filter: $filter');\n  }\n  if (isOwnerAuthorization) {\n    docArgs.push(`$${ownerField}: String!`);\n    opArgs.push(`${ownerField}: $${ownerField}`);\n  }\n  const docStr = docArgs.length ? `(${docArgs.join(',')})` : '';\n  const opStr = opArgs.length ? `(${opArgs.join(',')})` : '';\n  return [transformerMutationType, opName, `subscription operation${docStr}{\n\t\t\t${opName}${opStr}{\n\t\t\t\t${selectionSet}\n\t\t\t}\n\t\t}`];\n}\nfunction buildGraphQLOperation(namespace, modelDefinition, graphQLOpType) {\n  let selectionSet = generateSelectionSet(namespace, modelDefinition);\n  const {\n    name: typeName,\n    pluralName: pluralTypeName\n  } = modelDefinition;\n  let operation;\n  let documentArgs;\n  let operationArgs;\n  let transformerMutationType;\n  switch (graphQLOpType) {\n    case 'LIST':\n      operation = `sync${pluralTypeName}`;\n      documentArgs = `($limit: Int, $nextToken: String, $lastSync: AWSTimestamp, $filter: Model${typeName}FilterInput)`;\n      operationArgs = '(limit: $limit, nextToken: $nextToken, lastSync: $lastSync, filter: $filter)';\n      selectionSet = `items {\n\t\t\t\t\t\t\t${selectionSet}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextToken\n\t\t\t\t\t\tstartedAt`;\n      break;\n    case 'CREATE':\n      operation = `create${typeName}`;\n      documentArgs = `($input: Create${typeName}Input!)`;\n      operationArgs = '(input: $input)';\n      transformerMutationType = TransformerMutationType.CREATE;\n      break;\n    case 'UPDATE':\n      operation = `update${typeName}`;\n      documentArgs = `($input: Update${typeName}Input!, $condition: Model${typeName}ConditionInput)`;\n      operationArgs = '(input: $input, condition: $condition)';\n      transformerMutationType = TransformerMutationType.UPDATE;\n      break;\n    case 'DELETE':\n      operation = `delete${typeName}`;\n      documentArgs = `($input: Delete${typeName}Input!, $condition: Model${typeName}ConditionInput)`;\n      operationArgs = '(input: $input, condition: $condition)';\n      transformerMutationType = TransformerMutationType.DELETE;\n      break;\n    case 'GET':\n      operation = `get${typeName}`;\n      documentArgs = `($id: ID!)`;\n      operationArgs = '(id: $id)';\n      transformerMutationType = TransformerMutationType.GET;\n      break;\n    default:\n      throw new Error(`Invalid graphQlOpType ${graphQLOpType}`);\n  }\n  return [[transformerMutationType, operation, `${GraphQLOperationType[graphQLOpType]} operation${documentArgs}{\n\t\t${operation}${operationArgs}{\n\t\t\t${selectionSet}\n\t\t}\n\t}`]];\n}\nfunction createMutationInstanceFromModelOperation(relationships, modelDefinition, opType, model, element, condition, MutationEventConstructor, modelInstanceCreator, id) {\n  let operation;\n  switch (opType) {\n    case OpType.INSERT:\n      operation = TransformerMutationType.CREATE;\n      break;\n    case OpType.UPDATE:\n      operation = TransformerMutationType.UPDATE;\n      break;\n    case OpType.DELETE:\n      operation = TransformerMutationType.DELETE;\n      break;\n    default:\n      throw new Error(`Invalid opType ${opType}`);\n  }\n  // stringify nested objects of type AWSJSON\n  // this allows us to return parsed JSON to users (see `castInstanceType()` in datastore.ts),\n  // but still send the object correctly over the wire\n  const replacer = (k, v) => {\n    const isAWSJSON = k && v !== null && typeof v === 'object' && modelDefinition.fields[k] && modelDefinition.fields[k].type === 'AWSJSON';\n    if (isAWSJSON) {\n      return JSON.stringify(v);\n    }\n    return v;\n  };\n  const modelId = getIdentifierValue(modelDefinition, element);\n  const optionalId = OpType.INSERT && id ? {\n    id\n  } : {};\n  const mutationEvent = modelInstanceCreator(MutationEventConstructor, {\n    ...optionalId,\n    data: JSON.stringify(element, replacer),\n    modelId,\n    model: model.name,\n    operation: operation,\n    condition: JSON.stringify(condition)\n  });\n  return mutationEvent;\n}\nfunction predicateToGraphQLCondition(predicate, modelDefinition) {\n  const result = {};\n  if (!predicate || !Array.isArray(predicate.predicates)) {\n    return result;\n  }\n  // This is compatible with how the GQL Transform currently generates the Condition Input,\n  // i.e. any PK and SK fields are omitted and can't be used as conditions.\n  // However, I think this limits usability.\n  // What if we want to delete all records where SK > some value\n  // Or all records where PK = some value but SKs are different values\n  // TODO: if the Transform gets updated we'll need to modify this logic to only omit\n  // key fields from the predicate/condition when ALL of the keyFields are present and using `eq` operators\n  const keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n  return predicateToGraphQLFilter(predicate, keyFields);\n}\n/**\n * @param predicatesGroup - Predicate Group\n    @returns GQL Filter Expression from Predicate Group\n    \n    @remarks Flattens redundant list predicates\n    @example\n\n    ```js\n    { and:[{ and:[{ username:  { eq: 'bob' }}] }] }\n    ```\n    Becomes\n    ```js\n    { and:[{ username: { eq: 'bob' }}] }\n    ```\n    */\nfunction predicateToGraphQLFilter(predicatesGroup, fieldsToOmit = [], root = true) {\n  const result = {};\n  if (!predicatesGroup || !Array.isArray(predicatesGroup.predicates)) {\n    return result;\n  }\n  const {\n    type,\n    predicates\n  } = predicatesGroup;\n  const isList = type === 'and' || type === 'or';\n  result[type] = isList ? [] : {};\n  const children = [];\n  predicates.forEach(predicate => {\n    if (isPredicateObj(predicate)) {\n      const {\n        field,\n        operator,\n        operand\n      } = predicate;\n      if (fieldsToOmit.includes(field)) return;\n      const gqlField = {\n        [field]: {\n          [operator]: operand\n        }\n      };\n      children.push(gqlField);\n      return;\n    }\n    const child = predicateToGraphQLFilter(predicate, fieldsToOmit, false);\n    if (Object.keys(child).length > 0) {\n      children.push(child);\n    }\n  });\n  // flatten redundant list predicates\n  if (children.length === 1) {\n    const [child] = children;\n    if (\n    // any nested list node\n    isList && !root ||\n    // root list node where the only child is also a list node\n    isList && root && ('and' in child || 'or' in child)) {\n      delete result[type];\n      Object.assign(result, child);\n      return result;\n    }\n  }\n  children.forEach(child => {\n    if (isList) {\n      result[type].push(child);\n    } else {\n      result[type] = child;\n    }\n  });\n  if (isList) {\n    if (result[type].length === 0) return {};\n  } else {\n    if (Object.keys(result[type]).length === 0) return {};\n  }\n  return result;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns set of distinct field names in the filter group\n */\nfunction filterFields(group) {\n  const fields = new Set();\n  if (!group || !Array.isArray(group.predicates)) return fields;\n  const {\n    predicates\n  } = group;\n  const stack = [...predicates];\n  while (stack.length > 0) {\n    const current = stack.pop();\n    if (isPredicateObj(current)) {\n      fields.add(current.field);\n    } else if (isPredicateGroup(current)) {\n      stack.push(...current.predicates);\n    }\n  }\n  return fields;\n}\n/**\n *\n * @param modelDefinition\n * @returns set of field names used with dynamic auth modes configured for the provided model definition\n */\nfunction dynamicAuthFields(modelDefinition) {\n  const rules = getAuthorizationRules(modelDefinition);\n  const fields = new Set();\n  for (const rule of rules) {\n    if (rule.groupsField && !rule.groups.length) {\n      // dynamic group rule will have no values in `rule.groups`\n      fields.add(rule.groupsField);\n    } else if (rule.ownerField) {\n      fields.add(rule.ownerField);\n    }\n  }\n  return fields;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns the total number of OR'd predicates in the filter group\n *\n * @example returns 2\n * ```js\n * { type: \"or\", predicates: [\n * { field: \"username\", operator: \"beginsWith\", operand: \"a\" },\n * { field: \"title\", operator: \"contains\", operand: \"abc\" },\n * ]}\n * ```\n */\nfunction countFilterCombinations(group) {\n  if (!group || !Array.isArray(group.predicates)) return 0;\n  let count = 0;\n  const stack = [group];\n  while (stack.length > 0) {\n    const current = stack.pop();\n    if (isPredicateGroup(current)) {\n      const {\n        predicates,\n        type\n      } = current;\n      // ignore length = 1; groups with 1 predicate will get flattened when converted to gqlFilter\n      if (type === 'or' && predicates.length > 1) {\n        count += predicates.length;\n      }\n      stack.push(...predicates);\n    }\n  }\n  // if we didn't encounter any OR groups, default to 1\n  return count || 1;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns name of repeated field | null\n *\n * @example returns \"username\"\n * ```js\n * { type: \"and\", predicates: [\n * \t\t{ field: \"username\", operator: \"beginsWith\", operand: \"a\" },\n * \t\t{ field: \"username\", operator: \"contains\", operand: \"abc\" },\n * ] }\n * ```\n */\nfunction repeatedFieldInGroup(group) {\n  if (!group || !Array.isArray(group.predicates)) return null;\n  // convert to filter in order to flatten redundant groups\n  const gqlFilter = predicateToGraphQLFilter(group);\n  const stack = [gqlFilter];\n  const hasGroupRepeatedFields = fields => {\n    const seen = {};\n    for (const f of fields) {\n      const [fieldName] = Object.keys(f);\n      if (seen[fieldName]) {\n        return fieldName;\n      }\n      seen[fieldName] = true;\n    }\n    return null;\n  };\n  while (stack.length > 0) {\n    const current = stack.pop();\n    const [key] = Object.keys(current);\n    const values = current[key];\n    if (!Array.isArray(values)) {\n      return null;\n    }\n    // field value will be single object\n    const predicateObjects = values.filter(v => !Array.isArray(Object.values(v)[0]));\n    // group value will be an array\n    const predicateGroups = values.filter(v => Array.isArray(Object.values(v)[0]));\n    if (key === 'and') {\n      const repeatedField = hasGroupRepeatedFields(predicateObjects);\n      if (repeatedField) {\n        return repeatedField;\n      }\n    }\n    stack.push(...predicateGroups);\n  }\n  return null;\n}\nvar RTFError;\n(function (RTFError) {\n  RTFError[RTFError[\"UnknownField\"] = 0] = \"UnknownField\";\n  RTFError[RTFError[\"MaxAttributes\"] = 1] = \"MaxAttributes\";\n  RTFError[RTFError[\"MaxCombinations\"] = 2] = \"MaxCombinations\";\n  RTFError[RTFError[\"RepeatedFieldname\"] = 3] = \"RepeatedFieldname\";\n  RTFError[RTFError[\"NotGroup\"] = 4] = \"NotGroup\";\n  RTFError[RTFError[\"FieldNotInType\"] = 5] = \"FieldNotInType\";\n})(RTFError || (RTFError = {}));\nfunction generateRTFRemediation(errorType, modelDefinition, predicatesGroup) {\n  const selSyncFields = filterFields(predicatesGroup);\n  const selSyncFieldStr = [...selSyncFields].join(', ');\n  const dynamicAuthModeFields = dynamicAuthFields(modelDefinition);\n  const dynamicAuthFieldsStr = [...dynamicAuthModeFields].join(', ');\n  const filterCombinations = countFilterCombinations(predicatesGroup);\n  const repeatedField = repeatedFieldInGroup(predicatesGroup);\n  switch (errorType) {\n    case RTFError.UnknownField:\n      return `Your API was generated with an older version of the CLI that doesn't support backend subscription filtering.` + 'To enable backend subscription filtering, upgrade your Amplify CLI to the latest version and push your app by running `amplify upgrade` followed by `amplify push`';\n    case RTFError.MaxAttributes:\n      {\n        let message = `Your selective sync expression for ${modelDefinition.name} contains ${selSyncFields.size} different model fields: ${selSyncFieldStr}.\\n\\n`;\n        if (dynamicAuthModeFields.size > 0) {\n          message += `Note: the number of fields you can use with selective sync is affected by @auth rules configured on the model.\\n\\n` + `Dynamic auth modes, such as owner auth and dynamic group auth each utilize 1 field.\\n` + `You currently have ${dynamicAuthModeFields.size} dynamic auth mode(s) configured on this model: ${dynamicAuthFieldsStr}.`;\n        }\n        return message;\n      }\n    case RTFError.MaxCombinations:\n      {\n        let message = `Your selective sync expression for ${modelDefinition.name} contains ${filterCombinations} field combinations (total number of predicates in an OR expression).\\n\\n`;\n        if (dynamicAuthModeFields.size > 0) {\n          message += `Note: the number of fields you can use with selective sync is affected by @auth rules configured on the model.\\n\\n` + `Dynamic auth modes, such as owner auth and dynamic group auth factor in to the number of combinations you're using.\\n` + `You currently have ${dynamicAuthModeFields.size} dynamic auth mode(s) configured on this model: ${dynamicAuthFieldsStr}.`;\n        }\n        return message;\n      }\n    case RTFError.RepeatedFieldname:\n      return `Your selective sync expression for ${modelDefinition.name} contains multiple entries for ${repeatedField} in the same AND group.`;\n    case RTFError.NotGroup:\n      return `Your selective sync expression for ${modelDefinition.name} uses a \\`not\\` group. If you'd like to filter subscriptions in the backend, ` + `rewrite your expression using \\`ne\\` or \\`notContains\\` operators.`;\n    case RTFError.FieldNotInType:\n      // no remediation instructions. We'll surface the message directly\n      return '';\n  }\n}\nfunction getUserGroupsFromToken(token, rule) {\n  // validate token against groupClaim\n  let userGroups = token[rule.groupClaim] || [];\n  if (typeof userGroups === 'string') {\n    let parsedGroups;\n    try {\n      parsedGroups = JSON.parse(userGroups);\n    } catch (e) {\n      parsedGroups = userGroups;\n    }\n    userGroups = [].concat(parsedGroups);\n  }\n  return userGroups;\n}\nasync function getModelAuthModes({\n  authModeStrategy,\n  defaultAuthMode,\n  modelName,\n  schema\n}) {\n  const operations = Object.values(ModelOperation);\n  const modelAuthModes = {\n    CREATE: [],\n    READ: [],\n    UPDATE: [],\n    DELETE: []\n  };\n  try {\n    await Promise.all(operations.map(async operation => {\n      const authModes = await authModeStrategy({\n        schema,\n        modelName,\n        operation\n      });\n      if (typeof authModes === 'string') {\n        modelAuthModes[operation] = [authModes];\n      } else if (Array.isArray(authModes) && authModes.length) {\n        modelAuthModes[operation] = authModes;\n      } else {\n        // Use default auth mode if nothing is returned from authModeStrategy\n        modelAuthModes[operation] = [defaultAuthMode];\n      }\n    }));\n  } catch (error) {\n    logger.debug(`Error getting auth modes for model: ${modelName}`, error);\n  }\n  return modelAuthModes;\n}\nfunction getForbiddenError(error) {\n  const forbiddenErrorCodes = [401, 403];\n  let forbiddenError;\n  if (error && error.errors) {\n    forbiddenError = error.errors.find(err => forbiddenErrorCodes.includes(resolveServiceErrorStatusCode(err)));\n  } else if (error && error.message) {\n    forbiddenError = error;\n  }\n  if (forbiddenError) {\n    return forbiddenError.message ?? `Request failed with status code ${resolveServiceErrorStatusCode(forbiddenError)}`;\n  }\n  return null;\n}\nfunction resolveServiceErrorStatusCode(error) {\n  if (error?.['$metadata']?.['httpStatusCode']) {\n    return Number(error?.['$metadata']?.['httpStatusCode']);\n  } else if (error?.originalError) {\n    return resolveServiceErrorStatusCode(error?.originalError);\n  } else {\n    return null;\n  }\n}\nfunction getClientSideAuthError(error) {\n  const clientSideAuthErrors = Object.values(GraphQLAuthError);\n  const clientSideError = error && error.message && clientSideAuthErrors.find(clientError => error.message.includes(clientError));\n  return clientSideError || null;\n}\nasync function getTokenForCustomAuth(authMode, amplifyConfig = {}) {\n  if (authMode === 'lambda') {\n    const {\n      authProviders: {\n        functionAuthProvider\n      } = {\n        functionAuthProvider: null\n      }\n    } = amplifyConfig;\n    if (functionAuthProvider && typeof functionAuthProvider === 'function') {\n      try {\n        const {\n          token\n        } = await functionAuthProvider();\n        return token;\n      } catch (error) {\n        throw new Error(`Error retrieving token from \\`functionAuthProvider\\`: ${error}`);\n      }\n    } else {\n      // TODO: add docs link once available\n      throw new Error('You must provide a `functionAuthProvider` function to `DataStore.configure` when using lambda');\n    }\n  }\n}\n// Util that takes a modelDefinition and model and returns either the id value(s) or the custom primary key value(s)\nfunction getIdentifierValue(modelDefinition, model) {\n  const pkFieldNames = extractPrimaryKeyFieldNames(modelDefinition);\n  const idOrPk = pkFieldNames.map(f => model[f]).join(IDENTIFIER_KEY_SEPARATOR);\n  return idOrPk;\n}\nexport { RTFError, TransformerMutationType, buildGraphQLOperation, buildSubscriptionGraphQLOperation, countFilterCombinations, createMutationInstanceFromModelOperation, dynamicAuthFields, filterFields, generateRTFRemediation, generateSelectionSet, getAuthorizationRules, getClientSideAuthError, getForbiddenError, getIdentifierValue, getMetadataFields, getModelAuthModes, getTokenForCustomAuth, getUserGroupsFromToken, predicateToGraphQLCondition, predicateToGraphQLFilter, repeatedFieldInGroup, resolveServiceErrorStatusCode };","map":{"version":3,"names":["logger","ConsoleLogger","GraphQLOperationType","TransformerMutationType","dummyMetadata","_version","undefined","_lastChangedAt","_deleted","metadataFields","Object","keys","getMetadataFields","generateSelectionSet","namespace","modelDefinition","scalarFields","getScalarFields","nonModelFields","getNonModelFields","implicitOwnerField","getImplicitOwnerField","scalarAndMetadataFields","values","map","name","concat","isSchemaModel","getConnectionFields","result","join","ownerFields","getOwnerFields","owner","includes","isSchemaModelWithAttributes","attributes","forEach","attr","properties","rules","rule","find","allow","ownerField","push","fields","filter","field","isGraphQLScalarType","type","isEnumFieldType","reduce","acc","association","length","connectionType","isTargetNameAssociation","targetNames","relations","establishRelationAndKeys","connectedModelName","byPkIndex","indexes","keyFields","keyFieldSelectionSet","Error","isNonModelFieldType","typeDefinition","nonModels","nonModel","nested","getAuthorizationRules","authConfig","resultRules","identityClaim","operations","provider","groupClaim","authStrategy","groups","groupsField","isReadAuthorized","isOwnerAuth","authRule","areSubscriptionsPublic","modelConfig","subscriptions","level","unshift","buildSubscriptionGraphQLOperation","transformerMutationType","isOwnerAuthorization","filterArg","selectionSet","typeName","opName","docArgs","opArgs","docStr","opStr","buildGraphQLOperation","graphQLOpType","pluralName","pluralTypeName","operation","documentArgs","operationArgs","CREATE","UPDATE","DELETE","GET","createMutationInstanceFromModelOperation","relationships","opType","model","element","condition","MutationEventConstructor","modelInstanceCreator","id","OpType","INSERT","replacer","k","v","isAWSJSON","JSON","stringify","modelId","getIdentifierValue","optionalId","mutationEvent","data","predicateToGraphQLCondition","predicate","Array","isArray","predicates","extractPrimaryKeyFieldNames","predicateToGraphQLFilter","predicatesGroup","fieldsToOmit","root","isList","children","isPredicateObj","operator","operand","gqlField","child","assign","filterFields","group","Set","stack","current","pop","add","isPredicateGroup","dynamicAuthFields","countFilterCombinations","count","repeatedFieldInGroup","gqlFilter","hasGroupRepeatedFields","seen","f","fieldName","key","predicateObjects","predicateGroups","repeatedField","RTFError","generateRTFRemediation","errorType","selSyncFields","selSyncFieldStr","dynamicAuthModeFields","dynamicAuthFieldsStr","filterCombinations","UnknownField","MaxAttributes","message","size","MaxCombinations","RepeatedFieldname","NotGroup","FieldNotInType","getUserGroupsFromToken","token","userGroups","parsedGroups","parse","e","getModelAuthModes","authModeStrategy","defaultAuthMode","modelName","schema","ModelOperation","modelAuthModes","READ","Promise","all","authModes","error","debug","getForbiddenError","forbiddenErrorCodes","forbiddenError","errors","err","resolveServiceErrorStatusCode","Number","originalError","getClientSideAuthError","clientSideAuthErrors","GraphQLAuthError","clientSideError","clientError","getTokenForCustomAuth","authMode","amplifyConfig","authProviders","functionAuthProvider","pkFieldNames","idOrPk","IDENTIFIER_KEY_SEPARATOR"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/sync/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { GraphQLAuthError } from '@aws-amplify/api';\nimport { isEnumFieldType, isGraphQLScalarType, isPredicateObj, isSchemaModel, isSchemaModelWithAttributes, isTargetNameAssociation, isNonModelFieldType, OpType, ModelOperation, isPredicateGroup, } from '../types';\nimport { extractPrimaryKeyFieldNames, establishRelationAndKeys, IDENTIFIER_KEY_SEPARATOR, } from '../util';\nimport { ConsoleLogger } from '@aws-amplify/core';\nconst logger = new ConsoleLogger('DataStore');\nvar GraphQLOperationType;\n(function (GraphQLOperationType) {\n    GraphQLOperationType[\"LIST\"] = \"query\";\n    GraphQLOperationType[\"CREATE\"] = \"mutation\";\n    GraphQLOperationType[\"UPDATE\"] = \"mutation\";\n    GraphQLOperationType[\"DELETE\"] = \"mutation\";\n    GraphQLOperationType[\"GET\"] = \"query\";\n})(GraphQLOperationType || (GraphQLOperationType = {}));\nexport var TransformerMutationType;\n(function (TransformerMutationType) {\n    TransformerMutationType[\"CREATE\"] = \"Create\";\n    TransformerMutationType[\"UPDATE\"] = \"Update\";\n    TransformerMutationType[\"DELETE\"] = \"Delete\";\n    TransformerMutationType[\"GET\"] = \"Get\";\n})(TransformerMutationType || (TransformerMutationType = {}));\nconst dummyMetadata = {\n    _version: undefined,\n    _lastChangedAt: undefined,\n    _deleted: undefined,\n};\nconst metadataFields = (Object.keys(dummyMetadata));\nexport function getMetadataFields() {\n    return metadataFields;\n}\nexport function generateSelectionSet(namespace, modelDefinition) {\n    const scalarFields = getScalarFields(modelDefinition);\n    const nonModelFields = getNonModelFields(namespace, modelDefinition);\n    const implicitOwnerField = getImplicitOwnerField(modelDefinition, scalarFields);\n    let scalarAndMetadataFields = Object.values(scalarFields)\n        .map(({ name }) => name)\n        .concat(implicitOwnerField)\n        .concat(nonModelFields);\n    if (isSchemaModel(modelDefinition)) {\n        scalarAndMetadataFields = scalarAndMetadataFields\n            .concat(getMetadataFields())\n            .concat(getConnectionFields(modelDefinition, namespace));\n    }\n    const result = scalarAndMetadataFields.join('\\n');\n    return result;\n}\nfunction getImplicitOwnerField(modelDefinition, scalarFields) {\n    const ownerFields = getOwnerFields(modelDefinition);\n    if (!scalarFields.owner && ownerFields.includes('owner')) {\n        return ['owner'];\n    }\n    return [];\n}\nfunction getOwnerFields(modelDefinition) {\n    const ownerFields = [];\n    if (isSchemaModelWithAttributes(modelDefinition)) {\n        modelDefinition.attributes.forEach(attr => {\n            if (attr.properties && attr.properties.rules) {\n                const rule = attr.properties.rules.find(rule => rule.allow === 'owner');\n                if (rule && rule.ownerField) {\n                    ownerFields.push(rule.ownerField);\n                }\n            }\n        });\n    }\n    return ownerFields;\n}\nfunction getScalarFields(modelDefinition) {\n    const { fields } = modelDefinition;\n    const result = Object.values(fields)\n        .filter(field => {\n        if (isGraphQLScalarType(field.type) || isEnumFieldType(field.type)) {\n            return true;\n        }\n        return false;\n    })\n        .reduce((acc, field) => {\n        acc[field.name] = field;\n        return acc;\n    }, {});\n    return result;\n}\n// Used for generating the selection set for queries and mutations\nfunction getConnectionFields(modelDefinition, namespace) {\n    const result = [];\n    Object.values(modelDefinition.fields)\n        .filter(({ association }) => association && Object.keys(association).length)\n        .forEach(({ name, association }) => {\n        const { connectionType } = association || {};\n        switch (connectionType) {\n            case 'HAS_ONE':\n            case 'HAS_MANY':\n                // Intentionally blank\n                break;\n            case 'BELONGS_TO':\n                if (isTargetNameAssociation(association)) {\n                    // New codegen (CPK)\n                    if (association.targetNames && association.targetNames.length > 0) {\n                        // Need to retrieve relations in order to get connected model keys\n                        const [relations] = establishRelationAndKeys(namespace);\n                        const connectedModelName = modelDefinition.fields[name].type['model'];\n                        const byPkIndex = relations[connectedModelName].indexes.find(([name]) => name === 'byPk');\n                        const keyFields = byPkIndex && byPkIndex[1];\n                        const keyFieldSelectionSet = keyFields?.join(' ');\n                        // We rely on `_deleted` when we process the sync query (e.g. in batchSave in the adapters)\n                        result.push(`${name} { ${keyFieldSelectionSet} _deleted }`);\n                    }\n                    else {\n                        // backwards-compatability for schema generated prior to custom primary key support\n                        result.push(`${name} { id _deleted }`);\n                    }\n                }\n                break;\n            default:\n                throw new Error(`Invalid connection type ${connectionType}`);\n        }\n    });\n    return result;\n}\nfunction getNonModelFields(namespace, modelDefinition) {\n    const result = [];\n    Object.values(modelDefinition.fields).forEach(({ name, type }) => {\n        if (isNonModelFieldType(type)) {\n            const typeDefinition = namespace.nonModels[type.nonModel];\n            const scalarFields = Object.values(getScalarFields(typeDefinition)).map(({ name }) => name);\n            const nested = [];\n            Object.values(typeDefinition.fields).forEach(field => {\n                const { type, name } = field;\n                if (isNonModelFieldType(type)) {\n                    const typeDefinition = namespace.nonModels[type.nonModel];\n                    nested.push(`${name} { ${generateSelectionSet(namespace, typeDefinition)} }`);\n                }\n            });\n            result.push(`${name} { ${scalarFields.join(' ')} ${nested.join(' ')} }`);\n        }\n    });\n    return result;\n}\nexport function getAuthorizationRules(modelDefinition) {\n    // Searching for owner authorization on attributes\n    const authConfig = []\n        .concat(modelDefinition.attributes || [])\n        .find(attr => attr && attr.type === 'auth');\n    const { properties: { rules = [] } = {} } = authConfig || {};\n    const resultRules = [];\n    // Multiple rules can be declared for allow: owner\n    rules.forEach(rule => {\n        // setting defaults for backwards compatibility with old cli\n        const { identityClaim = 'cognito:username', ownerField = 'owner', operations = ['create', 'update', 'delete', 'read'], provider = 'userPools', groupClaim = 'cognito:groups', allow: authStrategy = 'iam', groups = [], groupsField = '', } = rule;\n        const isReadAuthorized = operations.includes('read');\n        const isOwnerAuth = authStrategy === 'owner';\n        if (!isReadAuthorized && !isOwnerAuth) {\n            return;\n        }\n        const authRule = {\n            identityClaim,\n            ownerField,\n            provider,\n            groupClaim,\n            authStrategy,\n            groups,\n            groupsField,\n            areSubscriptionsPublic: false,\n        };\n        if (isOwnerAuth) {\n            // look for the subscription level override\n            // only pay attention to the public level\n            const modelConfig = []\n                .concat(modelDefinition.attributes || [])\n                .find(attr => attr && attr.type === 'model');\n            // find the subscriptions level. ON is default\n            const { properties: { subscriptions: { level = 'on' } = {} } = {} } = modelConfig || {};\n            // treat subscriptions as public for owner auth with unprotected reads\n            // when `read` is omitted from `operations`\n            authRule.areSubscriptionsPublic =\n                !operations.includes('read') || level === 'public';\n        }\n        if (isOwnerAuth) {\n            // owner rules has least priority\n            resultRules.push(authRule);\n            return;\n        }\n        resultRules.unshift(authRule);\n    });\n    return resultRules;\n}\nexport function buildSubscriptionGraphQLOperation(namespace, modelDefinition, transformerMutationType, isOwnerAuthorization, ownerField, filterArg = false) {\n    const selectionSet = generateSelectionSet(namespace, modelDefinition);\n    const { name: typeName } = modelDefinition;\n    const opName = `on${transformerMutationType}${typeName}`;\n    const docArgs = [];\n    const opArgs = [];\n    if (filterArg) {\n        docArgs.push(`$filter: ModelSubscription${typeName}FilterInput`);\n        opArgs.push('filter: $filter');\n    }\n    if (isOwnerAuthorization) {\n        docArgs.push(`$${ownerField}: String!`);\n        opArgs.push(`${ownerField}: $${ownerField}`);\n    }\n    const docStr = docArgs.length ? `(${docArgs.join(',')})` : '';\n    const opStr = opArgs.length ? `(${opArgs.join(',')})` : '';\n    return [\n        transformerMutationType,\n        opName,\n        `subscription operation${docStr}{\n\t\t\t${opName}${opStr}{\n\t\t\t\t${selectionSet}\n\t\t\t}\n\t\t}`,\n    ];\n}\nexport function buildGraphQLOperation(namespace, modelDefinition, graphQLOpType) {\n    let selectionSet = generateSelectionSet(namespace, modelDefinition);\n    const { name: typeName, pluralName: pluralTypeName } = modelDefinition;\n    let operation;\n    let documentArgs;\n    let operationArgs;\n    let transformerMutationType;\n    switch (graphQLOpType) {\n        case 'LIST':\n            operation = `sync${pluralTypeName}`;\n            documentArgs = `($limit: Int, $nextToken: String, $lastSync: AWSTimestamp, $filter: Model${typeName}FilterInput)`;\n            operationArgs =\n                '(limit: $limit, nextToken: $nextToken, lastSync: $lastSync, filter: $filter)';\n            selectionSet = `items {\n\t\t\t\t\t\t\t${selectionSet}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextToken\n\t\t\t\t\t\tstartedAt`;\n            break;\n        case 'CREATE':\n            operation = `create${typeName}`;\n            documentArgs = `($input: Create${typeName}Input!)`;\n            operationArgs = '(input: $input)';\n            transformerMutationType = TransformerMutationType.CREATE;\n            break;\n        case 'UPDATE':\n            operation = `update${typeName}`;\n            documentArgs = `($input: Update${typeName}Input!, $condition: Model${typeName}ConditionInput)`;\n            operationArgs = '(input: $input, condition: $condition)';\n            transformerMutationType = TransformerMutationType.UPDATE;\n            break;\n        case 'DELETE':\n            operation = `delete${typeName}`;\n            documentArgs = `($input: Delete${typeName}Input!, $condition: Model${typeName}ConditionInput)`;\n            operationArgs = '(input: $input, condition: $condition)';\n            transformerMutationType = TransformerMutationType.DELETE;\n            break;\n        case 'GET':\n            operation = `get${typeName}`;\n            documentArgs = `($id: ID!)`;\n            operationArgs = '(id: $id)';\n            transformerMutationType = TransformerMutationType.GET;\n            break;\n        default:\n            throw new Error(`Invalid graphQlOpType ${graphQLOpType}`);\n    }\n    return [\n        [\n            transformerMutationType,\n            operation,\n            `${GraphQLOperationType[graphQLOpType]} operation${documentArgs}{\n\t\t${operation}${operationArgs}{\n\t\t\t${selectionSet}\n\t\t}\n\t}`,\n        ],\n    ];\n}\nexport function createMutationInstanceFromModelOperation(relationships, modelDefinition, opType, model, element, condition, MutationEventConstructor, modelInstanceCreator, id) {\n    let operation;\n    switch (opType) {\n        case OpType.INSERT:\n            operation = TransformerMutationType.CREATE;\n            break;\n        case OpType.UPDATE:\n            operation = TransformerMutationType.UPDATE;\n            break;\n        case OpType.DELETE:\n            operation = TransformerMutationType.DELETE;\n            break;\n        default:\n            throw new Error(`Invalid opType ${opType}`);\n    }\n    // stringify nested objects of type AWSJSON\n    // this allows us to return parsed JSON to users (see `castInstanceType()` in datastore.ts),\n    // but still send the object correctly over the wire\n    const replacer = (k, v) => {\n        const isAWSJSON = k &&\n            v !== null &&\n            typeof v === 'object' &&\n            modelDefinition.fields[k] &&\n            modelDefinition.fields[k].type === 'AWSJSON';\n        if (isAWSJSON) {\n            return JSON.stringify(v);\n        }\n        return v;\n    };\n    const modelId = getIdentifierValue(modelDefinition, element);\n    const optionalId = OpType.INSERT && id ? { id } : {};\n    const mutationEvent = modelInstanceCreator(MutationEventConstructor, {\n        ...optionalId,\n        data: JSON.stringify(element, replacer),\n        modelId,\n        model: model.name,\n        operation: operation,\n        condition: JSON.stringify(condition),\n    });\n    return mutationEvent;\n}\nexport function predicateToGraphQLCondition(predicate, modelDefinition) {\n    const result = {};\n    if (!predicate || !Array.isArray(predicate.predicates)) {\n        return result;\n    }\n    // This is compatible with how the GQL Transform currently generates the Condition Input,\n    // i.e. any PK and SK fields are omitted and can't be used as conditions.\n    // However, I think this limits usability.\n    // What if we want to delete all records where SK > some value\n    // Or all records where PK = some value but SKs are different values\n    // TODO: if the Transform gets updated we'll need to modify this logic to only omit\n    // key fields from the predicate/condition when ALL of the keyFields are present and using `eq` operators\n    const keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n    return predicateToGraphQLFilter(predicate, keyFields);\n}\n/**\n * @param predicatesGroup - Predicate Group\n    @returns GQL Filter Expression from Predicate Group\n    \n    @remarks Flattens redundant list predicates\n    @example\n\n    ```js\n    { and:[{ and:[{ username:  { eq: 'bob' }}] }] }\n    ```\n    Becomes\n    ```js\n    { and:[{ username: { eq: 'bob' }}] }\n    ```\n    */\nexport function predicateToGraphQLFilter(predicatesGroup, fieldsToOmit = [], root = true) {\n    const result = {};\n    if (!predicatesGroup || !Array.isArray(predicatesGroup.predicates)) {\n        return result;\n    }\n    const { type, predicates } = predicatesGroup;\n    const isList = type === 'and' || type === 'or';\n    result[type] = isList ? [] : {};\n    const children = [];\n    predicates.forEach(predicate => {\n        if (isPredicateObj(predicate)) {\n            const { field, operator, operand } = predicate;\n            if (fieldsToOmit.includes(field))\n                return;\n            const gqlField = {\n                [field]: { [operator]: operand },\n            };\n            children.push(gqlField);\n            return;\n        }\n        const child = predicateToGraphQLFilter(predicate, fieldsToOmit, false);\n        if (Object.keys(child).length > 0) {\n            children.push(child);\n        }\n    });\n    // flatten redundant list predicates\n    if (children.length === 1) {\n        const [child] = children;\n        if (\n        // any nested list node\n        (isList && !root) ||\n            // root list node where the only child is also a list node\n            (isList && root && ('and' in child || 'or' in child))) {\n            delete result[type];\n            Object.assign(result, child);\n            return result;\n        }\n    }\n    children.forEach(child => {\n        if (isList) {\n            result[type].push(child);\n        }\n        else {\n            result[type] = child;\n        }\n    });\n    if (isList) {\n        if (result[type].length === 0)\n            return {};\n    }\n    else {\n        if (Object.keys(result[type]).length === 0)\n            return {};\n    }\n    return result;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns set of distinct field names in the filter group\n */\nexport function filterFields(group) {\n    const fields = new Set();\n    if (!group || !Array.isArray(group.predicates))\n        return fields;\n    const { predicates } = group;\n    const stack = [...predicates];\n    while (stack.length > 0) {\n        const current = stack.pop();\n        if (isPredicateObj(current)) {\n            fields.add(current.field);\n        }\n        else if (isPredicateGroup(current)) {\n            stack.push(...current.predicates);\n        }\n    }\n    return fields;\n}\n/**\n *\n * @param modelDefinition\n * @returns set of field names used with dynamic auth modes configured for the provided model definition\n */\nexport function dynamicAuthFields(modelDefinition) {\n    const rules = getAuthorizationRules(modelDefinition);\n    const fields = new Set();\n    for (const rule of rules) {\n        if (rule.groupsField && !rule.groups.length) {\n            // dynamic group rule will have no values in `rule.groups`\n            fields.add(rule.groupsField);\n        }\n        else if (rule.ownerField) {\n            fields.add(rule.ownerField);\n        }\n    }\n    return fields;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns the total number of OR'd predicates in the filter group\n *\n * @example returns 2\n * ```js\n * { type: \"or\", predicates: [\n * { field: \"username\", operator: \"beginsWith\", operand: \"a\" },\n * { field: \"title\", operator: \"contains\", operand: \"abc\" },\n * ]}\n * ```\n */\nexport function countFilterCombinations(group) {\n    if (!group || !Array.isArray(group.predicates))\n        return 0;\n    let count = 0;\n    const stack = [group];\n    while (stack.length > 0) {\n        const current = stack.pop();\n        if (isPredicateGroup(current)) {\n            const { predicates, type } = current;\n            // ignore length = 1; groups with 1 predicate will get flattened when converted to gqlFilter\n            if (type === 'or' && predicates.length > 1) {\n                count += predicates.length;\n            }\n            stack.push(...predicates);\n        }\n    }\n    // if we didn't encounter any OR groups, default to 1\n    return count || 1;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns name of repeated field | null\n *\n * @example returns \"username\"\n * ```js\n * { type: \"and\", predicates: [\n * \t\t{ field: \"username\", operator: \"beginsWith\", operand: \"a\" },\n * \t\t{ field: \"username\", operator: \"contains\", operand: \"abc\" },\n * ] }\n * ```\n */\nexport function repeatedFieldInGroup(group) {\n    if (!group || !Array.isArray(group.predicates))\n        return null;\n    // convert to filter in order to flatten redundant groups\n    const gqlFilter = predicateToGraphQLFilter(group);\n    const stack = [gqlFilter];\n    const hasGroupRepeatedFields = (fields) => {\n        const seen = {};\n        for (const f of fields) {\n            const [fieldName] = Object.keys(f);\n            if (seen[fieldName]) {\n                return fieldName;\n            }\n            seen[fieldName] = true;\n        }\n        return null;\n    };\n    while (stack.length > 0) {\n        const current = stack.pop();\n        const [key] = Object.keys(current);\n        const values = current[key];\n        if (!Array.isArray(values)) {\n            return null;\n        }\n        // field value will be single object\n        const predicateObjects = values.filter(v => !Array.isArray(Object.values(v)[0]));\n        // group value will be an array\n        const predicateGroups = values.filter(v => Array.isArray(Object.values(v)[0]));\n        if (key === 'and') {\n            const repeatedField = hasGroupRepeatedFields(predicateObjects);\n            if (repeatedField) {\n                return repeatedField;\n            }\n        }\n        stack.push(...predicateGroups);\n    }\n    return null;\n}\nexport var RTFError;\n(function (RTFError) {\n    RTFError[RTFError[\"UnknownField\"] = 0] = \"UnknownField\";\n    RTFError[RTFError[\"MaxAttributes\"] = 1] = \"MaxAttributes\";\n    RTFError[RTFError[\"MaxCombinations\"] = 2] = \"MaxCombinations\";\n    RTFError[RTFError[\"RepeatedFieldname\"] = 3] = \"RepeatedFieldname\";\n    RTFError[RTFError[\"NotGroup\"] = 4] = \"NotGroup\";\n    RTFError[RTFError[\"FieldNotInType\"] = 5] = \"FieldNotInType\";\n})(RTFError || (RTFError = {}));\nexport function generateRTFRemediation(errorType, modelDefinition, predicatesGroup) {\n    const selSyncFields = filterFields(predicatesGroup);\n    const selSyncFieldStr = [...selSyncFields].join(', ');\n    const dynamicAuthModeFields = dynamicAuthFields(modelDefinition);\n    const dynamicAuthFieldsStr = [...dynamicAuthModeFields].join(', ');\n    const filterCombinations = countFilterCombinations(predicatesGroup);\n    const repeatedField = repeatedFieldInGroup(predicatesGroup);\n    switch (errorType) {\n        case RTFError.UnknownField:\n            return (`Your API was generated with an older version of the CLI that doesn't support backend subscription filtering.` +\n                'To enable backend subscription filtering, upgrade your Amplify CLI to the latest version and push your app by running `amplify upgrade` followed by `amplify push`');\n        case RTFError.MaxAttributes: {\n            let message = `Your selective sync expression for ${modelDefinition.name} contains ${selSyncFields.size} different model fields: ${selSyncFieldStr}.\\n\\n`;\n            if (dynamicAuthModeFields.size > 0) {\n                message +=\n                    `Note: the number of fields you can use with selective sync is affected by @auth rules configured on the model.\\n\\n` +\n                        `Dynamic auth modes, such as owner auth and dynamic group auth each utilize 1 field.\\n` +\n                        `You currently have ${dynamicAuthModeFields.size} dynamic auth mode(s) configured on this model: ${dynamicAuthFieldsStr}.`;\n            }\n            return message;\n        }\n        case RTFError.MaxCombinations: {\n            let message = `Your selective sync expression for ${modelDefinition.name} contains ${filterCombinations} field combinations (total number of predicates in an OR expression).\\n\\n`;\n            if (dynamicAuthModeFields.size > 0) {\n                message +=\n                    `Note: the number of fields you can use with selective sync is affected by @auth rules configured on the model.\\n\\n` +\n                        `Dynamic auth modes, such as owner auth and dynamic group auth factor in to the number of combinations you're using.\\n` +\n                        `You currently have ${dynamicAuthModeFields.size} dynamic auth mode(s) configured on this model: ${dynamicAuthFieldsStr}.`;\n            }\n            return message;\n        }\n        case RTFError.RepeatedFieldname:\n            return `Your selective sync expression for ${modelDefinition.name} contains multiple entries for ${repeatedField} in the same AND group.`;\n        case RTFError.NotGroup:\n            return (`Your selective sync expression for ${modelDefinition.name} uses a \\`not\\` group. If you'd like to filter subscriptions in the backend, ` +\n                `rewrite your expression using \\`ne\\` or \\`notContains\\` operators.`);\n        case RTFError.FieldNotInType:\n            // no remediation instructions. We'll surface the message directly\n            return '';\n    }\n}\nexport function getUserGroupsFromToken(token, rule) {\n    // validate token against groupClaim\n    let userGroups = token[rule.groupClaim] || [];\n    if (typeof userGroups === 'string') {\n        let parsedGroups;\n        try {\n            parsedGroups = JSON.parse(userGroups);\n        }\n        catch (e) {\n            parsedGroups = userGroups;\n        }\n        userGroups = [].concat(parsedGroups);\n    }\n    return userGroups;\n}\nexport async function getModelAuthModes({ authModeStrategy, defaultAuthMode, modelName, schema, }) {\n    const operations = Object.values(ModelOperation);\n    const modelAuthModes = {\n        CREATE: [],\n        READ: [],\n        UPDATE: [],\n        DELETE: [],\n    };\n    try {\n        await Promise.all(operations.map(async (operation) => {\n            const authModes = await authModeStrategy({\n                schema,\n                modelName,\n                operation,\n            });\n            if (typeof authModes === 'string') {\n                modelAuthModes[operation] = [authModes];\n            }\n            else if (Array.isArray(authModes) && authModes.length) {\n                modelAuthModes[operation] = authModes;\n            }\n            else {\n                // Use default auth mode if nothing is returned from authModeStrategy\n                modelAuthModes[operation] = [defaultAuthMode];\n            }\n        }));\n    }\n    catch (error) {\n        logger.debug(`Error getting auth modes for model: ${modelName}`, error);\n    }\n    return modelAuthModes;\n}\nexport function getForbiddenError(error) {\n    const forbiddenErrorCodes = [401, 403];\n    let forbiddenError;\n    if (error && error.errors) {\n        forbiddenError = error.errors.find(err => forbiddenErrorCodes.includes(resolveServiceErrorStatusCode(err)));\n    }\n    else if (error && error.message) {\n        forbiddenError = error;\n    }\n    if (forbiddenError) {\n        return (forbiddenError.message ??\n            `Request failed with status code ${resolveServiceErrorStatusCode(forbiddenError)}`);\n    }\n    return null;\n}\nexport function resolveServiceErrorStatusCode(error) {\n    if (error?.['$metadata']?.['httpStatusCode']) {\n        return Number(error?.['$metadata']?.['httpStatusCode']);\n    }\n    else if (error?.originalError) {\n        return resolveServiceErrorStatusCode(error?.originalError);\n    }\n    else {\n        return null;\n    }\n}\nexport function getClientSideAuthError(error) {\n    const clientSideAuthErrors = Object.values(GraphQLAuthError);\n    const clientSideError = error &&\n        error.message &&\n        clientSideAuthErrors.find(clientError => error.message.includes(clientError));\n    return clientSideError || null;\n}\nexport async function getTokenForCustomAuth(authMode, amplifyConfig = {}) {\n    if (authMode === 'lambda') {\n        const { authProviders: { functionAuthProvider } = { functionAuthProvider: null }, } = amplifyConfig;\n        if (functionAuthProvider && typeof functionAuthProvider === 'function') {\n            try {\n                const { token } = await functionAuthProvider();\n                return token;\n            }\n            catch (error) {\n                throw new Error(`Error retrieving token from \\`functionAuthProvider\\`: ${error}`);\n            }\n        }\n        else {\n            // TODO: add docs link once available\n            throw new Error('You must provide a `functionAuthProvider` function to `DataStore.configure` when using lambda');\n        }\n    }\n}\n// Util that takes a modelDefinition and model and returns either the id value(s) or the custom primary key value(s)\nexport function getIdentifierValue(modelDefinition, model) {\n    const pkFieldNames = extractPrimaryKeyFieldNames(modelDefinition);\n    const idOrPk = pkFieldNames.map(f => model[f]).join(IDENTIFIER_KEY_SEPARATOR);\n    return idOrPk;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}