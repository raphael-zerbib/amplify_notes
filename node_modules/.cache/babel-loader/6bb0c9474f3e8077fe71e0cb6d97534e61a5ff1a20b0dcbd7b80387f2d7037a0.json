{"ast":null,"code":"import * as React from 'react';\nimport { isDesignToken } from '@aws-amplify/ui';\nimport { ComponentPropsToStylePropsMap } from '../types/style.mjs';\nimport { getValueAtCurrentBreakpoint } from './responsive/utils.mjs';\nimport { useBreakpoint } from './responsive/useBreakpoint.mjs';\nimport { useTheme } from '../../hooks/useTheme.mjs';\nimport { getStyleValue } from './getStyleValue.mjs';\nimport { isNullOrEmptyString, isEmptyString, getCSSVariableIfValueIsThemeKey } from './utils.mjs';\nconst isSpanPrimitiveValue = spanValue => {\n  return spanValue === 'auto' || typeof spanValue === 'number' && !isNaN(spanValue) || typeof spanValue === 'string' && !isNaN(parseFloat(spanValue));\n};\nconst getGridSpan = spanValue => {\n  return spanValue === 'auto' ? 'auto' : \"span \".concat(spanValue);\n};\nconst convertGridSpan = spanValue => {\n  // PropertyType\n  if (isSpanPrimitiveValue(spanValue)) {\n    return getGridSpan(spanValue);\n  }\n  // PropertyType[]\n  if (Array.isArray(spanValue)) {\n    return spanValue.map(value => getGridSpan(value));\n  }\n  // ResponsiveObject<PropertyType>\n  if (typeof spanValue === 'object' && spanValue != null) {\n    return Object.entries(spanValue).reduce((acc, _ref) => {\n      let [key, value] = _ref;\n      return {\n        ...acc,\n        [key]: getGridSpan(value)\n      };\n    }, {});\n  }\n  return null;\n};\n/**\n * Transforms style props to another target prop\n * where the original is a simpler API than the target.\n * This function will remove the original prop and\n * replace target prop values with calculated\n * E.g. rowSpan => row, columnSpan => column\n */\nconst useTransformStyleProps = props => {\n  const {\n    rowSpan,\n    columnSpan,\n    row,\n    column,\n    ...rest\n  } = props;\n  const {\n    rowFromSpanValue,\n    columnFromSpanValue\n  } = React.useMemo(() => {\n    return {\n      rowFromSpanValue: convertGridSpan(rowSpan),\n      columnFromSpanValue: convertGridSpan(columnSpan)\n    };\n  }, [rowSpan, columnSpan]);\n  return {\n    row: !isNullOrEmptyString(row) ? row : rowFromSpanValue,\n    column: !isNullOrEmptyString(column) ? column : columnFromSpanValue,\n    ...rest\n  };\n};\nconst isComponentStyleProp = key => {\n  return key in ComponentPropsToStylePropsMap;\n};\n/**\n * Convert style props to CSS variables for React style prop\n * Note: Will filter out undefined, null, and empty string prop values\n */\nconst convertStylePropsToStyleObj = _ref2 => {\n  let {\n    props = {},\n    style = {},\n    breakpoint,\n    breakpoints,\n    tokens\n  } = _ref2;\n  const nonStyleProps = {};\n  Object.keys(props).filter(propKey => props[propKey] !== null).forEach(propKey => {\n    if (isComponentStyleProp(propKey)) {\n      const values = props[propKey];\n      if (!values || isEmptyString(values)) return;\n      const reactStyleProp = ComponentPropsToStylePropsMap[propKey];\n      // short circuit the style prop here if it is a string or design token\n      // so we don't have to call getValueAtCurrentBreakpoint every time\n      let value = '';\n      if (isDesignToken(values)) {\n        value = values.toString();\n      } else if (typeof values === 'string') {\n        value = getCSSVariableIfValueIsThemeKey(propKey, values, tokens);\n      } else if (typeof values === 'number') {\n        value = values;\n      } else if (typeof values === 'object') {\n        // here values should be a responsive array or object\n        value = getStyleValue({\n          propKey,\n          tokens,\n          value: getValueAtCurrentBreakpoint({\n            values,\n            breakpoint,\n            breakpoints\n          })\n        });\n      }\n      style = {\n        ...style,\n        [reactStyleProp]: value\n      };\n    } else if (typeof props[propKey] !== 'undefined') {\n      nonStyleProps[propKey] = props[propKey];\n    }\n  });\n  return {\n    propStyles: style,\n    nonStyleProps\n  };\n};\nconst useStyles = (props, style) => {\n  const {\n    breakpoints: {\n      values: breakpoints,\n      defaultBreakpoint\n    },\n    tokens\n  } = useTheme();\n  const breakpoint = useBreakpoint({\n    breakpoints,\n    defaultBreakpoint\n  });\n  const propStyles = useTransformStyleProps(props);\n  return React.useMemo(() => convertStylePropsToStyleObj({\n    props: propStyles,\n    style,\n    breakpoint,\n    breakpoints,\n    tokens\n  }), [propStyles, style, breakpoints, breakpoint, tokens]);\n};\nexport { convertGridSpan, convertStylePropsToStyleObj, getGridSpan, isSpanPrimitiveValue, useStyles, useTransformStyleProps };","map":{"version":3,"names":["React","isDesignToken","ComponentPropsToStylePropsMap","getValueAtCurrentBreakpoint","useBreakpoint","useTheme","getStyleValue","isNullOrEmptyString","isEmptyString","getCSSVariableIfValueIsThemeKey","isSpanPrimitiveValue","spanValue","isNaN","parseFloat","getGridSpan","concat","convertGridSpan","Array","isArray","map","value","Object","entries","reduce","acc","_ref","key","useTransformStyleProps","props","rowSpan","columnSpan","row","column","rest","rowFromSpanValue","columnFromSpanValue","useMemo","isComponentStyleProp","convertStylePropsToStyleObj","_ref2","style","breakpoint","breakpoints","tokens","nonStyleProps","keys","filter","propKey","forEach","values","reactStyleProp","toString","propStyles","useStyles","defaultBreakpoint"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/ui-react/dist/esm/primitives/shared/styleUtils.mjs"],"sourcesContent":["import * as React from 'react';\nimport { isDesignToken } from '@aws-amplify/ui';\nimport { ComponentPropsToStylePropsMap } from '../types/style.mjs';\nimport { getValueAtCurrentBreakpoint } from './responsive/utils.mjs';\nimport { useBreakpoint } from './responsive/useBreakpoint.mjs';\nimport { useTheme } from '../../hooks/useTheme.mjs';\nimport { getStyleValue } from './getStyleValue.mjs';\nimport { isNullOrEmptyString, isEmptyString, getCSSVariableIfValueIsThemeKey } from './utils.mjs';\n\nconst isSpanPrimitiveValue = (spanValue) => {\n    return (spanValue === 'auto' ||\n        (typeof spanValue === 'number' && !isNaN(spanValue)) ||\n        (typeof spanValue === 'string' && !isNaN(parseFloat(spanValue))));\n};\nconst getGridSpan = (spanValue) => {\n    return spanValue === 'auto' ? 'auto' : `span ${spanValue}`;\n};\nconst convertGridSpan = (spanValue) => {\n    // PropertyType\n    if (isSpanPrimitiveValue(spanValue)) {\n        return getGridSpan(spanValue);\n    }\n    // PropertyType[]\n    if (Array.isArray(spanValue)) {\n        return spanValue.map((value) => getGridSpan(value));\n    }\n    // ResponsiveObject<PropertyType>\n    if (typeof spanValue === 'object' && spanValue != null) {\n        return Object.entries(spanValue).reduce((acc, [key, value]) => ({ ...acc, [key]: getGridSpan(value) }), {});\n    }\n    return null;\n};\n/**\n * Transforms style props to another target prop\n * where the original is a simpler API than the target.\n * This function will remove the original prop and\n * replace target prop values with calculated\n * E.g. rowSpan => row, columnSpan => column\n */\nconst useTransformStyleProps = (props) => {\n    const { rowSpan, columnSpan, row, column, ...rest } = props;\n    const { rowFromSpanValue, columnFromSpanValue } = React.useMemo(() => {\n        return {\n            rowFromSpanValue: convertGridSpan(rowSpan),\n            columnFromSpanValue: convertGridSpan(columnSpan),\n        };\n    }, [rowSpan, columnSpan]);\n    return {\n        row: !isNullOrEmptyString(row) ? row : rowFromSpanValue,\n        column: !isNullOrEmptyString(column) ? column : columnFromSpanValue,\n        ...rest,\n    };\n};\nconst isComponentStyleProp = (key) => {\n    return key in ComponentPropsToStylePropsMap;\n};\n/**\n * Convert style props to CSS variables for React style prop\n * Note: Will filter out undefined, null, and empty string prop values\n */\nconst convertStylePropsToStyleObj = ({ props = {}, style = {}, breakpoint, breakpoints, tokens, }) => {\n    const nonStyleProps = {};\n    Object.keys(props)\n        .filter((propKey) => props[propKey] !== null)\n        .forEach((propKey) => {\n        if (isComponentStyleProp(propKey)) {\n            const values = props[propKey];\n            if (!values || isEmptyString(values))\n                return;\n            const reactStyleProp = ComponentPropsToStylePropsMap[propKey];\n            // short circuit the style prop here if it is a string or design token\n            // so we don't have to call getValueAtCurrentBreakpoint every time\n            let value = '';\n            if (isDesignToken(values)) {\n                value = values.toString();\n            }\n            else if (typeof values === 'string') {\n                value = getCSSVariableIfValueIsThemeKey(propKey, values, tokens);\n            }\n            else if (typeof values === 'number') {\n                value = values;\n            }\n            else if (typeof values === 'object') {\n                // here values should be a responsive array or object\n                value = getStyleValue({\n                    propKey,\n                    tokens,\n                    value: getValueAtCurrentBreakpoint({\n                        values,\n                        breakpoint,\n                        breakpoints,\n                    }),\n                });\n            }\n            style = {\n                ...style,\n                [reactStyleProp]: value,\n            };\n        }\n        else if (typeof props[propKey] !== 'undefined') {\n            nonStyleProps[propKey] = props[propKey];\n        }\n    });\n    return { propStyles: style, nonStyleProps };\n};\nconst useStyles = (props, style) => {\n    const { breakpoints: { values: breakpoints, defaultBreakpoint }, tokens, } = useTheme();\n    const breakpoint = useBreakpoint({\n        breakpoints,\n        defaultBreakpoint,\n    });\n    const propStyles = useTransformStyleProps(props);\n    return React.useMemo(() => convertStylePropsToStyleObj({\n        props: propStyles,\n        style,\n        breakpoint,\n        breakpoints,\n        tokens,\n    }), [propStyles, style, breakpoints, breakpoint, tokens]);\n};\n\nexport { convertGridSpan, convertStylePropsToStyleObj, getGridSpan, isSpanPrimitiveValue, useStyles, useTransformStyleProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}