{"ast":null,"code":"import { withMemoization } from '@aws-amplify/core/internals/aws-client-utils';\nimport { ConsoleLogger } from '@aws-amplify/core';\nimport { CanceledError } from '../../../../../errors/CanceledError.mjs';\nimport { NETWORK_ERROR_MESSAGE, ABORT_ERROR_MESSAGE, NETWORK_ERROR_CODE, ABORT_ERROR_CODE, CANCELED_ERROR_CODE, CANCELED_ERROR_MESSAGE } from './constants.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('xhr-http-handler');\n/**\n * Base transfer handler implementation using XMLHttpRequest to support upload and download progress events.\n *\n * @param request - The request object.\n * @param options - The request options.\n * @returns A promise that will be resolved with the response object.\n *\n * @internal\n */\nconst xhrTransferHandler = (request, options) => {\n  const {\n    url,\n    method,\n    headers,\n    body\n  } = request;\n  const {\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    abortSignal\n  } = options;\n  return new Promise((resolve, reject) => {\n    let xhr = new XMLHttpRequest();\n    xhr.open(method.toUpperCase(), url.toString());\n    Object.entries(headers).filter(_ref => {\n      let [header] = _ref;\n      return !FORBIDDEN_HEADERS.includes(header);\n    }).forEach(_ref2 => {\n      let [header, value] = _ref2;\n      xhr.setRequestHeader(header, value);\n    });\n    xhr.responseType = responseType;\n    if (onDownloadProgress) {\n      xhr.addEventListener('progress', event => {\n        onDownloadProgress(convertToTransferProgressEvent(event));\n        logger.debug(event);\n      });\n    }\n    if (onUploadProgress) {\n      xhr.upload.addEventListener('progress', event => {\n        onUploadProgress(convertToTransferProgressEvent(event));\n        logger.debug(event);\n      });\n    }\n    xhr.addEventListener('error', () => {\n      const networkError = buildHandlerError(NETWORK_ERROR_MESSAGE, NETWORK_ERROR_CODE);\n      logger.error(NETWORK_ERROR_MESSAGE);\n      reject(networkError);\n      xhr = null; // clean up request\n    });\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    xhr.addEventListener('abort', () => {\n      // The abort event can be triggered after the error or load event. So we need to check if the xhr is null.\n      // When request is aborted by AbortSignal, the promise is rejected in the abortSignal's 'abort' event listener.\n      if (!xhr || abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted) return;\n      // Handle abort request caused by browser instead of AbortController\n      // see: https://github.com/axios/axios/issues/537\n      const error = buildHandlerError(ABORT_ERROR_MESSAGE, ABORT_ERROR_CODE);\n      logger.error(ABORT_ERROR_MESSAGE);\n      reject(error);\n      xhr = null; // clean up request\n    });\n    // Skip handling timeout error since we don't have a timeout\n    xhr.addEventListener('readystatechange', () => {\n      if (!xhr || xhr.readyState !== xhr.DONE) {\n        return;\n      }\n      const onloadend = () => {\n        // The load event is triggered after the error/abort/load event. So we need to check if the xhr is null.\n        if (!xhr) return;\n        const responseHeaders = convertResponseHeaders(xhr.getAllResponseHeaders());\n        const {\n          responseType: loadEndResponseType\n        } = xhr;\n        const responseBlob = xhr.response;\n        const responseText = loadEndResponseType === 'text' ? xhr.responseText : '';\n        const bodyMixIn = {\n          blob: () => Promise.resolve(responseBlob),\n          text: withMemoization(() => loadEndResponseType === 'blob' ? readBlobAsText(responseBlob) : Promise.resolve(responseText)),\n          json: () => Promise.reject(\n          // S3 does not support JSON response. So fail-fast here with nicer error message.\n          new Error('Parsing response to JSON is not implemented. Please use response.text() instead.'))\n        };\n        const response = {\n          statusCode: xhr.status,\n          headers: responseHeaders,\n          // The xhr.responseType is only set to 'blob' for streaming binary S3 object data. The streaming data is\n          // exposed via public interface of Storage.get(). So we need to return the response as a Blob object for\n          // backward compatibility. In other cases, the response payload is only used internally, we return it is\n          // {@link ResponseBodyMixin}\n          body: xhr.responseType === 'blob' ? Object.assign(responseBlob, bodyMixIn) : bodyMixIn\n        };\n        resolve(response);\n        xhr = null; // clean up request\n      };\n      // readystate handler is calling before onerror or ontimeout handlers,\n      // so we should call onloadend on the next 'tick'\n      // @see https://github.com/axios/axios/blob/9588fcdec8aca45c3ba2f7968988a5d03f23168c/lib/adapters/xhr.js#L98-L99\n      setTimeout(onloadend);\n    });\n    if (abortSignal) {\n      const onCanceled = () => {\n        // The abort event is triggered after the error or load event. So we need to check if the xhr is null.\n        if (!xhr) {\n          return;\n        }\n        const canceledError = new CanceledError({\n          name: CANCELED_ERROR_CODE,\n          message: CANCELED_ERROR_MESSAGE\n        });\n        reject(canceledError);\n        xhr.abort();\n        xhr = null;\n      };\n      abortSignal.aborted ? onCanceled() : abortSignal.addEventListener('abort', onCanceled);\n    }\n    if (typeof ReadableStream === 'function' && body instanceof ReadableStream) {\n      // This does not matter as previous implementation uses Axios which does not support ReadableStream anyway.\n      throw new Error('ReadableStream request payload is not supported.');\n    }\n    xhr.send(body !== null && body !== void 0 ? body : null);\n  });\n};\nconst convertToTransferProgressEvent = event => ({\n  transferredBytes: event.loaded,\n  totalBytes: event.lengthComputable ? event.total : undefined\n});\nconst buildHandlerError = (message, name) => {\n  const error = new Error(message);\n  error.name = name;\n  return error;\n};\n/**\n * Convert xhr.getAllResponseHeaders() string to a Record<string, string>. Note that modern browser already returns\n * header names in lowercase.\n * @param xhrHeaders - string of headers returned from xhr.getAllResponseHeaders()\n */\nconst convertResponseHeaders = xhrHeaders => {\n  if (!xhrHeaders) {\n    return {};\n  }\n  return xhrHeaders.split('\\r\\n').reduce((headerMap, line) => {\n    const parts = line.split(': ');\n    const header = parts.shift();\n    const value = parts.join(': ');\n    headerMap[header.toLowerCase()] = value;\n    return headerMap;\n  }, {});\n};\nconst readBlobAsText = blob => {\n  const reader = new FileReader();\n  return new Promise((resolve, reject) => {\n    reader.onloadend = () => {\n      if (reader.readyState !== FileReader.DONE) {\n        return;\n      }\n      resolve(reader.result);\n    };\n    reader.onerror = () => {\n      reject(reader.error);\n    };\n    reader.readAsText(blob);\n  });\n};\n// To add more forbidden headers as found set by S3. Intentionally NOT list all of them here to save bundle size.\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS = ['host'];\nexport { xhrTransferHandler };","map":{"version":3,"names":["logger","ConsoleLogger","xhrTransferHandler","request","options","url","method","headers","body","onDownloadProgress","onUploadProgress","responseType","abortSignal","Promise","resolve","reject","xhr","XMLHttpRequest","open","toUpperCase","toString","Object","entries","filter","_ref","header","FORBIDDEN_HEADERS","includes","forEach","_ref2","value","setRequestHeader","addEventListener","event","convertToTransferProgressEvent","debug","upload","networkError","buildHandlerError","NETWORK_ERROR_MESSAGE","NETWORK_ERROR_CODE","error","aborted","ABORT_ERROR_MESSAGE","ABORT_ERROR_CODE","readyState","DONE","onloadend","responseHeaders","convertResponseHeaders","getAllResponseHeaders","loadEndResponseType","responseBlob","response","responseText","bodyMixIn","blob","text","withMemoization","readBlobAsText","json","Error","statusCode","status","assign","setTimeout","onCanceled","canceledError","CanceledError","name","CANCELED_ERROR_CODE","message","CANCELED_ERROR_MESSAGE","abort","ReadableStream","send","transferredBytes","loaded","totalBytes","lengthComputable","total","undefined","xhrHeaders","split","reduce","headerMap","line","parts","shift","join","toLowerCase","reader","FileReader","result","onerror","readAsText"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/storage/src/providers/s3/utils/client/runtime/xhrTransferHandler.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { withMemoization, } from '@aws-amplify/core/internals/aws-client-utils';\nimport { ConsoleLogger } from '@aws-amplify/core';\nimport { CanceledError } from '../../../../../errors/CanceledError';\nimport { ABORT_ERROR_CODE, ABORT_ERROR_MESSAGE, CANCELED_ERROR_CODE, CANCELED_ERROR_MESSAGE, NETWORK_ERROR_CODE, NETWORK_ERROR_MESSAGE, } from './constants';\nconst logger = new ConsoleLogger('xhr-http-handler');\n/**\n * Base transfer handler implementation using XMLHttpRequest to support upload and download progress events.\n *\n * @param request - The request object.\n * @param options - The request options.\n * @returns A promise that will be resolved with the response object.\n *\n * @internal\n */\nexport const xhrTransferHandler = (request, options) => {\n    const { url, method, headers, body } = request;\n    const { onDownloadProgress, onUploadProgress, responseType, abortSignal } = options;\n    return new Promise((resolve, reject) => {\n        let xhr = new XMLHttpRequest();\n        xhr.open(method.toUpperCase(), url.toString());\n        Object.entries(headers)\n            .filter(([header]) => !FORBIDDEN_HEADERS.includes(header))\n            .forEach(([header, value]) => {\n            xhr.setRequestHeader(header, value);\n        });\n        xhr.responseType = responseType;\n        if (onDownloadProgress) {\n            xhr.addEventListener('progress', event => {\n                onDownloadProgress(convertToTransferProgressEvent(event));\n                logger.debug(event);\n            });\n        }\n        if (onUploadProgress) {\n            xhr.upload.addEventListener('progress', event => {\n                onUploadProgress(convertToTransferProgressEvent(event));\n                logger.debug(event);\n            });\n        }\n        xhr.addEventListener('error', () => {\n            const networkError = buildHandlerError(NETWORK_ERROR_MESSAGE, NETWORK_ERROR_CODE);\n            logger.error(NETWORK_ERROR_MESSAGE);\n            reject(networkError);\n            xhr = null; // clean up request\n        });\n        // Handle browser request cancellation (as opposed to a manual cancellation)\n        xhr.addEventListener('abort', () => {\n            // The abort event can be triggered after the error or load event. So we need to check if the xhr is null.\n            // When request is aborted by AbortSignal, the promise is rejected in the abortSignal's 'abort' event listener.\n            if (!xhr || abortSignal?.aborted)\n                return;\n            // Handle abort request caused by browser instead of AbortController\n            // see: https://github.com/axios/axios/issues/537\n            const error = buildHandlerError(ABORT_ERROR_MESSAGE, ABORT_ERROR_CODE);\n            logger.error(ABORT_ERROR_MESSAGE);\n            reject(error);\n            xhr = null; // clean up request\n        });\n        // Skip handling timeout error since we don't have a timeout\n        xhr.addEventListener('readystatechange', () => {\n            if (!xhr || xhr.readyState !== xhr.DONE) {\n                return;\n            }\n            const onloadend = () => {\n                // The load event is triggered after the error/abort/load event. So we need to check if the xhr is null.\n                if (!xhr)\n                    return;\n                const responseHeaders = convertResponseHeaders(xhr.getAllResponseHeaders());\n                const { responseType: loadEndResponseType } = xhr;\n                const responseBlob = xhr.response;\n                const responseText = loadEndResponseType === 'text' ? xhr.responseText : '';\n                const bodyMixIn = {\n                    blob: () => Promise.resolve(responseBlob),\n                    text: withMemoization(() => loadEndResponseType === 'blob'\n                        ? readBlobAsText(responseBlob)\n                        : Promise.resolve(responseText)),\n                    json: () => Promise.reject(\n                    // S3 does not support JSON response. So fail-fast here with nicer error message.\n                    new Error('Parsing response to JSON is not implemented. Please use response.text() instead.')),\n                };\n                const response = {\n                    statusCode: xhr.status,\n                    headers: responseHeaders,\n                    // The xhr.responseType is only set to 'blob' for streaming binary S3 object data. The streaming data is\n                    // exposed via public interface of Storage.get(). So we need to return the response as a Blob object for\n                    // backward compatibility. In other cases, the response payload is only used internally, we return it is\n                    // {@link ResponseBodyMixin}\n                    body: (xhr.responseType === 'blob'\n                        ? Object.assign(responseBlob, bodyMixIn)\n                        : bodyMixIn),\n                };\n                resolve(response);\n                xhr = null; // clean up request\n            };\n            // readystate handler is calling before onerror or ontimeout handlers,\n            // so we should call onloadend on the next 'tick'\n            // @see https://github.com/axios/axios/blob/9588fcdec8aca45c3ba2f7968988a5d03f23168c/lib/adapters/xhr.js#L98-L99\n            setTimeout(onloadend);\n        });\n        if (abortSignal) {\n            const onCanceled = () => {\n                // The abort event is triggered after the error or load event. So we need to check if the xhr is null.\n                if (!xhr) {\n                    return;\n                }\n                const canceledError = new CanceledError({\n                    name: CANCELED_ERROR_CODE,\n                    message: CANCELED_ERROR_MESSAGE,\n                });\n                reject(canceledError);\n                xhr.abort();\n                xhr = null;\n            };\n            abortSignal.aborted\n                ? onCanceled()\n                : abortSignal.addEventListener('abort', onCanceled);\n        }\n        if (typeof ReadableStream === 'function' &&\n            body instanceof ReadableStream) {\n            // This does not matter as previous implementation uses Axios which does not support ReadableStream anyway.\n            throw new Error('ReadableStream request payload is not supported.');\n        }\n        xhr.send(body ?? null);\n    });\n};\nconst convertToTransferProgressEvent = (event) => ({\n    transferredBytes: event.loaded,\n    totalBytes: event.lengthComputable ? event.total : undefined,\n});\nconst buildHandlerError = (message, name) => {\n    const error = new Error(message);\n    error.name = name;\n    return error;\n};\n/**\n * Convert xhr.getAllResponseHeaders() string to a Record<string, string>. Note that modern browser already returns\n * header names in lowercase.\n * @param xhrHeaders - string of headers returned from xhr.getAllResponseHeaders()\n */\nconst convertResponseHeaders = (xhrHeaders) => {\n    if (!xhrHeaders) {\n        return {};\n    }\n    return xhrHeaders\n        .split('\\r\\n')\n        .reduce((headerMap, line) => {\n        const parts = line.split(': ');\n        const header = parts.shift();\n        const value = parts.join(': ');\n        headerMap[header.toLowerCase()] = value;\n        return headerMap;\n    }, {});\n};\nconst readBlobAsText = (blob) => {\n    const reader = new FileReader();\n    return new Promise((resolve, reject) => {\n        reader.onloadend = () => {\n            if (reader.readyState !== FileReader.DONE) {\n                return;\n            }\n            resolve(reader.result);\n        };\n        reader.onerror = () => {\n            reject(reader.error);\n        };\n        reader.readAsText(blob);\n    });\n};\n// To add more forbidden headers as found set by S3. Intentionally NOT list all of them here to save bundle size.\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS = ['host'];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}