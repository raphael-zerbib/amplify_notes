{"ast":null,"code":"import { monotonicFactory } from 'ulid';\nimport { amplifyUuid, AmplifyUrl, WordArray } from '@aws-amplify/core/internals/utils';\nimport { produce, applyPatches } from 'immer';\nimport { isPredicateObj, isPredicateGroup, SortDirection, LimitTimerRaceResolvedValues, isModelAttributeCompositeKey, isModelAttributeKey, isModelAttributePrimaryKey } from './types.mjs';\nimport './predicates/index.mjs';\nimport { ModelSortPredicateCreator } from './predicates/sort.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst ID = 'id';\n/**\n * Used by the Async Storage Adapter to concatenate key values\n * for a record. For instance, if a model has the following keys:\n * `customId: ID! @primaryKey(sortKeyFields: [\"createdAt\"])`,\n * we concatenate the `customId` and `createdAt` as:\n * `12-234-5#2022-09-28T00:00:00.000Z`\n */\nconst DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR = '#';\n/**\n * Used for generating spinal-cased index name from an array of\n * key field names.\n * E.g. for keys `[id, title]` => 'id-title'\n */\nconst IDENTIFIER_KEY_SEPARATOR = '-';\nconst errorMessages = {\n  idEmptyString: 'An index field cannot contain an empty string value',\n  queryByPkWithCompositeKeyPresent: 'Models with composite primary keys cannot be queried by a single key value. Use object literal syntax for composite keys instead: https://docs.amplify.aws/lib/datastore/advanced-workflows/q/platform/js/#querying-records-with-custom-primary-keys',\n  deleteByPkWithCompositeKeyPresent: 'Models with composite primary keys cannot be deleted by a single key value, unless using a predicate. Use object literal syntax for composite keys instead: https://docs.amplify.aws/lib/datastore/advanced-workflows/q/platform/js/#querying-records-with-custom-primary-keys',\n  observeWithObjectLiteral: 'Object literal syntax cannot be used with observe. Use a predicate instead: https://docs.amplify.aws/lib/datastore/data-access/q/platform/js/#predicates'\n};\nvar NAMESPACES;\n(function (NAMESPACES) {\n  NAMESPACES[\"DATASTORE\"] = \"datastore\";\n  NAMESPACES[\"USER\"] = \"user\";\n  NAMESPACES[\"SYNC\"] = \"sync\";\n  NAMESPACES[\"STORAGE\"] = \"storage\";\n})(NAMESPACES || (NAMESPACES = {}));\nconst DATASTORE = NAMESPACES.DATASTORE;\nconst USER = NAMESPACES.USER;\nconst SYNC = NAMESPACES.SYNC;\nconst STORAGE = NAMESPACES.STORAGE;\nconst exhaustiveCheck = function (obj) {\n  let throwOnError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (throwOnError) {\n    throw new Error(\"Invalid \".concat(obj));\n  }\n};\nconst isNullOrUndefined = val => {\n  return typeof val === 'undefined' || val === undefined || val === null;\n};\nconst validatePredicate = (model, groupType, predicatesOrGroups) => {\n  let filterType;\n  let isNegation = false;\n  if (predicatesOrGroups.length === 0) {\n    return true;\n  }\n  switch (groupType) {\n    case 'not':\n      filterType = 'every';\n      isNegation = true;\n      break;\n    case 'and':\n      filterType = 'every';\n      break;\n    case 'or':\n      filterType = 'some';\n      break;\n    default:\n      throw new Error(\"Invalid \".concat(groupType));\n  }\n  const result = predicatesOrGroups[filterType](predicateOrGroup => {\n    if (isPredicateObj(predicateOrGroup)) {\n      const {\n        field,\n        operator,\n        operand\n      } = predicateOrGroup;\n      const value = model[field];\n      return validatePredicateField(value, operator, operand);\n    }\n    if (isPredicateGroup(predicateOrGroup)) {\n      const {\n        type,\n        predicates\n      } = predicateOrGroup;\n      return validatePredicate(model, type, predicates);\n    }\n    throw new Error('Not a predicate or group');\n  });\n  return isNegation ? !result : result;\n};\nconst validatePredicateField = (value, operator, operand) => {\n  switch (operator) {\n    case 'ne':\n      return value !== operand;\n    case 'eq':\n      return value === operand;\n    case 'le':\n      return value <= operand;\n    case 'lt':\n      return value < operand;\n    case 'ge':\n      return value >= operand;\n    case 'gt':\n      return value > operand;\n    case 'between':\n      const [min, max] = operand;\n      return value >= min && value <= max;\n    case 'beginsWith':\n      return !isNullOrUndefined(value) && value.startsWith(operand);\n    case 'contains':\n      return !isNullOrUndefined(value) && value.indexOf(operand) > -1;\n    case 'notContains':\n      return isNullOrUndefined(value) || value.indexOf(operand) === -1;\n    default:\n      return false;\n  }\n};\nconst isModelConstructor = obj => {\n  return obj && typeof obj.copyOf === 'function';\n};\nconst nonModelClasses = new WeakSet();\nfunction registerNonModelClass(clazz) {\n  nonModelClasses.add(clazz);\n}\nconst isNonModelConstructor = obj => {\n  return nonModelClasses.has(obj);\n};\nconst topologicallySortedModels = new WeakMap();\nconst traverseModel = (srcModelName, instance, namespace, modelInstanceCreator, getModelConstructorByModelName) => {\n  const modelConstructor = getModelConstructorByModelName(namespace.name, srcModelName);\n  const result = [];\n  const newInstance = modelConstructor.copyOf(instance, () => {});\n  result.unshift({\n    modelName: srcModelName,\n    item: newInstance,\n    instance: newInstance\n  });\n  if (!topologicallySortedModels.has(namespace)) {\n    topologicallySortedModels.set(namespace, Array.from(namespace.modelTopologicalOrdering.keys()));\n  }\n  const sortedModels = topologicallySortedModels.get(namespace);\n  result.sort((a, b) => {\n    return sortedModels.indexOf(a.modelName) - sortedModels.indexOf(b.modelName);\n  });\n  return result;\n};\nlet privateModeCheckResult;\nconst isPrivateMode = () => {\n  return new Promise(resolve => {\n    const dbname = amplifyUuid();\n    let db;\n    const isPrivate = () => {\n      privateModeCheckResult = false;\n      resolve(true);\n    };\n    const isNotPrivate = async () => {\n      if (db && db.result && typeof db.result.close === 'function') {\n        await db.result.close();\n      }\n      await indexedDB.deleteDatabase(dbname);\n      privateModeCheckResult = true;\n      return resolve(false);\n    };\n    if (privateModeCheckResult === true) {\n      return isNotPrivate();\n    }\n    if (privateModeCheckResult === false) {\n      return isPrivate();\n    }\n    if (indexedDB === null) return isPrivate();\n    db = indexedDB.open(dbname);\n    db.onerror = isPrivate;\n    db.onsuccess = isNotPrivate;\n  });\n};\nlet safariCompatabilityModeResult;\n/**\n * Whether the browser's implementation of IndexedDB breaks on array lookups\n * against composite indexes whose keypath contains a single column.\n *\n * E.g., Whether `store.createIndex(indexName, ['id'])` followed by\n * `store.index(indexName).get([1])` will *ever* return records.\n *\n * In all known, modern Safari browsers as of Q4 2022, the query against an index like\n * this will *always* return `undefined`. So, the index needs to be created as a scalar.\n */\nconst isSafariCompatabilityMode = async () => {\n  try {\n    const dbName = amplifyUuid();\n    const storeName = 'indexedDBFeatureProbeStore';\n    const indexName = 'idx';\n    if (indexedDB === null) return false;\n    if (safariCompatabilityModeResult !== undefined) {\n      return safariCompatabilityModeResult;\n    }\n    const db = await new Promise(resolve => {\n      const dbOpenRequest = indexedDB.open(dbName);\n      dbOpenRequest.onerror = () => resolve(false);\n      dbOpenRequest.onsuccess = () => {\n        const db = dbOpenRequest.result;\n        resolve(db);\n      };\n      dbOpenRequest.onupgradeneeded = event => {\n        var _event$target;\n        const db = event === null || event === void 0 || (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result;\n        db.onerror = () => resolve(false);\n        const store = db.createObjectStore(storeName, {\n          autoIncrement: true\n        });\n        store.createIndex(indexName, ['id']);\n      };\n    });\n    if (!db) {\n      throw new Error('Could not open probe DB');\n    }\n    const rwTx = db.transaction(storeName, 'readwrite');\n    const rwStore = rwTx.objectStore(storeName);\n    rwStore.add({\n      id: 1\n    });\n    rwTx.commit();\n    const result = await new Promise(resolve => {\n      const tx = db.transaction(storeName, 'readonly');\n      const store = tx.objectStore(storeName);\n      const index = store.index(indexName);\n      const getRequest = index.get([1]);\n      getRequest.onerror = () => resolve(false);\n      getRequest.onsuccess = event => {\n        var _event$target2;\n        resolve(event === null || event === void 0 || (_event$target2 = event.target) === null || _event$target2 === void 0 ? void 0 : _event$target2.result);\n      };\n    });\n    if (db && typeof db.close === 'function') {\n      await db.close();\n    }\n    await indexedDB.deleteDatabase(dbName);\n    if (result === undefined) {\n      safariCompatabilityModeResult = true;\n    } else {\n      safariCompatabilityModeResult = false;\n    }\n  } catch (error) {\n    safariCompatabilityModeResult = false;\n  }\n  return safariCompatabilityModeResult;\n};\nconst HEX_TO_SHORT = {};\nfor (let i = 0; i < 256; i++) {\n  let encodedByte = i.toString(16).toLowerCase();\n  if (encodedByte.length === 1) {\n    encodedByte = \"0\".concat(encodedByte);\n  }\n  HEX_TO_SHORT[encodedByte] = i;\n}\nconst getBytesFromHex = encoded => {\n  if (encoded.length % 2 !== 0) {\n    throw new Error('Hex encoded strings must have an even number length');\n  }\n  const out = new Uint8Array(encoded.length / 2);\n  for (let i = 0; i < encoded.length; i += 2) {\n    const encodedByte = encoded.slice(i, i + 2).toLowerCase();\n    if (encodedByte in HEX_TO_SHORT) {\n      out[i / 2] = HEX_TO_SHORT[encodedByte];\n    } else {\n      throw new Error(\"Cannot decode unrecognized sequence \".concat(encodedByte, \" as hexadecimal\"));\n    }\n  }\n  return out;\n};\nconst randomBytes = nBytes => {\n  const str = new WordArray().random(nBytes).toString();\n  return getBytesFromHex(str);\n};\nconst prng = () => randomBytes(1)[0] / 0xff;\nfunction monotonicUlidFactory(seed) {\n  const ulid = monotonicFactory(prng);\n  return () => {\n    return ulid(seed);\n  };\n}\n/**\n * Uses performance.now() if available, otherwise, uses Date.now() (e.g. react native without a polyfill)\n *\n * The values returned by performance.now() always increase at a constant rate,\n * independent of the system clock (which might be adjusted manually or skewed\n * by software like NTP).\n *\n * Otherwise, performance.timing.navigationStart + performance.now() will be\n * approximately equal to Date.now()\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Performance/now#Example\n */\nfunction getNow() {\n  if (typeof performance !== 'undefined' && performance && typeof performance.now === 'function') {\n    return performance.now() | 0; // convert to integer\n  } else {\n    return Date.now();\n  }\n}\nfunction sortCompareFunction(sortPredicates) {\n  return function compareFunction(a, b) {\n    // enable multi-field sort by iterating over predicates until\n    // a comparison returns -1 or 1\n    for (const predicate of sortPredicates) {\n      const {\n        field,\n        sortDirection\n      } = predicate;\n      // reverse result when direction is descending\n      const sortMultiplier = sortDirection === SortDirection.ASCENDING ? 1 : -1;\n      if (a[field] < b[field]) {\n        return -1 * sortMultiplier;\n      }\n      if (a[field] > b[field]) {\n        return 1 * sortMultiplier;\n      }\n    }\n    return 0;\n  };\n}\n/* deep directed comparison ensuring that all fields on \"from\" object exist and\n * are equal to values on an \"against\" object\n *\n * Note: This same guarauntee is not applied for values on \"against\" that aren't on \"from\"\n *\n * @param fromObject - The object that may be an equal subset of the againstObject.\n * @param againstObject - The object that may be an equal superset of the fromObject.\n *\n * @returns True if fromObject is a equal subset of againstObject and False otherwise.\n */\nfunction directedValueEquality(fromObject, againstObject) {\n  let nullish = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const aKeys = Object.keys(fromObject);\n  for (const key of aKeys) {\n    const fromValue = fromObject[key];\n    const againstValue = againstObject[key];\n    if (!valuesEqual(fromValue, againstValue, nullish)) {\n      return false;\n    }\n  }\n  return true;\n}\n// deep compare any 2 values\n// primitives or object types (including arrays, Sets, and Maps)\n// returns true if equal by value\n// if nullish is true, treat undefined and null values as equal\n// to normalize for GQL response values for undefined fields\nfunction valuesEqual(valA, valB) {\n  let nullish = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let a = valA;\n  let b = valB;\n  const nullishCompare = (_a, _b) => {\n    return (_a === undefined || _a === null) && (_b === undefined || _b === null);\n  };\n  // if one of the values is a primitive and the other is an object\n  if (a instanceof Object && !(b instanceof Object) || !(a instanceof Object) && b instanceof Object) {\n    return false;\n  }\n  // compare primitive types\n  if (!(a instanceof Object)) {\n    if (nullish && nullishCompare(a, b)) {\n      return true;\n    }\n    return a === b;\n  }\n  // make sure object types match\n  if (Array.isArray(a) && !Array.isArray(b) || Array.isArray(b) && !Array.isArray(a)) {\n    return false;\n  }\n  if (a instanceof Set && b instanceof Set) {\n    a = [...a];\n    b = [...b];\n  }\n  if (a instanceof Map && b instanceof Map) {\n    a = Object.fromEntries(a);\n    b = Object.fromEntries(b);\n  }\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  // last condition is to ensure that [] !== [null] even if nullish. However [undefined] === [null] when nullish\n  if (aKeys.length !== bKeys.length && (!nullish || Array.isArray(a))) {\n    return false;\n  }\n  // iterate through the longer set of keys\n  // e.g., for a nullish comparison of a={ a: 1 } and b={ a: 1, b: null }\n  // we want to iterate through bKeys\n  const keys = aKeys.length >= bKeys.length ? aKeys : bKeys;\n  for (const key of keys) {\n    const aVal = a[key];\n    const bVal = b[key];\n    if (!valuesEqual(aVal, bVal, nullish)) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Statelessly extracts the specified page from an array.\n *\n * @param records - The source array to extract a page from.\n * @param pagination - A definition of the page to extract.\n * @returns This items from `records` matching the `pagination` definition.\n */\nfunction inMemoryPagination(records, pagination) {\n  if (pagination && records.length > 1) {\n    if (pagination.sort) {\n      const sortPredicates = ModelSortPredicateCreator.getPredicates(pagination.sort);\n      if (sortPredicates.length) {\n        const compareFn = sortCompareFunction(sortPredicates);\n        records.sort(compareFn);\n      }\n    }\n    const {\n      page = 0,\n      limit = 0\n    } = pagination;\n    const start = Math.max(0, page * limit) || 0;\n    const end = limit > 0 ? start + limit : records.length;\n    return records.slice(start, end);\n  }\n  return records;\n}\n/**\n * An `aysnc` implementation of `Array.some()`. Returns as soon as a match is found.\n * @param items The items to check.\n * @param matches The async matcher function, expected to\n * return Promise<boolean>: `true` for a matching item, `false` otherwise.\n * @returns A `Promise<boolean>`, `true` if \"some\" items match; `false` otherwise.\n */\nasync function asyncSome(items, matches) {\n  for (const item of items) {\n    if (await matches(item)) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * An `aysnc` implementation of `Array.every()`. Returns as soon as a non-match is found.\n * @param items The items to check.\n * @param matches The async matcher function, expected to\n * return Promise<boolean>: `true` for a matching item, `false` otherwise.\n * @returns A `Promise<boolean>`, `true` if every item matches; `false` otherwise.\n */\nasync function asyncEvery(items, matches) {\n  for (const item of items) {\n    if (!(await matches(item))) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * An `async` implementation of `Array.filter()`. Returns after all items have been filtered.\n * TODO: Return AsyncIterable.\n * @param items The items to filter.\n * @param matches The `async` matcher function, expected to\n * return Promise<boolean>: `true` for a matching item, `false` otherwise.\n * @returns A `Promise<T>` of matching items.\n */\nasync function asyncFilter(items, matches) {\n  const results = [];\n  for (const item of items) {\n    if (await matches(item)) {\n      results.push(item);\n    }\n  }\n  return results;\n}\nconst isAWSDate = val => {\n  return !!/^\\d{4}-\\d{2}-\\d{2}(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(val);\n};\nconst isAWSTime = val => {\n  return !!/^\\d{2}:\\d{2}(:\\d{2}(.\\d+)?)?(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(val);\n};\nconst isAWSDateTime = val => {\n  return !!/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}(:\\d{2}(.\\d+)?)?(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(val);\n};\nconst isAWSTimestamp = val => {\n  return !!/^\\d+$/.exec(String(val));\n};\nconst isAWSEmail = val => {\n  return !!/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.exec(val);\n};\nconst isAWSJSON = val => {\n  try {\n    JSON.parse(val);\n    return true;\n  } catch {\n    return false;\n  }\n};\nconst isAWSURL = val => {\n  try {\n    return !!new AmplifyUrl(val);\n  } catch {\n    return false;\n  }\n};\nconst isAWSPhone = val => {\n  return !!/^\\+?\\d[\\d\\s-]+$/.exec(val);\n};\nconst isAWSIPAddress = val => {\n  return !!/((^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$)|(^((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?$))$/.exec(val);\n};\nclass DeferredPromise {\n  constructor() {\n    const self = this;\n    this.promise = new Promise((resolve, reject) => {\n      self.resolve = resolve;\n      self.reject = reject;\n    });\n  }\n}\nclass DeferredCallbackResolver {\n  constructor(options) {\n    this.limitPromise = new DeferredPromise();\n    this.raceInFlight = false;\n    this.callback = () => {};\n    this.defaultErrorHandler = function () {\n      let msg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'DeferredCallbackResolver error';\n      throw new Error(msg);\n    };\n    this.callback = options.callback;\n    this.errorHandler = options.errorHandler || this.defaultErrorHandler;\n    this.maxInterval = options.maxInterval || 2000;\n  }\n  startTimer() {\n    this.timerPromise = new Promise((resolve, reject) => {\n      this.timer = setTimeout(() => {\n        resolve(LimitTimerRaceResolvedValues.TIMER);\n      }, this.maxInterval);\n    });\n  }\n  async racePromises() {\n    let winner;\n    try {\n      this.raceInFlight = true;\n      this.startTimer();\n      winner = await Promise.race([this.timerPromise, this.limitPromise.promise]);\n      this.callback();\n    } catch (err) {\n      this.errorHandler(err);\n    } finally {\n      // reset for the next race\n      this.clear();\n      this.raceInFlight = false;\n      this.limitPromise = new DeferredPromise();\n      return winner;\n    }\n  }\n  start() {\n    if (!this.raceInFlight) this.racePromises();\n  }\n  clear() {\n    clearTimeout(this.timer);\n  }\n  resolve() {\n    this.limitPromise.resolve(LimitTimerRaceResolvedValues.LIMIT);\n  }\n}\n/**\n * merge two sets of patches created by immer produce.\n * newPatches take precedent over oldPatches for patches modifying the same path.\n * In the case many consecutive pathces are merged the original model should\n * always be the root model.\n *\n * Example:\n * A -> B, patches1\n * B -> C, patches2\n *\n * mergePatches(A, patches1, patches2) to get patches for A -> C\n *\n * @param originalSource the original Model the patches should be applied to\n * @param oldPatches immer produce patch list\n * @param newPatches immer produce patch list (will take precedence)\n * @return merged patches\n */\nfunction mergePatches(originalSource, oldPatches, newPatches) {\n  const patchesToMerge = oldPatches.concat(newPatches);\n  let patches;\n  produce(originalSource, draft => {\n    applyPatches(draft, patchesToMerge);\n  }, p => {\n    patches = p;\n  });\n  return patches;\n}\nconst getStorename = (namespace, modelName) => {\n  const storeName = \"\".concat(namespace, \"_\").concat(modelName);\n  return storeName;\n};\n//#region Key Utils\n/*\n  When we have GSI(s) with composite sort keys defined on a model\n    There are some very particular rules regarding which fields must be included in the update mutation input\n    The field selection becomes more complex as the number of GSIs with composite sort keys grows\n\n    To summarize: any time we update a field that is part of the composite sort key of a GSI, we must include:\n     1. all of the other fields in that composite sort key\n     2. all of the fields from any other composite sort key that intersect with the fields from 1.\n\n     E.g.,\n     Model @model\n        @key(name: 'key1' fields: ['hk', 'a', 'b', 'c'])\n        @key(name: 'key2' fields: ['hk', 'a', 'b', 'd'])\n        @key(name: 'key3' fields: ['hk', 'x', 'y', 'z'])\n\n    Model.a is updated => include ['a', 'b', 'c', 'd']\n    Model.c is updated => include ['a', 'b', 'c', 'd']\n    Model.d is updated => include ['a', 'b', 'c', 'd']\n    Model.x is updated => include ['x', 'y', 'z']\n\n    This function accepts a model's attributes and returns grouped sets of composite key fields\n    Using our example Model above, the function will return:\n    [\n        Set('a', 'b', 'c', 'd'),\n        Set('x', 'y', 'z'),\n    ]\n\n    This gives us the opportunity to correctly include the required fields for composite keys\n    When crafting the mutation input in Storage.getUpdateMutationInput\n\n    See 'processCompositeKeys' test in util.test.ts for more examples\n*/\nconst processCompositeKeys = attributes => {\n  const extractCompositeSortKey = _ref => {\n    let {\n      properties: {\n        // ignore the HK (fields[0]) we only need to include the composite sort key fields[1...n]\n        fields: [, ...sortKeyFields]\n      }\n    } = _ref;\n    return sortKeyFields;\n  };\n  const compositeKeyFields = attributes.filter(isModelAttributeCompositeKey).map(extractCompositeSortKey);\n  /*\n      if 2 sets of fields have any intersecting fields => combine them into 1 union set\n      e.g., ['a', 'b', 'c'] and ['a', 'b', 'd'] => ['a', 'b', 'c', 'd']\n  */\n  const combineIntersecting = fields => fields.reduce((combined, sortKeyFields) => {\n    const sortKeyFieldsSet = new Set(sortKeyFields);\n    if (combined.length === 0) {\n      combined.push(sortKeyFieldsSet);\n      return combined;\n    }\n    // does the current set share values with another set we've already added to `combined`?\n    const intersectingSetIdx = combined.findIndex(existingSet => {\n      return [...existingSet].some(f => sortKeyFieldsSet.has(f));\n    });\n    if (intersectingSetIdx > -1) {\n      const union = new Set([...combined[intersectingSetIdx], ...sortKeyFieldsSet]);\n      // combine the current set with the intersecting set we found above\n      combined[intersectingSetIdx] = union;\n    } else {\n      // none of the sets in `combined` have intersecting values with the current set\n      combined.push(sortKeyFieldsSet);\n    }\n    return combined;\n  }, []);\n  const initial = combineIntersecting(compositeKeyFields);\n  // a single pass pay not be enough to correctly combine all the fields\n  // call the function once more to get a final merged list of sets\n  const combined = combineIntersecting(initial);\n  return combined;\n};\nconst extractKeyIfExists = modelDefinition => {\n  var _modelDefinition$attr;\n  const keyAttribute = modelDefinition === null || modelDefinition === void 0 || (_modelDefinition$attr = modelDefinition.attributes) === null || _modelDefinition$attr === void 0 ? void 0 : _modelDefinition$attr.find(isModelAttributeKey);\n  return keyAttribute;\n};\nconst extractPrimaryKeyFieldNames = modelDefinition => {\n  const keyAttribute = extractKeyIfExists(modelDefinition);\n  if (keyAttribute && isModelAttributePrimaryKey(keyAttribute)) {\n    return keyAttribute.properties.fields;\n  }\n  return [ID];\n};\nconst extractPrimaryKeyValues = (model, keyFields) => {\n  return keyFields.map(key => model[key]);\n};\nconst extractPrimaryKeysAndValues = (model, keyFields) => {\n  const primaryKeysAndValues = {};\n  keyFields.forEach(key => primaryKeysAndValues[key] = model[key]);\n  return primaryKeysAndValues;\n};\n// IdentifierFields<ManagedIdentifier>\n// Default behavior without explicit @primaryKey defined\nconst isIdManaged = modelDefinition => {\n  const keyAttribute = extractKeyIfExists(modelDefinition);\n  if (keyAttribute && isModelAttributePrimaryKey(keyAttribute)) {\n    return false;\n  }\n  return true;\n};\n// IdentifierFields<OptionallyManagedIdentifier>\n// @primaryKey with explicit `id` in the PK. Single key or composite\nconst isIdOptionallyManaged = modelDefinition => {\n  const keyAttribute = extractKeyIfExists(modelDefinition);\n  if (keyAttribute && isModelAttributePrimaryKey(keyAttribute)) {\n    return keyAttribute.properties.fields[0] === ID;\n  }\n  return false;\n};\nconst establishRelationAndKeys = namespace => {\n  const relationship = {};\n  const keys = {};\n  Object.keys(namespace.models).forEach(mKey => {\n    relationship[mKey] = {\n      indexes: [],\n      relationTypes: []\n    };\n    keys[mKey] = {};\n    const model = namespace.models[mKey];\n    Object.keys(model.fields).forEach(attr => {\n      const fieldAttribute = model.fields[attr];\n      if (typeof fieldAttribute.type === 'object' && 'model' in fieldAttribute.type) {\n        const connectionType = fieldAttribute.association.connectionType;\n        relationship[mKey].relationTypes.push({\n          fieldName: fieldAttribute.name,\n          modelName: fieldAttribute.type.model,\n          relationType: connectionType,\n          targetName: fieldAttribute.association['targetName'],\n          targetNames: fieldAttribute.association['targetNames'],\n          associatedWith: fieldAttribute.association['associatedWith']\n        });\n        if (connectionType === 'BELONGS_TO') {\n          const targetNames = extractTargetNamesFromSrc(fieldAttribute.association);\n          if (targetNames) {\n            const idxName = indexNameFromKeys(targetNames);\n            const idxExists = relationship[mKey].indexes.find(_ref2 => {\n              let [index] = _ref2;\n              return index === idxName;\n            });\n            if (!idxExists) {\n              relationship[mKey].indexes.push([idxName, targetNames]);\n            }\n          }\n        }\n      }\n    });\n    if (model.attributes) {\n      keys[mKey].compositeKeys = processCompositeKeys(model.attributes);\n      for (const attribute of model.attributes) {\n        if (!isModelAttributeKey(attribute)) {\n          continue;\n        }\n        const {\n          fields\n        } = attribute.properties;\n        if (isModelAttributePrimaryKey(attribute)) {\n          keys[mKey].primaryKey = fields;\n          continue;\n        }\n        // create indexes for all other keys\n        const idxName = indexNameFromKeys(fields);\n        const idxExists = relationship[mKey].indexes.find(_ref3 => {\n          let [index] = _ref3;\n          return index === idxName;\n        });\n        if (!idxExists) {\n          relationship[mKey].indexes.push([idxName, fields]);\n        }\n      }\n    }\n    // set 'id' as the PK for models without a custom PK explicitly defined\n    if (!keys[mKey].primaryKey) {\n      keys[mKey].primaryKey = [ID];\n    }\n    // create primary index\n    relationship[mKey].indexes.push(['byPk', keys[mKey].primaryKey, {\n      unique: true\n    }]);\n  });\n  return [relationship, keys];\n};\nconst getIndex = (rel, src) => {\n  let indexName;\n  rel.some(relItem => {\n    if (relItem.modelName === src) {\n      const targetNames = extractTargetNamesFromSrc(relItem);\n      indexName = targetNames && indexNameFromKeys(targetNames);\n      return true;\n    }\n  });\n  return indexName;\n};\nconst getIndexFromAssociation = (indexes, src) => {\n  let indexName;\n  if (Array.isArray(src)) {\n    indexName = indexNameFromKeys(src);\n  } else {\n    indexName = src;\n  }\n  const associationIndex = indexes.find(_ref4 => {\n    let [idxName] = _ref4;\n    return idxName === indexName;\n  });\n  return associationIndex && associationIndex[0];\n};\n/**\n * Backwards-compatability for schema generated prior to custom primary key support:\nthe single field `targetName` has been replaced with an array of `targetNames`.\n`targetName` and `targetNames` are exclusive (will never exist on the same schema)\n * @param src {RelationType | ModelAssociation | undefined}\n * @returns array of targetNames, or `undefined`\n */\nconst extractTargetNamesFromSrc = src => {\n  const targetName = src === null || src === void 0 ? void 0 : src.targetName;\n  const targetNames = src === null || src === void 0 ? void 0 : src.targetNames;\n  if (Array.isArray(targetNames)) {\n    return targetNames;\n  } else if (typeof targetName === 'string') {\n    return [targetName];\n  } else {\n    return undefined;\n  }\n};\n// Generates spinal-cased index name from an array of key field names\n// E.g. for keys `[id, title]` => 'id-title'\nconst indexNameFromKeys = keys => {\n  return keys.reduce((prev, cur, idx) => {\n    if (idx === 0) {\n      return cur;\n    }\n    return \"\".concat(prev).concat(IDENTIFIER_KEY_SEPARATOR).concat(cur);\n  }, '');\n};\nconst keysEqual = (keysA, keysB) => {\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  return keysA.every((key, idx) => key === keysB[idx]);\n};\n// Returns primary keys for a model\nconst getIndexKeys = (namespace, modelName) => {\n  var _namespace$keys;\n  const keyPath = namespace === null || namespace === void 0 || (_namespace$keys = namespace.keys) === null || _namespace$keys === void 0 || (_namespace$keys = _namespace$keys[modelName]) === null || _namespace$keys === void 0 ? void 0 : _namespace$keys.primaryKey;\n  if (keyPath) {\n    return keyPath;\n  }\n  return [ID];\n};\n//#endregion\n/**\n * Determine what the managed timestamp field names are for the given model definition\n * and return the mapping.\n *\n * All timestamp fields are included in the mapping, regardless of whether the final field\n * names are the defaults or customized in the `@model` directive.\n *\n * @see https://docs.amplify.aws/cli/graphql/data-modeling/#customize-creation-and-update-timestamps\n *\n * @param definition modelDefinition to inspect.\n * @returns An object mapping `createdAt` and `updatedAt` to their field names.\n */\nconst getTimestampFields = definition => {\n  var _definition$attribute, _modelAttributes$prop;\n  const modelAttributes = (_definition$attribute = definition.attributes) === null || _definition$attribute === void 0 ? void 0 : _definition$attribute.find(attr => attr.type === 'model');\n  const timestampFieldsMap = modelAttributes === null || modelAttributes === void 0 || (_modelAttributes$prop = modelAttributes.properties) === null || _modelAttributes$prop === void 0 ? void 0 : _modelAttributes$prop.timestamps;\n  const defaultFields = {\n    createdAt: 'createdAt',\n    updatedAt: 'updatedAt'\n  };\n  const customFields = timestampFieldsMap || {};\n  return {\n    ...defaultFields,\n    ...customFields\n  };\n};\nexport { DATASTORE, DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR, DeferredCallbackResolver, DeferredPromise, ID, IDENTIFIER_KEY_SEPARATOR, NAMESPACES, STORAGE, SYNC, USER, asyncEvery, asyncFilter, asyncSome, directedValueEquality, errorMessages, establishRelationAndKeys, exhaustiveCheck, extractKeyIfExists, extractPrimaryKeyFieldNames, extractPrimaryKeyValues, extractPrimaryKeysAndValues, extractTargetNamesFromSrc, getIndex, getIndexFromAssociation, getIndexKeys, getNow, getStorename, getTimestampFields, inMemoryPagination, indexNameFromKeys, isAWSDate, isAWSDateTime, isAWSEmail, isAWSIPAddress, isAWSJSON, isAWSPhone, isAWSTime, isAWSTimestamp, isAWSURL, isIdManaged, isIdOptionallyManaged, isModelConstructor, isNonModelConstructor, isNullOrUndefined, isPrivateMode, isSafariCompatabilityMode, keysEqual, mergePatches, monotonicUlidFactory, processCompositeKeys, registerNonModelClass, sortCompareFunction, traverseModel, validatePredicate, validatePredicateField, valuesEqual };","map":{"version":3,"names":["ID","DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR","IDENTIFIER_KEY_SEPARATOR","errorMessages","idEmptyString","queryByPkWithCompositeKeyPresent","deleteByPkWithCompositeKeyPresent","observeWithObjectLiteral","NAMESPACES","DATASTORE","USER","SYNC","STORAGE","exhaustiveCheck","obj","throwOnError","arguments","length","undefined","Error","concat","isNullOrUndefined","val","validatePredicate","model","groupType","predicatesOrGroups","filterType","isNegation","result","predicateOrGroup","isPredicateObj","field","operator","operand","value","validatePredicateField","isPredicateGroup","type","predicates","min","max","startsWith","indexOf","isModelConstructor","copyOf","nonModelClasses","WeakSet","registerNonModelClass","clazz","add","isNonModelConstructor","has","topologicallySortedModels","WeakMap","traverseModel","srcModelName","instance","namespace","modelInstanceCreator","getModelConstructorByModelName","modelConstructor","name","newInstance","unshift","modelName","item","set","Array","from","modelTopologicalOrdering","keys","sortedModels","get","sort","a","b","privateModeCheckResult","isPrivateMode","Promise","resolve","dbname","amplifyUuid","db","isPrivate","isNotPrivate","close","indexedDB","deleteDatabase","open","onerror","onsuccess","safariCompatabilityModeResult","isSafariCompatabilityMode","dbName","storeName","indexName","dbOpenRequest","onupgradeneeded","event","_event$target","target","store","createObjectStore","autoIncrement","createIndex","rwTx","transaction","rwStore","objectStore","id","commit","tx","index","getRequest","_event$target2","error","HEX_TO_SHORT","i","encodedByte","toString","toLowerCase","getBytesFromHex","encoded","out","Uint8Array","slice","randomBytes","nBytes","str","WordArray","random","prng","monotonicUlidFactory","seed","ulid","monotonicFactory","getNow","performance","now","Date","sortCompareFunction","sortPredicates","compareFunction","predicate","sortDirection","sortMultiplier","SortDirection","ASCENDING","directedValueEquality","fromObject","againstObject","nullish","aKeys","Object","key","fromValue","againstValue","valuesEqual","valA","valB","nullishCompare","_a","_b","isArray","Set","Map","fromEntries","bKeys","aVal","bVal","inMemoryPagination","records","pagination","ModelSortPredicateCreator","getPredicates","compareFn","page","limit","start","Math","end","asyncSome","items","matches","asyncEvery","asyncFilter","results","push","isAWSDate","exec","isAWSTime","isAWSDateTime","isAWSTimestamp","String","isAWSEmail","isAWSJSON","JSON","parse","isAWSURL","AmplifyUrl","isAWSPhone","isAWSIPAddress","DeferredPromise","constructor","self","promise","reject","DeferredCallbackResolver","options","limitPromise","raceInFlight","callback","defaultErrorHandler","msg","errorHandler","maxInterval","startTimer","timerPromise","timer","setTimeout","LimitTimerRaceResolvedValues","TIMER","racePromises","winner","race","err","clear","clearTimeout","LIMIT","mergePatches","originalSource","oldPatches","newPatches","patchesToMerge","patches","produce","draft","applyPatches","p","getStorename","processCompositeKeys","attributes","extractCompositeSortKey","_ref","properties","fields","sortKeyFields","compositeKeyFields","filter","isModelAttributeCompositeKey","map","combineIntersecting","reduce","combined","sortKeyFieldsSet","intersectingSetIdx","findIndex","existingSet","some","f","union","initial","extractKeyIfExists","modelDefinition","_modelDefinition$attr","keyAttribute","find","isModelAttributeKey","extractPrimaryKeyFieldNames","isModelAttributePrimaryKey","extractPrimaryKeyValues","keyFields","extractPrimaryKeysAndValues","primaryKeysAndValues","forEach","isIdManaged","isIdOptionallyManaged","establishRelationAndKeys","relationship","models","mKey","indexes","relationTypes","attr","fieldAttribute","connectionType","association","fieldName","relationType","targetName","targetNames","associatedWith","extractTargetNamesFromSrc","idxName","indexNameFromKeys","idxExists","_ref2","compositeKeys","attribute","primaryKey","_ref3","unique","getIndex","rel","src","relItem","getIndexFromAssociation","associationIndex","_ref4","prev","cur","idx","keysEqual","keysA","keysB","every","getIndexKeys","_namespace$keys","keyPath","getTimestampFields","definition","_definition$attribute","_modelAttributes$prop","modelAttributes","timestampFieldsMap","timestamps","defaultFields","createdAt","updatedAt","customFields"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/util.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { monotonicFactory } from 'ulid';\nimport { amplifyUuid, AmplifyUrl, WordArray, } from '@aws-amplify/core/internals/utils';\nimport { produce, applyPatches } from 'immer';\nimport { isPredicateGroup, isPredicateObj, SortDirection, isModelAttributeKey, isModelAttributePrimaryKey, isModelAttributeCompositeKey, LimitTimerRaceResolvedValues, } from './types';\nimport { ModelSortPredicateCreator } from './predicates';\nexport const ID = 'id';\n/**\n * Used by the Async Storage Adapter to concatenate key values\n * for a record. For instance, if a model has the following keys:\n * `customId: ID! @primaryKey(sortKeyFields: [\"createdAt\"])`,\n * we concatenate the `customId` and `createdAt` as:\n * `12-234-5#2022-09-28T00:00:00.000Z`\n */\nexport const DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR = '#';\n/**\n * Used for generating spinal-cased index name from an array of\n * key field names.\n * E.g. for keys `[id, title]` => 'id-title'\n */\nexport const IDENTIFIER_KEY_SEPARATOR = '-';\nexport const errorMessages = {\n    idEmptyString: 'An index field cannot contain an empty string value',\n    queryByPkWithCompositeKeyPresent: 'Models with composite primary keys cannot be queried by a single key value. Use object literal syntax for composite keys instead: https://docs.amplify.aws/lib/datastore/advanced-workflows/q/platform/js/#querying-records-with-custom-primary-keys',\n    deleteByPkWithCompositeKeyPresent: 'Models with composite primary keys cannot be deleted by a single key value, unless using a predicate. Use object literal syntax for composite keys instead: https://docs.amplify.aws/lib/datastore/advanced-workflows/q/platform/js/#querying-records-with-custom-primary-keys',\n    observeWithObjectLiteral: 'Object literal syntax cannot be used with observe. Use a predicate instead: https://docs.amplify.aws/lib/datastore/data-access/q/platform/js/#predicates',\n};\nexport var NAMESPACES;\n(function (NAMESPACES) {\n    NAMESPACES[\"DATASTORE\"] = \"datastore\";\n    NAMESPACES[\"USER\"] = \"user\";\n    NAMESPACES[\"SYNC\"] = \"sync\";\n    NAMESPACES[\"STORAGE\"] = \"storage\";\n})(NAMESPACES || (NAMESPACES = {}));\nconst DATASTORE = NAMESPACES.DATASTORE;\nconst USER = NAMESPACES.USER;\nconst SYNC = NAMESPACES.SYNC;\nconst STORAGE = NAMESPACES.STORAGE;\nexport { USER, SYNC, STORAGE, DATASTORE };\nexport const exhaustiveCheck = (obj, throwOnError = true) => {\n    if (throwOnError) {\n        throw new Error(`Invalid ${obj}`);\n    }\n};\nexport const isNullOrUndefined = (val) => {\n    return typeof val === 'undefined' || val === undefined || val === null;\n};\nexport const validatePredicate = (model, groupType, predicatesOrGroups) => {\n    let filterType;\n    let isNegation = false;\n    if (predicatesOrGroups.length === 0) {\n        return true;\n    }\n    switch (groupType) {\n        case 'not':\n            filterType = 'every';\n            isNegation = true;\n            break;\n        case 'and':\n            filterType = 'every';\n            break;\n        case 'or':\n            filterType = 'some';\n            break;\n        default:\n            throw new Error(`Invalid ${groupType}`);\n    }\n    const result = predicatesOrGroups[filterType](predicateOrGroup => {\n        if (isPredicateObj(predicateOrGroup)) {\n            const { field, operator, operand } = predicateOrGroup;\n            const value = model[field];\n            return validatePredicateField(value, operator, operand);\n        }\n        if (isPredicateGroup(predicateOrGroup)) {\n            const { type, predicates } = predicateOrGroup;\n            return validatePredicate(model, type, predicates);\n        }\n        throw new Error('Not a predicate or group');\n    });\n    return isNegation ? !result : result;\n};\nexport const validatePredicateField = (value, operator, operand) => {\n    switch (operator) {\n        case 'ne':\n            return value !== operand;\n        case 'eq':\n            return value === operand;\n        case 'le':\n            return value <= operand;\n        case 'lt':\n            return value < operand;\n        case 'ge':\n            return value >= operand;\n        case 'gt':\n            return value > operand;\n        case 'between':\n            const [min, max] = operand;\n            return value >= min && value <= max;\n        case 'beginsWith':\n            return (!isNullOrUndefined(value) &&\n                value.startsWith(operand));\n        case 'contains':\n            return (!isNullOrUndefined(value) &&\n                value.indexOf(operand) > -1);\n        case 'notContains':\n            return (isNullOrUndefined(value) ||\n                value.indexOf(operand) === -1);\n        default:\n            return false;\n    }\n};\nexport const isModelConstructor = (obj) => {\n    return (obj && typeof obj.copyOf === 'function');\n};\nconst nonModelClasses = new WeakSet();\nexport function registerNonModelClass(clazz) {\n    nonModelClasses.add(clazz);\n}\nexport const isNonModelConstructor = (obj) => {\n    return nonModelClasses.has(obj);\n};\nconst topologicallySortedModels = new WeakMap();\nexport const traverseModel = (srcModelName, instance, namespace, modelInstanceCreator, getModelConstructorByModelName) => {\n    const modelConstructor = getModelConstructorByModelName(namespace.name, srcModelName);\n    const result = [];\n    const newInstance = modelConstructor.copyOf(instance, () => { });\n    result.unshift({\n        modelName: srcModelName,\n        item: newInstance,\n        instance: newInstance,\n    });\n    if (!topologicallySortedModels.has(namespace)) {\n        topologicallySortedModels.set(namespace, Array.from(namespace.modelTopologicalOrdering.keys()));\n    }\n    const sortedModels = topologicallySortedModels.get(namespace);\n    result.sort((a, b) => {\n        return (sortedModels.indexOf(a.modelName) - sortedModels.indexOf(b.modelName));\n    });\n    return result;\n};\nlet privateModeCheckResult;\nexport const isPrivateMode = () => {\n    return new Promise(resolve => {\n        const dbname = amplifyUuid();\n        let db;\n        const isPrivate = () => {\n            privateModeCheckResult = false;\n            resolve(true);\n        };\n        const isNotPrivate = async () => {\n            if (db && db.result && typeof db.result.close === 'function') {\n                await db.result.close();\n            }\n            await indexedDB.deleteDatabase(dbname);\n            privateModeCheckResult = true;\n            return resolve(false);\n        };\n        if (privateModeCheckResult === true) {\n            return isNotPrivate();\n        }\n        if (privateModeCheckResult === false) {\n            return isPrivate();\n        }\n        if (indexedDB === null)\n            return isPrivate();\n        db = indexedDB.open(dbname);\n        db.onerror = isPrivate;\n        db.onsuccess = isNotPrivate;\n    });\n};\nlet safariCompatabilityModeResult;\n/**\n * Whether the browser's implementation of IndexedDB breaks on array lookups\n * against composite indexes whose keypath contains a single column.\n *\n * E.g., Whether `store.createIndex(indexName, ['id'])` followed by\n * `store.index(indexName).get([1])` will *ever* return records.\n *\n * In all known, modern Safari browsers as of Q4 2022, the query against an index like\n * this will *always* return `undefined`. So, the index needs to be created as a scalar.\n */\nexport const isSafariCompatabilityMode = async () => {\n    try {\n        const dbName = amplifyUuid();\n        const storeName = 'indexedDBFeatureProbeStore';\n        const indexName = 'idx';\n        if (indexedDB === null)\n            return false;\n        if (safariCompatabilityModeResult !== undefined) {\n            return safariCompatabilityModeResult;\n        }\n        const db = await new Promise(resolve => {\n            const dbOpenRequest = indexedDB.open(dbName);\n            dbOpenRequest.onerror = () => resolve(false);\n            dbOpenRequest.onsuccess = () => {\n                const db = dbOpenRequest.result;\n                resolve(db);\n            };\n            dbOpenRequest.onupgradeneeded = (event) => {\n                const db = event?.target?.result;\n                db.onerror = () => resolve(false);\n                const store = db.createObjectStore(storeName, {\n                    autoIncrement: true,\n                });\n                store.createIndex(indexName, ['id']);\n            };\n        });\n        if (!db) {\n            throw new Error('Could not open probe DB');\n        }\n        const rwTx = db.transaction(storeName, 'readwrite');\n        const rwStore = rwTx.objectStore(storeName);\n        rwStore.add({\n            id: 1,\n        });\n        rwTx.commit();\n        const result = await new Promise(resolve => {\n            const tx = db.transaction(storeName, 'readonly');\n            const store = tx.objectStore(storeName);\n            const index = store.index(indexName);\n            const getRequest = index.get([1]);\n            getRequest.onerror = () => resolve(false);\n            getRequest.onsuccess = (event) => {\n                resolve(event?.target?.result);\n            };\n        });\n        if (db && typeof db.close === 'function') {\n            await db.close();\n        }\n        await indexedDB.deleteDatabase(dbName);\n        if (result === undefined) {\n            safariCompatabilityModeResult = true;\n        }\n        else {\n            safariCompatabilityModeResult = false;\n        }\n    }\n    catch (error) {\n        safariCompatabilityModeResult = false;\n    }\n    return safariCompatabilityModeResult;\n};\nconst HEX_TO_SHORT = {};\nfor (let i = 0; i < 256; i++) {\n    let encodedByte = i.toString(16).toLowerCase();\n    if (encodedByte.length === 1) {\n        encodedByte = `0${encodedByte}`;\n    }\n    HEX_TO_SHORT[encodedByte] = i;\n}\nconst getBytesFromHex = (encoded) => {\n    if (encoded.length % 2 !== 0) {\n        throw new Error('Hex encoded strings must have an even number length');\n    }\n    const out = new Uint8Array(encoded.length / 2);\n    for (let i = 0; i < encoded.length; i += 2) {\n        const encodedByte = encoded.slice(i, i + 2).toLowerCase();\n        if (encodedByte in HEX_TO_SHORT) {\n            out[i / 2] = HEX_TO_SHORT[encodedByte];\n        }\n        else {\n            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);\n        }\n    }\n    return out;\n};\nconst randomBytes = (nBytes) => {\n    const str = new WordArray().random(nBytes).toString();\n    return getBytesFromHex(str);\n};\nconst prng = () => randomBytes(1)[0] / 0xff;\nexport function monotonicUlidFactory(seed) {\n    const ulid = monotonicFactory(prng);\n    return () => {\n        return ulid(seed);\n    };\n}\n/**\n * Uses performance.now() if available, otherwise, uses Date.now() (e.g. react native without a polyfill)\n *\n * The values returned by performance.now() always increase at a constant rate,\n * independent of the system clock (which might be adjusted manually or skewed\n * by software like NTP).\n *\n * Otherwise, performance.timing.navigationStart + performance.now() will be\n * approximately equal to Date.now()\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Performance/now#Example\n */\nexport function getNow() {\n    if (typeof performance !== 'undefined' &&\n        performance &&\n        typeof performance.now === 'function') {\n        return performance.now() | 0; // convert to integer\n    }\n    else {\n        return Date.now();\n    }\n}\nexport function sortCompareFunction(sortPredicates) {\n    return function compareFunction(a, b) {\n        // enable multi-field sort by iterating over predicates until\n        // a comparison returns -1 or 1\n        for (const predicate of sortPredicates) {\n            const { field, sortDirection } = predicate;\n            // reverse result when direction is descending\n            const sortMultiplier = sortDirection === SortDirection.ASCENDING ? 1 : -1;\n            if (a[field] < b[field]) {\n                return -1 * sortMultiplier;\n            }\n            if (a[field] > b[field]) {\n                return 1 * sortMultiplier;\n            }\n        }\n        return 0;\n    };\n}\n/* deep directed comparison ensuring that all fields on \"from\" object exist and\n * are equal to values on an \"against\" object\n *\n * Note: This same guarauntee is not applied for values on \"against\" that aren't on \"from\"\n *\n * @param fromObject - The object that may be an equal subset of the againstObject.\n * @param againstObject - The object that may be an equal superset of the fromObject.\n *\n * @returns True if fromObject is a equal subset of againstObject and False otherwise.\n */\nexport function directedValueEquality(fromObject, againstObject, nullish = false) {\n    const aKeys = Object.keys(fromObject);\n    for (const key of aKeys) {\n        const fromValue = fromObject[key];\n        const againstValue = againstObject[key];\n        if (!valuesEqual(fromValue, againstValue, nullish)) {\n            return false;\n        }\n    }\n    return true;\n}\n// deep compare any 2 values\n// primitives or object types (including arrays, Sets, and Maps)\n// returns true if equal by value\n// if nullish is true, treat undefined and null values as equal\n// to normalize for GQL response values for undefined fields\nexport function valuesEqual(valA, valB, nullish = false) {\n    let a = valA;\n    let b = valB;\n    const nullishCompare = (_a, _b) => {\n        return ((_a === undefined || _a === null) && (_b === undefined || _b === null));\n    };\n    // if one of the values is a primitive and the other is an object\n    if ((a instanceof Object && !(b instanceof Object)) ||\n        (!(a instanceof Object) && b instanceof Object)) {\n        return false;\n    }\n    // compare primitive types\n    if (!(a instanceof Object)) {\n        if (nullish && nullishCompare(a, b)) {\n            return true;\n        }\n        return a === b;\n    }\n    // make sure object types match\n    if ((Array.isArray(a) && !Array.isArray(b)) ||\n        (Array.isArray(b) && !Array.isArray(a))) {\n        return false;\n    }\n    if (a instanceof Set && b instanceof Set) {\n        a = [...a];\n        b = [...b];\n    }\n    if (a instanceof Map && b instanceof Map) {\n        a = Object.fromEntries(a);\n        b = Object.fromEntries(b);\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    // last condition is to ensure that [] !== [null] even if nullish. However [undefined] === [null] when nullish\n    if (aKeys.length !== bKeys.length && (!nullish || Array.isArray(a))) {\n        return false;\n    }\n    // iterate through the longer set of keys\n    // e.g., for a nullish comparison of a={ a: 1 } and b={ a: 1, b: null }\n    // we want to iterate through bKeys\n    const keys = aKeys.length >= bKeys.length ? aKeys : bKeys;\n    for (const key of keys) {\n        const aVal = a[key];\n        const bVal = b[key];\n        if (!valuesEqual(aVal, bVal, nullish)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Statelessly extracts the specified page from an array.\n *\n * @param records - The source array to extract a page from.\n * @param pagination - A definition of the page to extract.\n * @returns This items from `records` matching the `pagination` definition.\n */\nexport function inMemoryPagination(records, pagination) {\n    if (pagination && records.length > 1) {\n        if (pagination.sort) {\n            const sortPredicates = ModelSortPredicateCreator.getPredicates(pagination.sort);\n            if (sortPredicates.length) {\n                const compareFn = sortCompareFunction(sortPredicates);\n                records.sort(compareFn);\n            }\n        }\n        const { page = 0, limit = 0 } = pagination;\n        const start = Math.max(0, page * limit) || 0;\n        const end = limit > 0 ? start + limit : records.length;\n        return records.slice(start, end);\n    }\n    return records;\n}\n/**\n * An `aysnc` implementation of `Array.some()`. Returns as soon as a match is found.\n * @param items The items to check.\n * @param matches The async matcher function, expected to\n * return Promise<boolean>: `true` for a matching item, `false` otherwise.\n * @returns A `Promise<boolean>`, `true` if \"some\" items match; `false` otherwise.\n */\nexport async function asyncSome(items, matches) {\n    for (const item of items) {\n        if (await matches(item)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * An `aysnc` implementation of `Array.every()`. Returns as soon as a non-match is found.\n * @param items The items to check.\n * @param matches The async matcher function, expected to\n * return Promise<boolean>: `true` for a matching item, `false` otherwise.\n * @returns A `Promise<boolean>`, `true` if every item matches; `false` otherwise.\n */\nexport async function asyncEvery(items, matches) {\n    for (const item of items) {\n        if (!(await matches(item))) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * An `async` implementation of `Array.filter()`. Returns after all items have been filtered.\n * TODO: Return AsyncIterable.\n * @param items The items to filter.\n * @param matches The `async` matcher function, expected to\n * return Promise<boolean>: `true` for a matching item, `false` otherwise.\n * @returns A `Promise<T>` of matching items.\n */\nexport async function asyncFilter(items, matches) {\n    const results = [];\n    for (const item of items) {\n        if (await matches(item)) {\n            results.push(item);\n        }\n    }\n    return results;\n}\nexport const isAWSDate = (val) => {\n    return !!/^\\d{4}-\\d{2}-\\d{2}(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(val);\n};\nexport const isAWSTime = (val) => {\n    return !!/^\\d{2}:\\d{2}(:\\d{2}(.\\d+)?)?(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(val);\n};\nexport const isAWSDateTime = (val) => {\n    return !!/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}(:\\d{2}(.\\d+)?)?(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(val);\n};\nexport const isAWSTimestamp = (val) => {\n    return !!/^\\d+$/.exec(String(val));\n};\nexport const isAWSEmail = (val) => {\n    return !!/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.exec(val);\n};\nexport const isAWSJSON = (val) => {\n    try {\n        JSON.parse(val);\n        return true;\n    }\n    catch {\n        return false;\n    }\n};\nexport const isAWSURL = (val) => {\n    try {\n        return !!new AmplifyUrl(val);\n    }\n    catch {\n        return false;\n    }\n};\nexport const isAWSPhone = (val) => {\n    return !!/^\\+?\\d[\\d\\s-]+$/.exec(val);\n};\nexport const isAWSIPAddress = (val) => {\n    return !!/((^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$)|(^((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?$))$/.exec(val);\n};\nexport class DeferredPromise {\n    constructor() {\n        const self = this;\n        this.promise = new Promise((resolve, reject) => {\n            self.resolve = resolve;\n            self.reject = reject;\n        });\n    }\n}\nexport class DeferredCallbackResolver {\n    constructor(options) {\n        this.limitPromise = new DeferredPromise();\n        this.raceInFlight = false;\n        this.callback = () => { };\n        this.defaultErrorHandler = (msg = 'DeferredCallbackResolver error') => {\n            throw new Error(msg);\n        };\n        this.callback = options.callback;\n        this.errorHandler = options.errorHandler || this.defaultErrorHandler;\n        this.maxInterval = options.maxInterval || 2000;\n    }\n    startTimer() {\n        this.timerPromise = new Promise((resolve, reject) => {\n            this.timer = setTimeout(() => {\n                resolve(LimitTimerRaceResolvedValues.TIMER);\n            }, this.maxInterval);\n        });\n    }\n    async racePromises() {\n        let winner;\n        try {\n            this.raceInFlight = true;\n            this.startTimer();\n            winner = await Promise.race([\n                this.timerPromise,\n                this.limitPromise.promise,\n            ]);\n            this.callback();\n        }\n        catch (err) {\n            this.errorHandler(err);\n        }\n        finally {\n            // reset for the next race\n            this.clear();\n            this.raceInFlight = false;\n            this.limitPromise = new DeferredPromise();\n            return winner;\n        }\n    }\n    start() {\n        if (!this.raceInFlight)\n            this.racePromises();\n    }\n    clear() {\n        clearTimeout(this.timer);\n    }\n    resolve() {\n        this.limitPromise.resolve(LimitTimerRaceResolvedValues.LIMIT);\n    }\n}\n/**\n * merge two sets of patches created by immer produce.\n * newPatches take precedent over oldPatches for patches modifying the same path.\n * In the case many consecutive pathces are merged the original model should\n * always be the root model.\n *\n * Example:\n * A -> B, patches1\n * B -> C, patches2\n *\n * mergePatches(A, patches1, patches2) to get patches for A -> C\n *\n * @param originalSource the original Model the patches should be applied to\n * @param oldPatches immer produce patch list\n * @param newPatches immer produce patch list (will take precedence)\n * @return merged patches\n */\nexport function mergePatches(originalSource, oldPatches, newPatches) {\n    const patchesToMerge = oldPatches.concat(newPatches);\n    let patches;\n    produce(originalSource, draft => {\n        applyPatches(draft, patchesToMerge);\n    }, p => {\n        patches = p;\n    });\n    return patches;\n}\nexport const getStorename = (namespace, modelName) => {\n    const storeName = `${namespace}_${modelName}`;\n    return storeName;\n};\n//#region Key Utils\n/*\n  When we have GSI(s) with composite sort keys defined on a model\n    There are some very particular rules regarding which fields must be included in the update mutation input\n    The field selection becomes more complex as the number of GSIs with composite sort keys grows\n\n    To summarize: any time we update a field that is part of the composite sort key of a GSI, we must include:\n     1. all of the other fields in that composite sort key\n     2. all of the fields from any other composite sort key that intersect with the fields from 1.\n\n     E.g.,\n     Model @model\n        @key(name: 'key1' fields: ['hk', 'a', 'b', 'c'])\n        @key(name: 'key2' fields: ['hk', 'a', 'b', 'd'])\n        @key(name: 'key3' fields: ['hk', 'x', 'y', 'z'])\n\n    Model.a is updated => include ['a', 'b', 'c', 'd']\n    Model.c is updated => include ['a', 'b', 'c', 'd']\n    Model.d is updated => include ['a', 'b', 'c', 'd']\n    Model.x is updated => include ['x', 'y', 'z']\n\n    This function accepts a model's attributes and returns grouped sets of composite key fields\n    Using our example Model above, the function will return:\n    [\n        Set('a', 'b', 'c', 'd'),\n        Set('x', 'y', 'z'),\n    ]\n\n    This gives us the opportunity to correctly include the required fields for composite keys\n    When crafting the mutation input in Storage.getUpdateMutationInput\n\n    See 'processCompositeKeys' test in util.test.ts for more examples\n*/\nexport const processCompositeKeys = (attributes) => {\n    const extractCompositeSortKey = ({ properties: { \n    // ignore the HK (fields[0]) we only need to include the composite sort key fields[1...n]\n    fields: [, ...sortKeyFields], }, }) => sortKeyFields;\n    const compositeKeyFields = attributes\n        .filter(isModelAttributeCompositeKey)\n        .map(extractCompositeSortKey);\n    /*\n        if 2 sets of fields have any intersecting fields => combine them into 1 union set\n        e.g., ['a', 'b', 'c'] and ['a', 'b', 'd'] => ['a', 'b', 'c', 'd']\n    */\n    const combineIntersecting = (fields) => fields.reduce((combined, sortKeyFields) => {\n        const sortKeyFieldsSet = new Set(sortKeyFields);\n        if (combined.length === 0) {\n            combined.push(sortKeyFieldsSet);\n            return combined;\n        }\n        // does the current set share values with another set we've already added to `combined`?\n        const intersectingSetIdx = combined.findIndex(existingSet => {\n            return [...existingSet].some(f => sortKeyFieldsSet.has(f));\n        });\n        if (intersectingSetIdx > -1) {\n            const union = new Set([\n                ...combined[intersectingSetIdx],\n                ...sortKeyFieldsSet,\n            ]);\n            // combine the current set with the intersecting set we found above\n            combined[intersectingSetIdx] = union;\n        }\n        else {\n            // none of the sets in `combined` have intersecting values with the current set\n            combined.push(sortKeyFieldsSet);\n        }\n        return combined;\n    }, []);\n    const initial = combineIntersecting(compositeKeyFields);\n    // a single pass pay not be enough to correctly combine all the fields\n    // call the function once more to get a final merged list of sets\n    const combined = combineIntersecting(initial);\n    return combined;\n};\nexport const extractKeyIfExists = (modelDefinition) => {\n    const keyAttribute = modelDefinition?.attributes?.find(isModelAttributeKey);\n    return keyAttribute;\n};\nexport const extractPrimaryKeyFieldNames = (modelDefinition) => {\n    const keyAttribute = extractKeyIfExists(modelDefinition);\n    if (keyAttribute && isModelAttributePrimaryKey(keyAttribute)) {\n        return keyAttribute.properties.fields;\n    }\n    return [ID];\n};\nexport const extractPrimaryKeyValues = (model, keyFields) => {\n    return keyFields.map(key => model[key]);\n};\nexport const extractPrimaryKeysAndValues = (model, keyFields) => {\n    const primaryKeysAndValues = {};\n    keyFields.forEach(key => (primaryKeysAndValues[key] = model[key]));\n    return primaryKeysAndValues;\n};\n// IdentifierFields<ManagedIdentifier>\n// Default behavior without explicit @primaryKey defined\nexport const isIdManaged = (modelDefinition) => {\n    const keyAttribute = extractKeyIfExists(modelDefinition);\n    if (keyAttribute && isModelAttributePrimaryKey(keyAttribute)) {\n        return false;\n    }\n    return true;\n};\n// IdentifierFields<OptionallyManagedIdentifier>\n// @primaryKey with explicit `id` in the PK. Single key or composite\nexport const isIdOptionallyManaged = (modelDefinition) => {\n    const keyAttribute = extractKeyIfExists(modelDefinition);\n    if (keyAttribute && isModelAttributePrimaryKey(keyAttribute)) {\n        return keyAttribute.properties.fields[0] === ID;\n    }\n    return false;\n};\nexport const establishRelationAndKeys = (namespace) => {\n    const relationship = {};\n    const keys = {};\n    Object.keys(namespace.models).forEach((mKey) => {\n        relationship[mKey] = { indexes: [], relationTypes: [] };\n        keys[mKey] = {};\n        const model = namespace.models[mKey];\n        Object.keys(model.fields).forEach((attr) => {\n            const fieldAttribute = model.fields[attr];\n            if (typeof fieldAttribute.type === 'object' &&\n                'model' in fieldAttribute.type) {\n                const connectionType = fieldAttribute.association.connectionType;\n                relationship[mKey].relationTypes.push({\n                    fieldName: fieldAttribute.name,\n                    modelName: fieldAttribute.type.model,\n                    relationType: connectionType,\n                    targetName: fieldAttribute.association['targetName'],\n                    targetNames: fieldAttribute.association['targetNames'],\n                    associatedWith: fieldAttribute.association['associatedWith'],\n                });\n                if (connectionType === 'BELONGS_TO') {\n                    const targetNames = extractTargetNamesFromSrc(fieldAttribute.association);\n                    if (targetNames) {\n                        const idxName = indexNameFromKeys(targetNames);\n                        const idxExists = relationship[mKey].indexes.find(([index]) => index === idxName);\n                        if (!idxExists) {\n                            relationship[mKey].indexes.push([idxName, targetNames]);\n                        }\n                    }\n                }\n            }\n        });\n        if (model.attributes) {\n            keys[mKey].compositeKeys = processCompositeKeys(model.attributes);\n            for (const attribute of model.attributes) {\n                if (!isModelAttributeKey(attribute)) {\n                    continue;\n                }\n                const { fields } = attribute.properties;\n                if (isModelAttributePrimaryKey(attribute)) {\n                    keys[mKey].primaryKey = fields;\n                    continue;\n                }\n                // create indexes for all other keys\n                const idxName = indexNameFromKeys(fields);\n                const idxExists = relationship[mKey].indexes.find(([index]) => index === idxName);\n                if (!idxExists) {\n                    relationship[mKey].indexes.push([idxName, fields]);\n                }\n            }\n        }\n        // set 'id' as the PK for models without a custom PK explicitly defined\n        if (!keys[mKey].primaryKey) {\n            keys[mKey].primaryKey = [ID];\n        }\n        // create primary index\n        relationship[mKey].indexes.push([\n            'byPk',\n            keys[mKey].primaryKey,\n            { unique: true },\n        ]);\n    });\n    return [relationship, keys];\n};\nexport const getIndex = (rel, src) => {\n    let indexName;\n    rel.some((relItem) => {\n        if (relItem.modelName === src) {\n            const targetNames = extractTargetNamesFromSrc(relItem);\n            indexName = targetNames && indexNameFromKeys(targetNames);\n            return true;\n        }\n    });\n    return indexName;\n};\nexport const getIndexFromAssociation = (indexes, src) => {\n    let indexName;\n    if (Array.isArray(src)) {\n        indexName = indexNameFromKeys(src);\n    }\n    else {\n        indexName = src;\n    }\n    const associationIndex = indexes.find(([idxName]) => idxName === indexName);\n    return associationIndex && associationIndex[0];\n};\n/**\n * Backwards-compatability for schema generated prior to custom primary key support:\nthe single field `targetName` has been replaced with an array of `targetNames`.\n`targetName` and `targetNames` are exclusive (will never exist on the same schema)\n * @param src {RelationType | ModelAssociation | undefined}\n * @returns array of targetNames, or `undefined`\n */\nexport const extractTargetNamesFromSrc = (src) => {\n    const targetName = src?.targetName;\n    const targetNames = src?.targetNames;\n    if (Array.isArray(targetNames)) {\n        return targetNames;\n    }\n    else if (typeof targetName === 'string') {\n        return [targetName];\n    }\n    else {\n        return undefined;\n    }\n};\n// Generates spinal-cased index name from an array of key field names\n// E.g. for keys `[id, title]` => 'id-title'\nexport const indexNameFromKeys = (keys) => {\n    return keys.reduce((prev, cur, idx) => {\n        if (idx === 0) {\n            return cur;\n        }\n        return `${prev}${IDENTIFIER_KEY_SEPARATOR}${cur}`;\n    }, '');\n};\nexport const keysEqual = (keysA, keysB) => {\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    return keysA.every((key, idx) => key === keysB[idx]);\n};\n// Returns primary keys for a model\nexport const getIndexKeys = (namespace, modelName) => {\n    const keyPath = namespace?.keys?.[modelName]?.primaryKey;\n    if (keyPath) {\n        return keyPath;\n    }\n    return [ID];\n};\n//#endregion\n/**\n * Determine what the managed timestamp field names are for the given model definition\n * and return the mapping.\n *\n * All timestamp fields are included in the mapping, regardless of whether the final field\n * names are the defaults or customized in the `@model` directive.\n *\n * @see https://docs.amplify.aws/cli/graphql/data-modeling/#customize-creation-and-update-timestamps\n *\n * @param definition modelDefinition to inspect.\n * @returns An object mapping `createdAt` and `updatedAt` to their field names.\n */\nexport const getTimestampFields = (definition) => {\n    const modelAttributes = definition.attributes?.find(attr => attr.type === 'model');\n    const timestampFieldsMap = modelAttributes?.properties?.timestamps;\n    const defaultFields = {\n        createdAt: 'createdAt',\n        updatedAt: 'updatedAt',\n    };\n    const customFields = timestampFieldsMap || {};\n    return {\n        ...defaultFields,\n        ...customFields,\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}