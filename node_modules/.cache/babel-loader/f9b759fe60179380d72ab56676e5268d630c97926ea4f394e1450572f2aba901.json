{"ast":null,"code":"import { defaultStorage } from '@aws-amplify/core';\nimport { UPLOADS_STORAGE_KEY } from '../../../utils/constants.mjs';\nimport '../../../utils/client/base.mjs';\nimport '../../../utils/client/getObject.mjs';\nimport '../../../utils/client/listObjectsV2.mjs';\nimport '../../../utils/client/putObject.mjs';\nimport '../../../utils/client/createMultipartUpload.mjs';\nimport '../../../utils/client/uploadPart.mjs';\nimport '../../../utils/client/completeMultipartUpload.mjs';\nimport { listParts } from '../../../utils/client/listParts.mjs';\nimport '../../../utils/client/abortMultipartUpload.mjs';\nimport '../../../utils/client/copyObject.mjs';\nimport '../../../utils/client/headObject.mjs';\nimport '../../../utils/client/deleteObject.mjs';\nimport '../../../../../errors/types/validation.mjs';\nimport '@aws-amplify/core/internals/utils';\nimport { logger } from '../../../../../utils/logger.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst ONE_HOUR = 1000 * 60 * 60;\n/**\n * Find the cached multipart upload id and get the parts that have been uploaded\n * with ListParts API. If the cached upload is expired(1 hour), return null.\n */\nconst findCachedUploadParts = async _ref => {\n  let {\n    cacheKey,\n    s3Config,\n    bucket,\n    finalKey\n  } = _ref;\n  const cachedUploads = await listCachedUploadTasks(defaultStorage);\n  if (!cachedUploads[cacheKey] || cachedUploads[cacheKey].lastTouched < Date.now() - ONE_HOUR // Uploads are cached for 1 hour\n  ) {\n    return null;\n  }\n  const cachedUpload = cachedUploads[cacheKey];\n  cachedUpload.lastTouched = Date.now();\n  await defaultStorage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n  try {\n    const {\n      Parts = []\n    } = await listParts(s3Config, {\n      Bucket: bucket,\n      Key: finalKey,\n      UploadId: cachedUpload.uploadId\n    });\n    return {\n      parts: Parts,\n      uploadId: cachedUpload.uploadId\n    };\n  } catch (e) {\n    logger.debug('failed to list cached parts, removing cached upload.');\n    await removeCachedUpload(cacheKey);\n    return null;\n  }\n};\nconst listCachedUploadTasks = async kvStorage => {\n  try {\n    var _await$kvStorage$getI;\n    return JSON.parse((_await$kvStorage$getI = await kvStorage.getItem(UPLOADS_STORAGE_KEY)) !== null && _await$kvStorage$getI !== void 0 ? _await$kvStorage$getI : '{}');\n  } catch (e) {\n    logger.debug('failed to parse cached uploads record.');\n    return {};\n  }\n};\n/**\n * Get the cache key of a multipart upload. Data source cached by different: size, content type, bucket, access level,\n * key. If the data source is a File instance, the upload is additionally indexed by file name and last modified time.\n * So the library always created a new multipart upload if the file is modified.\n */\nconst getUploadsCacheKey = _ref2 => {\n  var _ref3;\n  let {\n    file,\n    size,\n    contentType,\n    bucket,\n    accessLevel,\n    key\n  } = _ref2;\n  const resolvedContentType = (_ref3 = contentType !== null && contentType !== void 0 ? contentType : file === null || file === void 0 ? void 0 : file.type) !== null && _ref3 !== void 0 ? _ref3 : 'application/octet-stream';\n  const levelStr = accessLevel === 'guest' ? 'public' : accessLevel;\n  const baseId = \"\".concat(size, \"_\").concat(resolvedContentType, \"_\").concat(bucket, \"_\").concat(levelStr, \"_\").concat(key);\n  if (file) {\n    return \"\".concat(file.name, \"_\").concat(file.lastModified, \"_\").concat(baseId);\n  } else {\n    return baseId;\n  }\n};\nconst cacheMultipartUpload = async (cacheKey, fileMetadata) => {\n  const cachedUploads = await listCachedUploadTasks(defaultStorage);\n  cachedUploads[cacheKey] = {\n    ...fileMetadata,\n    lastTouched: Date.now()\n  };\n  await defaultStorage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n};\nconst removeCachedUpload = async cacheKey => {\n  const cachedUploads = await listCachedUploadTasks(defaultStorage);\n  delete cachedUploads[cacheKey];\n  await defaultStorage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n};\nexport { cacheMultipartUpload, findCachedUploadParts, getUploadsCacheKey, removeCachedUpload };","map":{"version":3,"names":["ONE_HOUR","findCachedUploadParts","_ref","cacheKey","s3Config","bucket","finalKey","cachedUploads","listCachedUploadTasks","defaultStorage","lastTouched","Date","now","cachedUpload","setItem","UPLOADS_STORAGE_KEY","JSON","stringify","Parts","listParts","Bucket","Key","UploadId","uploadId","parts","e","logger","debug","removeCachedUpload","kvStorage","_await$kvStorage$getI","parse","getItem","getUploadsCacheKey","_ref2","_ref3","file","size","contentType","accessLevel","key","resolvedContentType","type","levelStr","baseId","concat","name","lastModified","cacheMultipartUpload","fileMetadata"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/storage/src/providers/s3/apis/uploadData/multipart/uploadCache.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { defaultStorage, } from '@aws-amplify/core';\nimport { UPLOADS_STORAGE_KEY } from '../../../utils/constants';\nimport { listParts } from '../../../utils/client';\nimport { logger } from '../../../../../utils';\nconst ONE_HOUR = 1000 * 60 * 60;\n/**\n * Find the cached multipart upload id and get the parts that have been uploaded\n * with ListParts API. If the cached upload is expired(1 hour), return null.\n */\nexport const findCachedUploadParts = async ({ cacheKey, s3Config, bucket, finalKey, }) => {\n    const cachedUploads = await listCachedUploadTasks(defaultStorage);\n    if (!cachedUploads[cacheKey] ||\n        cachedUploads[cacheKey].lastTouched < Date.now() - ONE_HOUR // Uploads are cached for 1 hour\n    ) {\n        return null;\n    }\n    const cachedUpload = cachedUploads[cacheKey];\n    cachedUpload.lastTouched = Date.now();\n    await defaultStorage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n    try {\n        const { Parts = [] } = await listParts(s3Config, {\n            Bucket: bucket,\n            Key: finalKey,\n            UploadId: cachedUpload.uploadId,\n        });\n        return {\n            parts: Parts,\n            uploadId: cachedUpload.uploadId,\n        };\n    }\n    catch (e) {\n        logger.debug('failed to list cached parts, removing cached upload.');\n        await removeCachedUpload(cacheKey);\n        return null;\n    }\n};\nconst listCachedUploadTasks = async (kvStorage) => {\n    try {\n        return JSON.parse((await kvStorage.getItem(UPLOADS_STORAGE_KEY)) ?? '{}');\n    }\n    catch (e) {\n        logger.debug('failed to parse cached uploads record.');\n        return {};\n    }\n};\n/**\n * Get the cache key of a multipart upload. Data source cached by different: size, content type, bucket, access level,\n * key. If the data source is a File instance, the upload is additionally indexed by file name and last modified time.\n * So the library always created a new multipart upload if the file is modified.\n */\nexport const getUploadsCacheKey = ({ file, size, contentType, bucket, accessLevel, key, }) => {\n    const resolvedContentType = contentType ?? file?.type ?? 'application/octet-stream';\n    const levelStr = accessLevel === 'guest' ? 'public' : accessLevel;\n    const baseId = `${size}_${resolvedContentType}_${bucket}_${levelStr}_${key}`;\n    if (file) {\n        return `${file.name}_${file.lastModified}_${baseId}`;\n    }\n    else {\n        return baseId;\n    }\n};\nexport const cacheMultipartUpload = async (cacheKey, fileMetadata) => {\n    const cachedUploads = await listCachedUploadTasks(defaultStorage);\n    cachedUploads[cacheKey] = {\n        ...fileMetadata,\n        lastTouched: Date.now(),\n    };\n    await defaultStorage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n};\nexport const removeCachedUpload = async (cacheKey) => {\n    const cachedUploads = await listCachedUploadTasks(defaultStorage);\n    delete cachedUploads[cacheKey];\n    await defaultStorage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}