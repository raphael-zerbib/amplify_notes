{"ast":null,"code":"import { ModelPredicateCreator } from '../../predicates/index.mjs';\nimport { isPredicateObj } from '../../types.mjs';\nimport { getStorename, getIndexKeys, extractPrimaryKeyValues, traverseModel, validatePredicate, isModelConstructor, extractPrimaryKeyFieldNames } from '../../util.mjs';\nimport { ModelRelationship } from '../relationship.mjs';\nimport { ConsoleLogger } from '@aws-amplify/core';\nconst logger = new ConsoleLogger('DataStore');\nconst DB_NAME = 'amplify-datastore';\nclass StorageAdapterBase {\n  constructor() {\n    this.dbName = DB_NAME;\n  }\n  /**\n   * Initializes local DB\n   *\n   * @param theSchema\n   * @param namespaceResolver\n   * @param modelInstanceCreator\n   * @param getModelConstructorByModelName\n   * @param sessionId\n   */\n  async setUp(theSchema, namespaceResolver, modelInstanceCreator, getModelConstructorByModelName, sessionId) {\n    await this.preSetUpChecks();\n    if (!this.initPromise) {\n      this.initPromise = new Promise((res, rej) => {\n        this.resolve = res;\n        this.reject = rej;\n      });\n    } else {\n      await this.initPromise;\n      return;\n    }\n    if (sessionId) {\n      this.dbName = \"\".concat(DB_NAME, \"-\").concat(sessionId);\n    }\n    this.schema = theSchema;\n    this.namespaceResolver = namespaceResolver;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.getModelConstructorByModelName = getModelConstructorByModelName;\n    try {\n      if (!this.db) {\n        this.db = await this.initDb();\n        this.resolve();\n      }\n    } catch (error) {\n      this.reject(error);\n    }\n  }\n  /**\n   * @param modelConstructor\n   * @returns local DB table name\n   */\n  getStorenameForModel(modelConstructor) {\n    const namespace = this.namespaceResolver(modelConstructor);\n    const {\n      name: modelName\n    } = modelConstructor;\n    return getStorename(namespace, modelName);\n  }\n  /**\n   *\n   * @param model - instantiated model record\n   * @returns the record's primary key values\n   */\n  getIndexKeyValuesFromModel(model) {\n    const modelConstructor = Object.getPrototypeOf(model).constructor;\n    const namespaceName = this.namespaceResolver(modelConstructor);\n    const keys = getIndexKeys(this.schema.namespaces[namespaceName], modelConstructor.name);\n    return extractPrimaryKeyValues(model, keys);\n  }\n  /**\n   * Common metadata for `save` operation\n   * used by individual storage adapters\n   *\n   * @param model\n   */\n  saveMetadata(model) {\n    const modelConstructor = Object.getPrototypeOf(model).constructor;\n    const storeName = this.getStorenameForModel(modelConstructor);\n    const namespaceName = this.namespaceResolver(modelConstructor);\n    const connectedModels = traverseModel(modelConstructor.name, model, this.schema.namespaces[namespaceName], this.modelInstanceCreator, this.getModelConstructorByModelName);\n    const set = new Set();\n    const connectionStoreNames = Object.values(connectedModels).map(_ref => {\n      let {\n        modelName,\n        item,\n        instance\n      } = _ref;\n      const storeName = getStorename(namespaceName, modelName);\n      set.add(storeName);\n      const keys = getIndexKeys(this.schema.namespaces[namespaceName], modelName);\n      return {\n        storeName,\n        item,\n        instance,\n        keys\n      };\n    });\n    const modelKeyValues = this.getIndexKeyValuesFromModel(model);\n    return {\n      storeName,\n      set,\n      connectionStoreNames,\n      modelKeyValues\n    };\n  }\n  /**\n   * Enforces conditional save. Throws if condition is not met.\n   * used by individual storage adapters\n   *\n   * @param model\n   */\n  validateSaveCondition(condition, fromDB) {\n    if (!(condition && fromDB)) {\n      return;\n    }\n    const predicates = ModelPredicateCreator.getPredicates(condition);\n    const {\n      predicates: predicateObjs,\n      type\n    } = predicates;\n    const isValid = validatePredicate(fromDB, type, predicateObjs);\n    if (!isValid) {\n      const msg = 'Conditional update failed';\n      logger.error(msg, {\n        model: fromDB,\n        condition: predicateObjs\n      });\n      throw new Error(msg);\n    }\n  }\n  /**\n   * Instantiate models from POJO records returned from the database\n   *\n   * @param namespaceName - string model namespace\n   * @param srcModelName - string model name\n   * @param records - array of uninstantiated records\n   * @returns\n   */\n  async load(namespaceName, srcModelName, records) {\n    const namespace = this.schema.namespaces[namespaceName];\n    const relations = namespace.relationships[srcModelName].relationTypes;\n    const connectionStoreNames = relations.map(_ref2 => {\n      let {\n        modelName\n      } = _ref2;\n      return getStorename(namespaceName, modelName);\n    });\n    const modelConstructor = this.getModelConstructorByModelName(namespaceName, srcModelName);\n    if (connectionStoreNames.length === 0) {\n      return records.map(record => this.modelInstanceCreator(modelConstructor, record));\n    }\n    return records.map(record => this.modelInstanceCreator(modelConstructor, record));\n  }\n  /**\n   * Extracts operands from a predicate group into an array of key values\n   * Used in the query method\n   *\n   * @param predicates - predicate group\n   * @param keyPath - string array of key names ['id', 'sortKey']\n   * @returns string[] of key values\n   *\n   * @example\n   * ```js\n   * { and:[{ id: { eq: 'abc' }}, { sortKey: { eq: 'def' }}] }\n   * ```\n   * Becomes\n   * ```\n   * ['abc', 'def']\n   * ```\n   */\n  keyValueFromPredicate(predicates, keyPath) {\n    const {\n      predicates: predicateObjs\n    } = predicates;\n    if (predicateObjs.length !== keyPath.length) {\n      return;\n    }\n    const keyValues = [];\n    for (const key of keyPath) {\n      const predicateObj = predicateObjs.find(p =>\n      // it's a relevant predicate object only if it's an equality\n      // operation for a key field from the key:\n      isPredicateObj(p) && p.field === key && p.operator === 'eq' && p.operand !== null && p.operand !== undefined);\n      predicateObj && keyValues.push(predicateObj.operand);\n    }\n    return keyValues.length === keyPath.length ? keyValues : undefined;\n  }\n  /**\n   * Common metadata for `query` operation\n   * used by individual storage adapters\n   *\n   * @param modelConstructor\n   * @param predicate\n   * @param pagination\n   */\n  queryMetadata(modelConstructor, predicate, pagination) {\n    const storeName = this.getStorenameForModel(modelConstructor);\n    const namespaceName = this.namespaceResolver(modelConstructor);\n    const predicates = predicate && ModelPredicateCreator.getPredicates(predicate);\n    const keyPath = getIndexKeys(this.schema.namespaces[namespaceName], modelConstructor.name);\n    const queryByKey = predicates && this.keyValueFromPredicate(predicates, keyPath);\n    const hasSort = pagination && pagination.sort;\n    const hasPagination = pagination && pagination.limit;\n    return {\n      storeName,\n      namespaceName,\n      queryByKey,\n      predicates,\n      hasSort,\n      hasPagination\n    };\n  }\n  /**\n   * Delete record\n   * Cascades to related records (for Has One and Has Many relationships)\n   *\n   * @param modelOrModelConstructor\n   * @param condition\n   * @returns\n   */\n  async delete(modelOrModelConstructor, condition) {\n    await this.preOpCheck();\n    const deleteQueue = [];\n    if (isModelConstructor(modelOrModelConstructor)) {\n      const modelConstructor = modelOrModelConstructor;\n      const namespace = this.namespaceResolver(modelConstructor);\n      const models = await this.query(modelConstructor, condition);\n      if (condition !== undefined) {\n        await this.deleteTraverse(models, modelConstructor, namespace, deleteQueue);\n        await this.deleteItem(deleteQueue);\n        const deletedModels = deleteQueue.reduce((acc, _ref3) => {\n          let {\n            items\n          } = _ref3;\n          return acc.concat(items);\n        }, []);\n        return [models, deletedModels];\n      } else {\n        await this.deleteTraverse(models, modelConstructor, namespace, deleteQueue);\n        await this.deleteItem(deleteQueue);\n        const deletedModels = deleteQueue.reduce((acc, _ref4) => {\n          let {\n            items\n          } = _ref4;\n          return acc.concat(items);\n        }, []);\n        return [models, deletedModels];\n      }\n    } else {\n      const model = modelOrModelConstructor;\n      const modelConstructor = Object.getPrototypeOf(model).constructor;\n      const namespaceName = this.namespaceResolver(modelConstructor);\n      const storeName = this.getStorenameForModel(modelConstructor);\n      if (condition) {\n        const keyValues = this.getIndexKeyValuesFromModel(model);\n        const fromDB = await this._get(storeName, keyValues);\n        if (fromDB === undefined) {\n          const msg = 'Model instance not found in storage';\n          logger.warn(msg, {\n            model\n          });\n          return [[model], []];\n        }\n        const predicates = ModelPredicateCreator.getPredicates(condition);\n        const {\n          predicates: predicateObjs,\n          type\n        } = predicates;\n        const isValid = validatePredicate(fromDB, type, predicateObjs);\n        if (!isValid) {\n          const msg = 'Conditional update failed';\n          logger.error(msg, {\n            model: fromDB,\n            condition: predicateObjs\n          });\n          throw new Error(msg);\n        }\n        await this.deleteTraverse([model], modelConstructor, namespaceName, deleteQueue);\n      } else {\n        await this.deleteTraverse([model], modelConstructor, namespaceName, deleteQueue);\n      }\n      await this.deleteItem(deleteQueue);\n      const deletedModels = deleteQueue.reduce((acc, _ref5) => {\n        let {\n          items\n        } = _ref5;\n        return acc.concat(items);\n      }, []);\n      return [[model], deletedModels];\n    }\n  }\n  /**\n   * Recursively traverse relationship graph and add\n   * all Has One and Has Many relations to `deleteQueue` param\n   *\n   * Actual deletion of records added to `deleteQueue` occurs in the `delete` method\n   *\n   * @param models\n   * @param modelConstructor\n   * @param namespace\n   * @param deleteQueue\n   */\n  async deleteTraverse(models, modelConstructor, namespace, deleteQueue) {\n    const cascadingRelationTypes = ['HAS_ONE', 'HAS_MANY'];\n    for await (const model of models) {\n      const modelDefinition = this.schema.namespaces[namespace].models[modelConstructor.name];\n      const modelMeta = {\n        builder: modelConstructor,\n        schema: modelDefinition,\n        pkField: extractPrimaryKeyFieldNames(modelDefinition)\n      };\n      const relationships = ModelRelationship.allFrom(modelMeta).filter(r => cascadingRelationTypes.includes(r.type));\n      for await (const r of relationships) {\n        const queryObject = r.createRemoteQueryObject(model);\n        if (queryObject !== null) {\n          const relatedRecords = await this.query(r.remoteModelConstructor, ModelPredicateCreator.createFromFlatEqualities(r.remoteDefinition, queryObject));\n          await this.deleteTraverse(relatedRecords, r.remoteModelConstructor, namespace, deleteQueue);\n        }\n      }\n    }\n    deleteQueue.push({\n      storeName: getStorename(namespace, modelConstructor.name),\n      items: models\n    });\n  }\n}\nexport { StorageAdapterBase };","map":{"version":3,"names":["logger","ConsoleLogger","DB_NAME","StorageAdapterBase","constructor","dbName","setUp","theSchema","namespaceResolver","modelInstanceCreator","getModelConstructorByModelName","sessionId","preSetUpChecks","initPromise","Promise","res","rej","resolve","reject","concat","schema","db","initDb","error","getStorenameForModel","modelConstructor","namespace","name","modelName","getStorename","getIndexKeyValuesFromModel","model","Object","getPrototypeOf","namespaceName","keys","getIndexKeys","namespaces","extractPrimaryKeyValues","saveMetadata","storeName","connectedModels","traverseModel","set","Set","connectionStoreNames","values","map","_ref","item","instance","add","modelKeyValues","validateSaveCondition","condition","fromDB","predicates","ModelPredicateCreator","getPredicates","predicateObjs","type","isValid","validatePredicate","msg","Error","load","srcModelName","records","relations","relationships","relationTypes","_ref2","length","record","keyValueFromPredicate","keyPath","keyValues","key","predicateObj","find","p","isPredicateObj","field","operator","operand","undefined","push","queryMetadata","predicate","pagination","queryByKey","hasSort","sort","hasPagination","limit","delete","modelOrModelConstructor","preOpCheck","deleteQueue","isModelConstructor","models","query","deleteTraverse","deleteItem","deletedModels","reduce","acc","_ref3","items","_ref4","_get","warn","_ref5","cascadingRelationTypes","modelDefinition","modelMeta","builder","pkField","extractPrimaryKeyFieldNames","ModelRelationship","allFrom","filter","r","includes","queryObject","createRemoteQueryObject","relatedRecords","remoteModelConstructor","createFromFlatEqualities","remoteDefinition"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/storage/adapter/StorageAdapterBase.ts"],"sourcesContent":["import { ModelPredicateCreator } from '../../predicates';\nimport { isPredicateObj, } from '../../types';\nimport { getStorename, getIndexKeys, extractPrimaryKeyValues, traverseModel, validatePredicate, isModelConstructor, extractPrimaryKeyFieldNames, } from '../../util';\nimport { ModelRelationship } from '../relationship';\nimport { ConsoleLogger } from '@aws-amplify/core';\nconst logger = new ConsoleLogger('DataStore');\nconst DB_NAME = 'amplify-datastore';\nexport class StorageAdapterBase {\n    constructor() {\n        this.dbName = DB_NAME;\n    }\n    /**\n     * Initializes local DB\n     *\n     * @param theSchema\n     * @param namespaceResolver\n     * @param modelInstanceCreator\n     * @param getModelConstructorByModelName\n     * @param sessionId\n     */\n    async setUp(theSchema, namespaceResolver, modelInstanceCreator, getModelConstructorByModelName, sessionId) {\n        await this.preSetUpChecks();\n        if (!this.initPromise) {\n            this.initPromise = new Promise((res, rej) => {\n                this.resolve = res;\n                this.reject = rej;\n            });\n        }\n        else {\n            await this.initPromise;\n            return;\n        }\n        if (sessionId) {\n            this.dbName = `${DB_NAME}-${sessionId}`;\n        }\n        this.schema = theSchema;\n        this.namespaceResolver = namespaceResolver;\n        this.modelInstanceCreator = modelInstanceCreator;\n        this.getModelConstructorByModelName = getModelConstructorByModelName;\n        try {\n            if (!this.db) {\n                this.db = await this.initDb();\n                this.resolve();\n            }\n        }\n        catch (error) {\n            this.reject(error);\n        }\n    }\n    /**\n     * @param modelConstructor\n     * @returns local DB table name\n     */\n    getStorenameForModel(modelConstructor) {\n        const namespace = this.namespaceResolver(modelConstructor);\n        const { name: modelName } = modelConstructor;\n        return getStorename(namespace, modelName);\n    }\n    /**\n     *\n     * @param model - instantiated model record\n     * @returns the record's primary key values\n     */\n    getIndexKeyValuesFromModel(model) {\n        const modelConstructor = Object.getPrototypeOf(model)\n            .constructor;\n        const namespaceName = this.namespaceResolver(modelConstructor);\n        const keys = getIndexKeys(this.schema.namespaces[namespaceName], modelConstructor.name);\n        return extractPrimaryKeyValues(model, keys);\n    }\n    /**\n     * Common metadata for `save` operation\n     * used by individual storage adapters\n     *\n     * @param model\n     */\n    saveMetadata(model) {\n        const modelConstructor = Object.getPrototypeOf(model)\n            .constructor;\n        const storeName = this.getStorenameForModel(modelConstructor);\n        const namespaceName = this.namespaceResolver(modelConstructor);\n        const connectedModels = traverseModel(modelConstructor.name, model, this.schema.namespaces[namespaceName], this.modelInstanceCreator, this.getModelConstructorByModelName);\n        const set = new Set();\n        const connectionStoreNames = Object.values(connectedModels).map(({ modelName, item, instance }) => {\n            const storeName = getStorename(namespaceName, modelName);\n            set.add(storeName);\n            const keys = getIndexKeys(this.schema.namespaces[namespaceName], modelName);\n            return { storeName, item, instance, keys };\n        });\n        const modelKeyValues = this.getIndexKeyValuesFromModel(model);\n        return { storeName, set, connectionStoreNames, modelKeyValues };\n    }\n    /**\n     * Enforces conditional save. Throws if condition is not met.\n     * used by individual storage adapters\n     *\n     * @param model\n     */\n    validateSaveCondition(condition, fromDB) {\n        if (!(condition && fromDB)) {\n            return;\n        }\n        const predicates = ModelPredicateCreator.getPredicates(condition);\n        const { predicates: predicateObjs, type } = predicates;\n        const isValid = validatePredicate(fromDB, type, predicateObjs);\n        if (!isValid) {\n            const msg = 'Conditional update failed';\n            logger.error(msg, { model: fromDB, condition: predicateObjs });\n            throw new Error(msg);\n        }\n    }\n    /**\n     * Instantiate models from POJO records returned from the database\n     *\n     * @param namespaceName - string model namespace\n     * @param srcModelName - string model name\n     * @param records - array of uninstantiated records\n     * @returns\n     */\n    async load(namespaceName, srcModelName, records) {\n        const namespace = this.schema.namespaces[namespaceName];\n        const relations = namespace.relationships[srcModelName].relationTypes;\n        const connectionStoreNames = relations.map(({ modelName }) => {\n            return getStorename(namespaceName, modelName);\n        });\n        const modelConstructor = this.getModelConstructorByModelName(namespaceName, srcModelName);\n        if (connectionStoreNames.length === 0) {\n            return records.map(record => this.modelInstanceCreator(modelConstructor, record));\n        }\n        return records.map(record => this.modelInstanceCreator(modelConstructor, record));\n    }\n    /**\n     * Extracts operands from a predicate group into an array of key values\n     * Used in the query method\n     *\n     * @param predicates - predicate group\n     * @param keyPath - string array of key names ['id', 'sortKey']\n     * @returns string[] of key values\n     *\n     * @example\n     * ```js\n     * { and:[{ id: { eq: 'abc' }}, { sortKey: { eq: 'def' }}] }\n     * ```\n     * Becomes\n     * ```\n     * ['abc', 'def']\n     * ```\n     */\n    keyValueFromPredicate(predicates, keyPath) {\n        const { predicates: predicateObjs } = predicates;\n        if (predicateObjs.length !== keyPath.length) {\n            return;\n        }\n        const keyValues = [];\n        for (const key of keyPath) {\n            const predicateObj = predicateObjs.find(p => \n            // it's a relevant predicate object only if it's an equality\n            // operation for a key field from the key:\n            isPredicateObj(p) &&\n                p.field === key &&\n                p.operator === 'eq' &&\n                p.operand !== null &&\n                p.operand !== undefined);\n            predicateObj && keyValues.push(predicateObj.operand);\n        }\n        return keyValues.length === keyPath.length ? keyValues : undefined;\n    }\n    /**\n     * Common metadata for `query` operation\n     * used by individual storage adapters\n     *\n     * @param modelConstructor\n     * @param predicate\n     * @param pagination\n     */\n    queryMetadata(modelConstructor, predicate, pagination) {\n        const storeName = this.getStorenameForModel(modelConstructor);\n        const namespaceName = this.namespaceResolver(modelConstructor);\n        const predicates = predicate && ModelPredicateCreator.getPredicates(predicate);\n        const keyPath = getIndexKeys(this.schema.namespaces[namespaceName], modelConstructor.name);\n        const queryByKey = predicates && this.keyValueFromPredicate(predicates, keyPath);\n        const hasSort = pagination && pagination.sort;\n        const hasPagination = pagination && pagination.limit;\n        return {\n            storeName,\n            namespaceName,\n            queryByKey,\n            predicates,\n            hasSort,\n            hasPagination,\n        };\n    }\n    /**\n     * Delete record\n     * Cascades to related records (for Has One and Has Many relationships)\n     *\n     * @param modelOrModelConstructor\n     * @param condition\n     * @returns\n     */\n    async delete(modelOrModelConstructor, condition) {\n        await this.preOpCheck();\n        const deleteQueue = [];\n        if (isModelConstructor(modelOrModelConstructor)) {\n            const modelConstructor = modelOrModelConstructor;\n            const namespace = this.namespaceResolver(modelConstructor);\n            const models = await this.query(modelConstructor, condition);\n            if (condition !== undefined) {\n                await this.deleteTraverse(models, modelConstructor, namespace, deleteQueue);\n                await this.deleteItem(deleteQueue);\n                const deletedModels = deleteQueue.reduce((acc, { items }) => acc.concat(items), []);\n                return [models, deletedModels];\n            }\n            else {\n                await this.deleteTraverse(models, modelConstructor, namespace, deleteQueue);\n                await this.deleteItem(deleteQueue);\n                const deletedModels = deleteQueue.reduce((acc, { items }) => acc.concat(items), []);\n                return [models, deletedModels];\n            }\n        }\n        else {\n            const model = modelOrModelConstructor;\n            const modelConstructor = Object.getPrototypeOf(model)\n                .constructor;\n            const namespaceName = this.namespaceResolver(modelConstructor);\n            const storeName = this.getStorenameForModel(modelConstructor);\n            if (condition) {\n                const keyValues = this.getIndexKeyValuesFromModel(model);\n                const fromDB = await this._get(storeName, keyValues);\n                if (fromDB === undefined) {\n                    const msg = 'Model instance not found in storage';\n                    logger.warn(msg, { model });\n                    return [[model], []];\n                }\n                const predicates = ModelPredicateCreator.getPredicates(condition);\n                const { predicates: predicateObjs, type } = predicates;\n                const isValid = validatePredicate(fromDB, type, predicateObjs);\n                if (!isValid) {\n                    const msg = 'Conditional update failed';\n                    logger.error(msg, { model: fromDB, condition: predicateObjs });\n                    throw new Error(msg);\n                }\n                await this.deleteTraverse([model], modelConstructor, namespaceName, deleteQueue);\n            }\n            else {\n                await this.deleteTraverse([model], modelConstructor, namespaceName, deleteQueue);\n            }\n            await this.deleteItem(deleteQueue);\n            const deletedModels = deleteQueue.reduce((acc, { items }) => acc.concat(items), []);\n            return [[model], deletedModels];\n        }\n    }\n    /**\n     * Recursively traverse relationship graph and add\n     * all Has One and Has Many relations to `deleteQueue` param\n     *\n     * Actual deletion of records added to `deleteQueue` occurs in the `delete` method\n     *\n     * @param models\n     * @param modelConstructor\n     * @param namespace\n     * @param deleteQueue\n     */\n    async deleteTraverse(models, modelConstructor, namespace, deleteQueue) {\n        const cascadingRelationTypes = ['HAS_ONE', 'HAS_MANY'];\n        for await (const model of models) {\n            const modelDefinition = this.schema.namespaces[namespace].models[modelConstructor.name];\n            const modelMeta = {\n                builder: modelConstructor,\n                schema: modelDefinition,\n                pkField: extractPrimaryKeyFieldNames(modelDefinition),\n            };\n            const relationships = ModelRelationship.allFrom(modelMeta).filter(r => cascadingRelationTypes.includes(r.type));\n            for await (const r of relationships) {\n                const queryObject = r.createRemoteQueryObject(model);\n                if (queryObject !== null) {\n                    const relatedRecords = await this.query(r.remoteModelConstructor, ModelPredicateCreator.createFromFlatEqualities(r.remoteDefinition, queryObject));\n                    await this.deleteTraverse(relatedRecords, r.remoteModelConstructor, namespace, deleteQueue);\n                }\n            }\n        }\n        deleteQueue.push({\n            storeName: getStorename(namespace, modelConstructor.name),\n            items: models,\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}