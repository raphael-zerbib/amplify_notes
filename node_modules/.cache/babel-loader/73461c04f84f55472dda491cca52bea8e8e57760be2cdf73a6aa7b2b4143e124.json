{"ast":null,"code":"class ModelSortPredicateCreator {\n  static createPredicateBuilder(modelDefinition) {\n    const {\n      name: modelName\n    } = modelDefinition;\n    const fieldNames = new Set(Object.keys(modelDefinition.fields));\n    const predicate = new Proxy({}, {\n      get(_target, propertyKey, receiver) {\n        const field = propertyKey;\n        if (!fieldNames.has(field)) {\n          throw new Error(`Invalid field for model. field: ${String(field)}, model: ${modelName}`);\n        }\n        const result = sortDirection => {\n          ModelSortPredicateCreator.sortPredicateGroupsMap.get(receiver)?.push({\n            field,\n            sortDirection\n          });\n          return receiver;\n        };\n        return result;\n      }\n    });\n    ModelSortPredicateCreator.sortPredicateGroupsMap.set(predicate, []);\n    return predicate;\n  }\n  static isValidPredicate(predicate) {\n    return ModelSortPredicateCreator.sortPredicateGroupsMap.has(predicate);\n  }\n  static getPredicates(predicate, throwOnInvalid = true) {\n    if (throwOnInvalid && !ModelSortPredicateCreator.isValidPredicate(predicate)) {\n      throw new Error('The predicate is not valid');\n    }\n    const predicateGroup = ModelSortPredicateCreator.sortPredicateGroupsMap.get(predicate);\n    if (predicateGroup) {\n      return predicateGroup;\n    } else {\n      throw new Error('Predicate group not found');\n    }\n  }\n  // transforms cb-style predicate into Proxy\n  static createFromExisting(modelDefinition, existing) {\n    if (!existing || !modelDefinition) {\n      return undefined;\n    }\n    return existing(ModelSortPredicateCreator.createPredicateBuilder(modelDefinition));\n  }\n}\nModelSortPredicateCreator.sortPredicateGroupsMap = new WeakMap();\nexport { ModelSortPredicateCreator };","map":{"version":3,"names":["ModelSortPredicateCreator","createPredicateBuilder","modelDefinition","name","modelName","fieldNames","Set","Object","keys","fields","predicate","Proxy","get","_target","propertyKey","receiver","field","has","Error","String","result","sortDirection","sortPredicateGroupsMap","push","set","isValidPredicate","getPredicates","throwOnInvalid","predicateGroup","createFromExisting","existing","undefined","WeakMap"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/predicates/sort.ts"],"sourcesContent":["export class ModelSortPredicateCreator {\n    static createPredicateBuilder(modelDefinition) {\n        const { name: modelName } = modelDefinition;\n        const fieldNames = new Set(Object.keys(modelDefinition.fields));\n        let handler;\n        const predicate = new Proxy({}, (handler = {\n            get(_target, propertyKey, receiver) {\n                const field = propertyKey;\n                if (!fieldNames.has(field)) {\n                    throw new Error(`Invalid field for model. field: ${String(field)}, model: ${modelName}`);\n                }\n                const result = (sortDirection) => {\n                    ModelSortPredicateCreator.sortPredicateGroupsMap\n                        .get(receiver)\n                        ?.push({ field, sortDirection });\n                    return receiver;\n                };\n                return result;\n            },\n        }));\n        ModelSortPredicateCreator.sortPredicateGroupsMap.set(predicate, []);\n        return predicate;\n    }\n    static isValidPredicate(predicate) {\n        return ModelSortPredicateCreator.sortPredicateGroupsMap.has(predicate);\n    }\n    static getPredicates(predicate, throwOnInvalid = true) {\n        if (throwOnInvalid &&\n            !ModelSortPredicateCreator.isValidPredicate(predicate)) {\n            throw new Error('The predicate is not valid');\n        }\n        const predicateGroup = ModelSortPredicateCreator.sortPredicateGroupsMap.get(predicate);\n        if (predicateGroup) {\n            return predicateGroup;\n        }\n        else {\n            throw new Error('Predicate group not found');\n        }\n    }\n    // transforms cb-style predicate into Proxy\n    static createFromExisting(modelDefinition, existing) {\n        if (!existing || !modelDefinition) {\n            return undefined;\n        }\n        return existing(ModelSortPredicateCreator.createPredicateBuilder(modelDefinition));\n    }\n}\nModelSortPredicateCreator.sortPredicateGroupsMap = new WeakMap();\n"],"mappings":"AAAO,MAAMA,yBAAyB,CAAC;EACnC,OAAOC,sBAAsBA,CAACC,eAAe,EAAE;IAC3C,MAAM;MAAEC,IAAI,EAAEC;IAAS,CAAE,GAAGF,eAAe;IAC3C,MAAMG,UAAU,GAAG,IAAIC,GAAG,CAACC,MAAM,CAACC,IAAI,CAACN,eAAe,CAACO,MAAM,CAAC,CAAC;IAE/D,MAAMC,SAAS,GAAG,IAAIC,KAAK,CAAC,EAAE,EAAa;MACvCC,GAAGA,CAACC,OAAO,EAAEC,WAAW,EAAEC,QAAQ,EAAE;QAChC,MAAMC,KAAK,GAAGF,WAAW;QACzB,IAAI,CAACT,UAAU,CAACY,GAAG,CAACD,KAAK,CAAC,EAAE;UACxB,MAAM,IAAIE,KAAK,CAAE,mCAAkCC,MAAM,CAACH,KAAK,CAAE,YAAWZ,SAAU,EAAC,CAAC;QAC5G;QACgB,MAAMgB,MAAM,GAAIC,aAAa,IAAK;UAC9BrB,yBAAyB,CAACsB,sBAAsB,CAC3CV,GAAG,CAACG,QAAQ,CAAC,EACZQ,IAAI,CAAC;YAAEP,KAAK;YAAEK;UAAa,CAAE,CAAC;UACpC,OAAON,QAAQ;QACnC,CAAiB;QACD,OAAOK,MAAM;MAC7B;IACA,CAAS,CAAE;IACHpB,yBAAyB,CAACsB,sBAAsB,CAACE,GAAG,CAACd,SAAS,EAAE,EAAE,CAAC;IACnE,OAAOA,SAAS;EACxB;EACI,OAAOe,gBAAgBA,CAACf,SAAS,EAAE;IAC/B,OAAOV,yBAAyB,CAACsB,sBAAsB,CAACL,GAAG,CAACP,SAAS,CAAC;EAC9E;EACI,OAAOgB,aAAaA,CAAChB,SAAS,EAAEiB,cAAc,GAAG,IAAI,EAAE;IACnD,IAAIA,cAAc,IACd,CAAC3B,yBAAyB,CAACyB,gBAAgB,CAACf,SAAS,CAAC,EAAE;MACxD,MAAM,IAAIQ,KAAK,CAAC,4BAA4B,CAAC;IACzD;IACQ,MAAMU,cAAc,GAAG5B,yBAAyB,CAACsB,sBAAsB,CAACV,GAAG,CAACF,SAAS,CAAC;IACtF,IAAIkB,cAAc,EAAE;MAChB,OAAOA,cAAc;IACjC,CAAS,MACI;MACD,MAAM,IAAIV,KAAK,CAAC,2BAA2B,CAAC;IACxD;EACA;EACA;EACI,OAAOW,kBAAkBA,CAAC3B,eAAe,EAAE4B,QAAQ,EAAE;IACjD,IAAI,CAACA,QAAQ,IAAI,CAAC5B,eAAe,EAAE;MAC/B,OAAO6B,SAAS;IAC5B;IACQ,OAAOD,QAAQ,CAAC9B,yBAAyB,CAACC,sBAAsB,CAACC,eAAe,CAAC,CAAC;EAC1F;AACA;AACAF,yBAAyB,CAACsB,sBAAsB,GAAG,IAAIU,OAAO,EAAE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}