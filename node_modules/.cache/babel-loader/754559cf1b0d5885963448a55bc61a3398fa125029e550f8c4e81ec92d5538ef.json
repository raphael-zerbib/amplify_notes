{"ast":null,"code":"import { InternalAPI } from '@aws-amplify/api/internals';\nimport { ConsoleLogger, fetchAuthSession, Hub } from '@aws-amplify/core';\nimport { BackgroundProcessManager, Category, DataStoreAction } from '@aws-amplify/core/internals/utils';\nimport { Observable } from 'rxjs';\nimport { ProcessName } from '../../types.mjs';\nimport { buildSubscriptionGraphQLOperation, getAuthorizationRules, getUserGroupsFromToken, getModelAuthModes, TransformerMutationType, RTFError, generateRTFRemediation, getTokenForCustomAuth, predicateToGraphQLFilter } from '../utils.mjs';\nimport { ModelPredicateCreator } from '../../predicates/index.mjs';\nimport { validatePredicate } from '../../util.mjs';\nimport { getSubscriptionErrorType } from './errorMaps.mjs';\nimport { CONTROL_MSG as CONTROL_MSG$1 } from '@aws-amplify/api-graphql';\nconst logger = new ConsoleLogger('DataStore');\nvar CONTROL_MSG;\n(function (CONTROL_MSG) {\n  CONTROL_MSG[\"CONNECTED\"] = \"CONNECTED\";\n})(CONTROL_MSG || (CONTROL_MSG = {}));\nvar USER_CREDENTIALS;\n(function (USER_CREDENTIALS) {\n  USER_CREDENTIALS[USER_CREDENTIALS[\"none\"] = 0] = \"none\";\n  USER_CREDENTIALS[USER_CREDENTIALS[\"unauth\"] = 1] = \"unauth\";\n  USER_CREDENTIALS[USER_CREDENTIALS[\"auth\"] = 2] = \"auth\";\n})(USER_CREDENTIALS || (USER_CREDENTIALS = {}));\nclass SubscriptionProcessor {\n  constructor(schema, syncPredicates, amplifyConfig = {}, authModeStrategy, errorHandler, amplifyContext = {\n    InternalAPI\n  }) {\n    this.schema = schema;\n    this.syncPredicates = syncPredicates;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.errorHandler = errorHandler;\n    this.amplifyContext = amplifyContext;\n    this.typeQuery = new WeakMap();\n    this.buffer = [];\n    this.runningProcesses = new BackgroundProcessManager();\n  }\n  buildSubscription(namespace, model, transformerMutationType, userCredentials, oidcTokenPayload, authMode, filterArg = false) {\n    const {\n      aws_appsync_authenticationType\n    } = this.amplifyConfig;\n    const {\n      isOwner,\n      ownerField,\n      ownerValue\n    } = this.getAuthorizationInfo(model, userCredentials, aws_appsync_authenticationType, oidcTokenPayload, authMode) || {};\n    const [opType, opName, query] = buildSubscriptionGraphQLOperation(namespace, model, transformerMutationType, isOwner, ownerField, filterArg);\n    return {\n      authMode,\n      opType,\n      opName,\n      query,\n      isOwner,\n      ownerField,\n      ownerValue\n    };\n  }\n  getAuthorizationInfo(model, userCredentials, defaultAuthType, oidcTokenPayload, authMode) {\n    const rules = getAuthorizationRules(model);\n    // Return null if user doesn't have proper credentials for private API with IAM auth\n    const iamPrivateAuth = authMode === 'iam' && rules.find(rule => rule.authStrategy === 'private' && rule.provider === 'iam');\n    if (iamPrivateAuth && userCredentials === USER_CREDENTIALS.unauth) {\n      return null;\n    }\n    // Group auth should take precedence over owner auth, so we are checking\n    // if rule(s) have group authorization as well as if either the Cognito or\n    // OIDC token has a groupClaim. If so, we are returning auth info before\n    // any further owner-based auth checks.\n    const groupAuthRules = rules.filter(rule => rule.authStrategy === 'groups' && ['userPools', 'oidc'].includes(rule.provider));\n    const validGroup = (authMode === 'oidc' || authMode === 'userPool') && groupAuthRules.find(groupAuthRule => {\n      // validate token against groupClaim\n      if (oidcTokenPayload) {\n        const oidcUserGroups = getUserGroupsFromToken(oidcTokenPayload, groupAuthRule);\n        return [...oidcUserGroups].find(userGroup => {\n          return groupAuthRule.groups.find(group => group === userGroup);\n        });\n      }\n    });\n    if (validGroup) {\n      return {\n        authMode,\n        isOwner: false\n      };\n    }\n    let ownerAuthInfo;\n    if (ownerAuthInfo) {\n      return ownerAuthInfo;\n    }\n    // Owner auth needs additional values to be returned in order to create the subscription with\n    // the correct parameters so we are getting the owner value from the OIDC token via the\n    // identityClaim from the auth rule.\n    const oidcOwnerAuthRules = authMode === 'oidc' || authMode === 'userPool' ? rules.filter(rule => rule.authStrategy === 'owner' && (rule.provider === 'oidc' || rule.provider === 'userPools')) : [];\n    oidcOwnerAuthRules.forEach(ownerAuthRule => {\n      const ownerValue = oidcTokenPayload[ownerAuthRule.identityClaim];\n      const singleOwner = model.fields[ownerAuthRule.ownerField]?.isArray !== true;\n      const isOwnerArgRequired = singleOwner && !ownerAuthRule.areSubscriptionsPublic;\n      if (ownerValue) {\n        ownerAuthInfo = {\n          authMode,\n          isOwner: isOwnerArgRequired,\n          ownerField: ownerAuthRule.ownerField,\n          ownerValue: String(ownerValue)\n        };\n      }\n    });\n    if (ownerAuthInfo) {\n      return ownerAuthInfo;\n    }\n    // Fallback: return authMode or default auth type\n    return {\n      authMode: authMode || defaultAuthType,\n      isOwner: false\n    };\n  }\n  hubQueryCompletionListener(completed, capsule) {\n    const {\n      payload: {\n        event\n      }\n    } = capsule;\n    if (event === CONTROL_MSG$1.SUBSCRIPTION_ACK) {\n      completed();\n    }\n  }\n  start() {\n    this.runningProcesses = this.runningProcesses || new BackgroundProcessManager();\n    const ctlObservable = new Observable(observer => {\n      const promises = [];\n      // Creating subs for each model/operation combo so they can be unsubscribed\n      // independently, since the auth retry behavior is asynchronous.\n      let subscriptions = {};\n      let oidcTokenPayload;\n      let userCredentials = USER_CREDENTIALS.none;\n      this.runningProcesses.add(async () => {\n        try {\n          // retrieving current AWS Credentials\n          const credentials = (await fetchAuthSession()).tokens?.accessToken;\n          userCredentials = credentials ? USER_CREDENTIALS.auth : USER_CREDENTIALS.unauth;\n        } catch (err) {\n          // best effort to get AWS credentials\n        }\n        try {\n          // retrieving current token info from Cognito UserPools\n          const session = await fetchAuthSession();\n          oidcTokenPayload = session.tokens?.idToken?.payload;\n        } catch (err) {\n          // best effort to get jwt from Cognito\n        }\n        Object.values(this.schema.namespaces).forEach(namespace => {\n          Object.values(namespace.models).filter(({\n            syncable\n          }) => syncable).forEach(modelDefinition => this.runningProcesses.isOpen && this.runningProcesses.add(async () => {\n            const modelAuthModes = await getModelAuthModes({\n              authModeStrategy: this.authModeStrategy,\n              defaultAuthMode: this.amplifyConfig.aws_appsync_authenticationType,\n              modelName: modelDefinition.name,\n              schema: this.schema\n            });\n            // subscriptions are created only based on the READ auth mode(s)\n            const readAuthModes = modelAuthModes.READ;\n            subscriptions = {\n              ...subscriptions,\n              [modelDefinition.name]: {\n                [TransformerMutationType.CREATE]: [],\n                [TransformerMutationType.UPDATE]: [],\n                [TransformerMutationType.DELETE]: []\n              }\n            };\n            const operations = [TransformerMutationType.CREATE, TransformerMutationType.UPDATE, TransformerMutationType.DELETE];\n            const operationAuthModeAttempts = {\n              [TransformerMutationType.CREATE]: 0,\n              [TransformerMutationType.UPDATE]: 0,\n              [TransformerMutationType.DELETE]: 0\n            };\n            const predicatesGroup = ModelPredicateCreator.getPredicates(this.syncPredicates.get(modelDefinition), false);\n            const addFilterArg = predicatesGroup !== undefined;\n            // Retry subscriptions that failed for one of the following reasons:\n            // 1. unauthorized - retry with next auth mode (if available)\n            // 2. RTF error - retry without sending filter arg. (filtering will fall back to clientside)\n            const subscriptionRetry = async (operation, addFilter = addFilterArg) => {\n              const {\n                opType: transformerMutationType,\n                opName,\n                query,\n                isOwner,\n                ownerField,\n                ownerValue,\n                authMode\n              } = this.buildSubscription(namespace, modelDefinition, operation, userCredentials, oidcTokenPayload, readAuthModes[operationAuthModeAttempts[operation]], addFilter);\n              const authToken = await getTokenForCustomAuth(authMode, this.amplifyConfig);\n              const variables = {};\n              const customUserAgentDetails = {\n                category: Category.DataStore,\n                action: DataStoreAction.Subscribe\n              };\n              if (addFilter && predicatesGroup) {\n                variables['filter'] = predicateToGraphQLFilter(predicatesGroup);\n              }\n              if (isOwner) {\n                if (!ownerValue) {\n                  observer.error('Owner field required, sign in is needed in order to perform this operation');\n                  return;\n                }\n                variables[ownerField] = ownerValue;\n              }\n              logger.debug(`Attempting ${operation} subscription with authMode: ${readAuthModes[operationAuthModeAttempts[operation]]}`);\n              const queryObservable = this.amplifyContext.InternalAPI.graphql({\n                query,\n                variables,\n                ...{\n                  authMode\n                },\n                authToken\n              }, undefined, customUserAgentDetails);\n              let subscriptionReadyCallback;\n              // TODO: consider onTerminate.then(() => API.cancel(...))\n              subscriptions[modelDefinition.name][transformerMutationType].push(queryObservable.subscribe({\n                next: result => {\n                  const {\n                    data,\n                    errors\n                  } = result;\n                  if (Array.isArray(errors) && errors.length > 0) {\n                    const messages = errors.map(({\n                      message\n                    }) => message);\n                    logger.warn(`Skipping incoming subscription. Messages: ${messages.join('\\n')}`);\n                    this.drainBuffer();\n                    return;\n                  }\n                  const predicatesGroup = ModelPredicateCreator.getPredicates(this.syncPredicates.get(modelDefinition), false);\n                  // @ts-ignore\n                  const {\n                    [opName]: record\n                  } = data;\n                  // checking incoming subscription against syncPredicate.\n                  // once AppSync implements filters on subscriptions, we'll be\n                  // able to set these when establishing the subscription instead.\n                  // Until then, we'll need to filter inbound\n                  if (this.passesPredicateValidation(record, predicatesGroup)) {\n                    this.pushToBuffer(transformerMutationType, modelDefinition, record);\n                  }\n                  this.drainBuffer();\n                },\n                error: async subscriptionError => {\n                  const {\n                    errors: [{\n                      message = ''\n                    } = {}]\n                  } = subscriptionError;\n                  const isRTFError =\n                  // only attempt catch if a filter variable was added to the subscription query\n                  addFilter && this.catchRTFError(message, modelDefinition, predicatesGroup);\n                  // Catch RTF errors\n                  if (isRTFError) {\n                    // Unsubscribe and clear subscription array for model/operation\n                    subscriptions[modelDefinition.name][transformerMutationType].forEach(subscription => subscription.unsubscribe());\n                    subscriptions[modelDefinition.name][transformerMutationType] = [];\n                    // retry subscription connection without filter\n                    subscriptionRetry(operation, false);\n                    return;\n                  }\n                  if (message.includes(CONTROL_MSG$1.REALTIME_SUBSCRIPTION_INIT_ERROR) || message.includes(CONTROL_MSG$1.CONNECTION_FAILED)) {\n                    // Unsubscribe and clear subscription array for model/operation\n                    subscriptions[modelDefinition.name][transformerMutationType].forEach(subscription => subscription.unsubscribe());\n                    subscriptions[modelDefinition.name][transformerMutationType] = [];\n                    operationAuthModeAttempts[operation]++;\n                    if (operationAuthModeAttempts[operation] >= readAuthModes.length) {\n                      // last auth mode retry. Continue with error\n                      logger.debug(`${operation} subscription failed with authMode: ${readAuthModes[operationAuthModeAttempts[operation] - 1]}`);\n                    } else {\n                      // retry with different auth mode. Do not trigger\n                      // observer error or error handler\n                      logger.debug(`${operation} subscription failed with authMode: ${readAuthModes[operationAuthModeAttempts[operation] - 1]}. Retrying with authMode: ${readAuthModes[operationAuthModeAttempts[operation]]}`);\n                      subscriptionRetry(operation);\n                      return;\n                    }\n                  }\n                  logger.warn('subscriptionError', message);\n                  try {\n                    await this.errorHandler({\n                      recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                      localModel: null,\n                      message,\n                      model: modelDefinition.name,\n                      operation,\n                      errorType: getSubscriptionErrorType(subscriptionError),\n                      process: ProcessName.subscribe,\n                      remoteModel: null,\n                      cause: subscriptionError\n                    });\n                  } catch (e) {\n                    logger.error('Subscription error handler failed with:', e);\n                  }\n                  if (typeof subscriptionReadyCallback === 'function') {\n                    subscriptionReadyCallback();\n                  }\n                  if (message.includes('\"errorType\":\"Unauthorized\"') || message.includes('\"errorType\":\"OperationDisabled\"')) {\n                    return;\n                  }\n                  observer.error(message);\n                }\n              }));\n              promises.push((async () => {\n                let boundFunction;\n                let removeBoundFunctionListener;\n                await new Promise(res => {\n                  subscriptionReadyCallback = res;\n                  boundFunction = this.hubQueryCompletionListener.bind(this, res);\n                  removeBoundFunctionListener = Hub.listen('api', boundFunction);\n                });\n                removeBoundFunctionListener();\n              })());\n            };\n            operations.forEach(op => subscriptionRetry(op));\n          }));\n        });\n        this.runningProcesses.isOpen && this.runningProcesses.add(() => Promise.all(promises).then(() => {\n          observer.next(CONTROL_MSG.CONNECTED);\n        }));\n      }, 'subscription processor new subscriber');\n      return this.runningProcesses.addCleaner(async () => {\n        Object.keys(subscriptions).forEach(modelName => {\n          subscriptions[modelName][TransformerMutationType.CREATE].forEach(subscription => subscription.unsubscribe());\n          subscriptions[modelName][TransformerMutationType.UPDATE].forEach(subscription => subscription.unsubscribe());\n          subscriptions[modelName][TransformerMutationType.DELETE].forEach(subscription => subscription.unsubscribe());\n        });\n      });\n    });\n    const dataObservable = new Observable(observer => {\n      this.dataObserver = observer;\n      this.drainBuffer();\n      return this.runningProcesses.addCleaner(async () => {\n        this.dataObserver = null;\n      });\n    });\n    return [ctlObservable, dataObservable];\n  }\n  async stop() {\n    await this.runningProcesses.close();\n    await this.runningProcesses.open();\n  }\n  passesPredicateValidation(record, predicatesGroup) {\n    if (!predicatesGroup) {\n      return true;\n    }\n    const {\n      predicates,\n      type\n    } = predicatesGroup;\n    return validatePredicate(record, type, predicates);\n  }\n  pushToBuffer(transformerMutationType, modelDefinition, data) {\n    this.buffer.push([transformerMutationType, modelDefinition, data]);\n  }\n  drainBuffer() {\n    if (this.dataObserver) {\n      this.buffer.forEach(data => this.dataObserver.next(data));\n      this.buffer = [];\n    }\n  }\n  /**\n   * @returns true if the service returned an RTF subscription error\n   * @remarks logs a warning with remediation instructions\n   *\n   */\n  catchRTFError(message, modelDefinition, predicatesGroup) {\n    const header = 'Backend subscriptions filtering error.\\n' + 'Subscriptions filtering will be applied clientside.\\n';\n    const messageErrorTypeMap = {\n      'UnknownArgument: Unknown field argument filter': RTFError.UnknownField,\n      'Filters exceed maximum attributes limit': RTFError.MaxAttributes,\n      'Filters combination exceed maximum limit': RTFError.MaxCombinations,\n      'filter uses same fieldName multiple time': RTFError.RepeatedFieldname,\n      \"The variables input contains a field name 'not'\": RTFError.NotGroup,\n      'The variables input contains a field that is not defined for input object type': RTFError.FieldNotInType\n    };\n    const [_errorMsg, errorType] = Object.entries(messageErrorTypeMap).find(([errorMsg]) => message.includes(errorMsg)) || [];\n    if (errorType !== undefined) {\n      const remediationMessage = generateRTFRemediation(errorType, modelDefinition, predicatesGroup);\n      logger.warn(`${header}\\n${message}\\n${remediationMessage}`);\n      return true;\n    }\n    return false;\n  }\n}\nexport { CONTROL_MSG, SubscriptionProcessor, USER_CREDENTIALS };","map":{"version":3,"names":["logger","ConsoleLogger","CONTROL_MSG","USER_CREDENTIALS","SubscriptionProcessor","constructor","schema","syncPredicates","amplifyConfig","authModeStrategy","errorHandler","amplifyContext","InternalAPI","typeQuery","WeakMap","buffer","runningProcesses","BackgroundProcessManager","buildSubscription","namespace","model","transformerMutationType","userCredentials","oidcTokenPayload","authMode","filterArg","aws_appsync_authenticationType","isOwner","ownerField","ownerValue","getAuthorizationInfo","opType","opName","query","buildSubscriptionGraphQLOperation","defaultAuthType","rules","getAuthorizationRules","iamPrivateAuth","find","rule","authStrategy","provider","unauth","groupAuthRules","filter","includes","validGroup","groupAuthRule","oidcUserGroups","getUserGroupsFromToken","userGroup","groups","group","ownerAuthInfo","oidcOwnerAuthRules","forEach","ownerAuthRule","identityClaim","singleOwner","fields","isArray","isOwnerArgRequired","areSubscriptionsPublic","String","hubQueryCompletionListener","completed","capsule","payload","event","CONTROL_MSG$1","SUBSCRIPTION_ACK","start","ctlObservable","Observable","observer","promises","subscriptions","none","add","credentials","fetchAuthSession","tokens","accessToken","auth","err","session","idToken","Object","values","namespaces","models","syncable","modelDefinition","isOpen","modelAuthModes","getModelAuthModes","defaultAuthMode","modelName","name","readAuthModes","READ","TransformerMutationType","CREATE","UPDATE","DELETE","operations","operationAuthModeAttempts","predicatesGroup","ModelPredicateCreator","getPredicates","get","addFilterArg","undefined","subscriptionRetry","operation","addFilter","authToken","getTokenForCustomAuth","variables","customUserAgentDetails","category","Category","DataStore","action","DataStoreAction","Subscribe","predicateToGraphQLFilter","error","debug","queryObservable","graphql","subscriptionReadyCallback","push","subscribe","next","result","data","errors","Array","length","messages","map","message","warn","join","drainBuffer","record","passesPredicateValidation","pushToBuffer","subscriptionError","isRTFError","catchRTFError","subscription","unsubscribe","REALTIME_SUBSCRIPTION_INIT_ERROR","CONNECTION_FAILED","recoverySuggestion","localModel","errorType","getSubscriptionErrorType","process","ProcessName","remoteModel","cause","e","boundFunction","removeBoundFunctionListener","Promise","res","bind","Hub","listen","op","all","then","CONNECTED","addCleaner","keys","dataObservable","dataObserver","stop","close","open","predicates","type","validatePredicate","header","messageErrorTypeMap","RTFError","UnknownField","MaxAttributes","MaxCombinations","RepeatedFieldname","NotGroup","FieldNotInType","_errorMsg","entries","errorMsg","remediationMessage","generateRTFRemediation"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/sync/processors/subscription.ts"],"sourcesContent":["import { InternalAPI } from '@aws-amplify/api/internals';\nimport { Hub, fetchAuthSession, ConsoleLogger, } from '@aws-amplify/core';\nimport { Category, DataStoreAction, BackgroundProcessManager, } from '@aws-amplify/core/internals/utils';\nimport { Observable } from 'rxjs';\nimport { ProcessName, } from '../../types';\nimport { buildSubscriptionGraphQLOperation, getAuthorizationRules, getModelAuthModes, getUserGroupsFromToken, TransformerMutationType, getTokenForCustomAuth, predicateToGraphQLFilter, RTFError, generateRTFRemediation, } from '../utils';\nimport { ModelPredicateCreator } from '../../predicates';\nimport { validatePredicate } from '../../util';\nimport { getSubscriptionErrorType } from './errorMaps';\nimport { CONTROL_MSG as PUBSUB_CONTROL_MSG } from '@aws-amplify/api-graphql';\nconst logger = new ConsoleLogger('DataStore');\nexport var CONTROL_MSG;\n(function (CONTROL_MSG) {\n    CONTROL_MSG[\"CONNECTED\"] = \"CONNECTED\";\n})(CONTROL_MSG || (CONTROL_MSG = {}));\nexport var USER_CREDENTIALS;\n(function (USER_CREDENTIALS) {\n    USER_CREDENTIALS[USER_CREDENTIALS[\"none\"] = 0] = \"none\";\n    USER_CREDENTIALS[USER_CREDENTIALS[\"unauth\"] = 1] = \"unauth\";\n    USER_CREDENTIALS[USER_CREDENTIALS[\"auth\"] = 2] = \"auth\";\n})(USER_CREDENTIALS || (USER_CREDENTIALS = {}));\nclass SubscriptionProcessor {\n    constructor(schema, syncPredicates, amplifyConfig = {}, authModeStrategy, errorHandler, amplifyContext = {\n        InternalAPI,\n    }) {\n        this.schema = schema;\n        this.syncPredicates = syncPredicates;\n        this.amplifyConfig = amplifyConfig;\n        this.authModeStrategy = authModeStrategy;\n        this.errorHandler = errorHandler;\n        this.amplifyContext = amplifyContext;\n        this.typeQuery = new WeakMap();\n        this.buffer = [];\n        this.runningProcesses = new BackgroundProcessManager();\n    }\n    buildSubscription(namespace, model, transformerMutationType, userCredentials, oidcTokenPayload, authMode, filterArg = false) {\n        const { aws_appsync_authenticationType } = this.amplifyConfig;\n        const { isOwner, ownerField, ownerValue } = this.getAuthorizationInfo(model, userCredentials, aws_appsync_authenticationType, oidcTokenPayload, authMode) || {};\n        const [opType, opName, query] = buildSubscriptionGraphQLOperation(namespace, model, transformerMutationType, isOwner, ownerField, filterArg);\n        return { authMode, opType, opName, query, isOwner, ownerField, ownerValue };\n    }\n    getAuthorizationInfo(model, userCredentials, defaultAuthType, oidcTokenPayload, authMode) {\n        const rules = getAuthorizationRules(model);\n        // Return null if user doesn't have proper credentials for private API with IAM auth\n        const iamPrivateAuth = authMode === 'iam' &&\n            rules.find(rule => rule.authStrategy === 'private' && rule.provider === 'iam');\n        if (iamPrivateAuth && userCredentials === USER_CREDENTIALS.unauth) {\n            return null;\n        }\n        // Group auth should take precedence over owner auth, so we are checking\n        // if rule(s) have group authorization as well as if either the Cognito or\n        // OIDC token has a groupClaim. If so, we are returning auth info before\n        // any further owner-based auth checks.\n        const groupAuthRules = rules.filter(rule => rule.authStrategy === 'groups' &&\n            ['userPools', 'oidc'].includes(rule.provider));\n        const validGroup = (authMode === 'oidc' || authMode === 'userPool') &&\n            groupAuthRules.find(groupAuthRule => {\n                // validate token against groupClaim\n                if (oidcTokenPayload) {\n                    const oidcUserGroups = getUserGroupsFromToken(oidcTokenPayload, groupAuthRule);\n                    return [...oidcUserGroups].find(userGroup => {\n                        return groupAuthRule.groups.find(group => group === userGroup);\n                    });\n                }\n            });\n        if (validGroup) {\n            return {\n                authMode,\n                isOwner: false,\n            };\n        }\n        let ownerAuthInfo;\n        if (ownerAuthInfo) {\n            return ownerAuthInfo;\n        }\n        // Owner auth needs additional values to be returned in order to create the subscription with\n        // the correct parameters so we are getting the owner value from the OIDC token via the\n        // identityClaim from the auth rule.\n        const oidcOwnerAuthRules = authMode === 'oidc' || authMode === 'userPool'\n            ? rules.filter(rule => rule.authStrategy === 'owner' &&\n                (rule.provider === 'oidc' || rule.provider === 'userPools'))\n            : [];\n        oidcOwnerAuthRules.forEach(ownerAuthRule => {\n            const ownerValue = oidcTokenPayload[ownerAuthRule.identityClaim];\n            const singleOwner = model.fields[ownerAuthRule.ownerField]?.isArray !== true;\n            const isOwnerArgRequired = singleOwner && !ownerAuthRule.areSubscriptionsPublic;\n            if (ownerValue) {\n                ownerAuthInfo = {\n                    authMode,\n                    isOwner: isOwnerArgRequired,\n                    ownerField: ownerAuthRule.ownerField,\n                    ownerValue: String(ownerValue),\n                };\n            }\n        });\n        if (ownerAuthInfo) {\n            return ownerAuthInfo;\n        }\n        // Fallback: return authMode or default auth type\n        return {\n            authMode: authMode || defaultAuthType,\n            isOwner: false,\n        };\n    }\n    hubQueryCompletionListener(completed, capsule) {\n        const { payload: { event }, } = capsule;\n        if (event === PUBSUB_CONTROL_MSG.SUBSCRIPTION_ACK) {\n            completed();\n        }\n    }\n    start() {\n        this.runningProcesses =\n            this.runningProcesses || new BackgroundProcessManager();\n        const ctlObservable = new Observable(observer => {\n            const promises = [];\n            // Creating subs for each model/operation combo so they can be unsubscribed\n            // independently, since the auth retry behavior is asynchronous.\n            let subscriptions = {};\n            let oidcTokenPayload;\n            let userCredentials = USER_CREDENTIALS.none;\n            this.runningProcesses.add(async () => {\n                try {\n                    // retrieving current AWS Credentials\n                    const credentials = (await fetchAuthSession()).tokens?.accessToken;\n                    userCredentials = credentials\n                        ? USER_CREDENTIALS.auth\n                        : USER_CREDENTIALS.unauth;\n                }\n                catch (err) {\n                    // best effort to get AWS credentials\n                }\n                try {\n                    // retrieving current token info from Cognito UserPools\n                    const session = await fetchAuthSession();\n                    oidcTokenPayload = session.tokens?.idToken?.payload;\n                }\n                catch (err) {\n                    // best effort to get jwt from Cognito\n                }\n                Object.values(this.schema.namespaces).forEach(namespace => {\n                    Object.values(namespace.models)\n                        .filter(({ syncable }) => syncable)\n                        .forEach(modelDefinition => this.runningProcesses.isOpen &&\n                        this.runningProcesses.add(async () => {\n                            const modelAuthModes = await getModelAuthModes({\n                                authModeStrategy: this.authModeStrategy,\n                                defaultAuthMode: this.amplifyConfig.aws_appsync_authenticationType,\n                                modelName: modelDefinition.name,\n                                schema: this.schema,\n                            });\n                            // subscriptions are created only based on the READ auth mode(s)\n                            const readAuthModes = modelAuthModes.READ;\n                            subscriptions = {\n                                ...subscriptions,\n                                [modelDefinition.name]: {\n                                    [TransformerMutationType.CREATE]: [],\n                                    [TransformerMutationType.UPDATE]: [],\n                                    [TransformerMutationType.DELETE]: [],\n                                },\n                            };\n                            const operations = [\n                                TransformerMutationType.CREATE,\n                                TransformerMutationType.UPDATE,\n                                TransformerMutationType.DELETE,\n                            ];\n                            const operationAuthModeAttempts = {\n                                [TransformerMutationType.CREATE]: 0,\n                                [TransformerMutationType.UPDATE]: 0,\n                                [TransformerMutationType.DELETE]: 0,\n                            };\n                            const predicatesGroup = ModelPredicateCreator.getPredicates(this.syncPredicates.get(modelDefinition), false);\n                            const addFilterArg = predicatesGroup !== undefined;\n                            // Retry subscriptions that failed for one of the following reasons:\n                            // 1. unauthorized - retry with next auth mode (if available)\n                            // 2. RTF error - retry without sending filter arg. (filtering will fall back to clientside)\n                            const subscriptionRetry = async (operation, addFilter = addFilterArg) => {\n                                const { opType: transformerMutationType, opName, query, isOwner, ownerField, ownerValue, authMode, } = this.buildSubscription(namespace, modelDefinition, operation, userCredentials, oidcTokenPayload, readAuthModes[operationAuthModeAttempts[operation]], addFilter);\n                                const authToken = await getTokenForCustomAuth(authMode, this.amplifyConfig);\n                                const variables = {};\n                                const customUserAgentDetails = {\n                                    category: Category.DataStore,\n                                    action: DataStoreAction.Subscribe,\n                                };\n                                if (addFilter && predicatesGroup) {\n                                    variables['filter'] =\n                                        predicateToGraphQLFilter(predicatesGroup);\n                                }\n                                if (isOwner) {\n                                    if (!ownerValue) {\n                                        observer.error('Owner field required, sign in is needed in order to perform this operation');\n                                        return;\n                                    }\n                                    variables[ownerField] = ownerValue;\n                                }\n                                logger.debug(`Attempting ${operation} subscription with authMode: ${readAuthModes[operationAuthModeAttempts[operation]]}`);\n                                const queryObservable = this.amplifyContext.InternalAPI.graphql({\n                                    query,\n                                    variables,\n                                    ...{ authMode },\n                                    authToken,\n                                }, undefined, customUserAgentDetails);\n                                let subscriptionReadyCallback;\n                                // TODO: consider onTerminate.then(() => API.cancel(...))\n                                subscriptions[modelDefinition.name][transformerMutationType].push(queryObservable.subscribe({\n                                    next: result => {\n                                        const { data, errors } = result;\n                                        if (Array.isArray(errors) && errors.length > 0) {\n                                            const messages = errors.map(({ message }) => message);\n                                            logger.warn(`Skipping incoming subscription. Messages: ${messages.join('\\n')}`);\n                                            this.drainBuffer();\n                                            return;\n                                        }\n                                        const predicatesGroup = ModelPredicateCreator.getPredicates(this.syncPredicates.get(modelDefinition), false);\n                                        // @ts-ignore\n                                        const { [opName]: record } = data;\n                                        // checking incoming subscription against syncPredicate.\n                                        // once AppSync implements filters on subscriptions, we'll be\n                                        // able to set these when establishing the subscription instead.\n                                        // Until then, we'll need to filter inbound\n                                        if (this.passesPredicateValidation(record, predicatesGroup)) {\n                                            this.pushToBuffer(transformerMutationType, modelDefinition, record);\n                                        }\n                                        this.drainBuffer();\n                                    },\n                                    error: async (subscriptionError) => {\n                                        const { errors: [{ message = '' } = {}], } = ({\n                                            errors: [],\n                                        } = subscriptionError);\n                                        const isRTFError = \n                                        // only attempt catch if a filter variable was added to the subscription query\n                                        addFilter &&\n                                            this.catchRTFError(message, modelDefinition, predicatesGroup);\n                                        // Catch RTF errors\n                                        if (isRTFError) {\n                                            // Unsubscribe and clear subscription array for model/operation\n                                            subscriptions[modelDefinition.name][transformerMutationType].forEach(subscription => subscription.unsubscribe());\n                                            subscriptions[modelDefinition.name][transformerMutationType] = [];\n                                            // retry subscription connection without filter\n                                            subscriptionRetry(operation, false);\n                                            return;\n                                        }\n                                        if (message.includes(PUBSUB_CONTROL_MSG.REALTIME_SUBSCRIPTION_INIT_ERROR) ||\n                                            message.includes(PUBSUB_CONTROL_MSG.CONNECTION_FAILED)) {\n                                            // Unsubscribe and clear subscription array for model/operation\n                                            subscriptions[modelDefinition.name][transformerMutationType].forEach(subscription => subscription.unsubscribe());\n                                            subscriptions[modelDefinition.name][transformerMutationType] = [];\n                                            operationAuthModeAttempts[operation]++;\n                                            if (operationAuthModeAttempts[operation] >=\n                                                readAuthModes.length) {\n                                                // last auth mode retry. Continue with error\n                                                logger.debug(`${operation} subscription failed with authMode: ${readAuthModes[operationAuthModeAttempts[operation] - 1]}`);\n                                            }\n                                            else {\n                                                // retry with different auth mode. Do not trigger\n                                                // observer error or error handler\n                                                logger.debug(`${operation} subscription failed with authMode: ${readAuthModes[operationAuthModeAttempts[operation] - 1]}. Retrying with authMode: ${readAuthModes[operationAuthModeAttempts[operation]]}`);\n                                                subscriptionRetry(operation);\n                                                return;\n                                            }\n                                        }\n                                        logger.warn('subscriptionError', message);\n                                        try {\n                                            await this.errorHandler({\n                                                recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                                                localModel: null,\n                                                message,\n                                                model: modelDefinition.name,\n                                                operation,\n                                                errorType: getSubscriptionErrorType(subscriptionError),\n                                                process: ProcessName.subscribe,\n                                                remoteModel: null,\n                                                cause: subscriptionError,\n                                            });\n                                        }\n                                        catch (e) {\n                                            logger.error('Subscription error handler failed with:', e);\n                                        }\n                                        if (typeof subscriptionReadyCallback === 'function') {\n                                            subscriptionReadyCallback();\n                                        }\n                                        if (message.includes('\"errorType\":\"Unauthorized\"') ||\n                                            message.includes('\"errorType\":\"OperationDisabled\"')) {\n                                            return;\n                                        }\n                                        observer.error(message);\n                                    },\n                                }));\n                                promises.push((async () => {\n                                    let boundFunction;\n                                    let removeBoundFunctionListener;\n                                    await new Promise(res => {\n                                        subscriptionReadyCallback = res;\n                                        boundFunction = this.hubQueryCompletionListener.bind(this, res);\n                                        removeBoundFunctionListener = Hub.listen('api', boundFunction);\n                                    });\n                                    removeBoundFunctionListener();\n                                })());\n                            };\n                            operations.forEach(op => subscriptionRetry(op));\n                        }));\n                });\n                this.runningProcesses.isOpen &&\n                    this.runningProcesses.add(() => Promise.all(promises).then(() => {\n                        observer.next(CONTROL_MSG.CONNECTED);\n                    }));\n            }, 'subscription processor new subscriber');\n            return this.runningProcesses.addCleaner(async () => {\n                Object.keys(subscriptions).forEach(modelName => {\n                    subscriptions[modelName][TransformerMutationType.CREATE].forEach(subscription => subscription.unsubscribe());\n                    subscriptions[modelName][TransformerMutationType.UPDATE].forEach(subscription => subscription.unsubscribe());\n                    subscriptions[modelName][TransformerMutationType.DELETE].forEach(subscription => subscription.unsubscribe());\n                });\n            });\n        });\n        const dataObservable = new Observable(observer => {\n            this.dataObserver = observer;\n            this.drainBuffer();\n            return this.runningProcesses.addCleaner(async () => {\n                this.dataObserver = null;\n            });\n        });\n        return [ctlObservable, dataObservable];\n    }\n    async stop() {\n        await this.runningProcesses.close();\n        await this.runningProcesses.open();\n    }\n    passesPredicateValidation(record, predicatesGroup) {\n        if (!predicatesGroup) {\n            return true;\n        }\n        const { predicates, type } = predicatesGroup;\n        return validatePredicate(record, type, predicates);\n    }\n    pushToBuffer(transformerMutationType, modelDefinition, data) {\n        this.buffer.push([transformerMutationType, modelDefinition, data]);\n    }\n    drainBuffer() {\n        if (this.dataObserver) {\n            this.buffer.forEach(data => this.dataObserver.next(data));\n            this.buffer = [];\n        }\n    }\n    /**\n     * @returns true if the service returned an RTF subscription error\n     * @remarks logs a warning with remediation instructions\n     *\n     */\n    catchRTFError(message, modelDefinition, predicatesGroup) {\n        const header = 'Backend subscriptions filtering error.\\n' +\n            'Subscriptions filtering will be applied clientside.\\n';\n        const messageErrorTypeMap = {\n            'UnknownArgument: Unknown field argument filter': RTFError.UnknownField,\n            'Filters exceed maximum attributes limit': RTFError.MaxAttributes,\n            'Filters combination exceed maximum limit': RTFError.MaxCombinations,\n            'filter uses same fieldName multiple time': RTFError.RepeatedFieldname,\n            \"The variables input contains a field name 'not'\": RTFError.NotGroup,\n            'The variables input contains a field that is not defined for input object type': RTFError.FieldNotInType,\n        };\n        const [_errorMsg, errorType] = Object.entries(messageErrorTypeMap).find(([errorMsg]) => message.includes(errorMsg)) || [];\n        if (errorType !== undefined) {\n            const remediationMessage = generateRTFRemediation(errorType, modelDefinition, predicatesGroup);\n            logger.warn(`${header}\\n${message}\\n${remediationMessage}`);\n            return true;\n        }\n        return false;\n    }\n}\nexport { SubscriptionProcessor };\n"],"mappings":";;;;;;;;;;AAUA,MAAMA,MAAM,GAAG,IAAIC,aAAa,CAAC,WAAW,CAAC;AACnC,IAACC,WAAA;AACX,CAAC,UAAUA,WAAW,EAAE;EACpBA,WAAW,CAAC,WAAW,CAAC,GAAG,WAAW;AAC1C,CAAC,EAAEA,WAAW,KAAKA,WAAW,GAAG,EAAE,CAAC,CAAC;AAC3B,IAACC,gBAAA;AACX,CAAC,UAAUA,gBAAgB,EAAE;EACzBA,gBAAgB,CAACA,gBAAgB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACvDA,gBAAgB,CAACA,gBAAgB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EAC3DA,gBAAgB,CAACA,gBAAgB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;AAC3D,CAAC,EAAEA,gBAAgB,KAAKA,gBAAgB,GAAG,EAAE,CAAC,CAAC;AAC/C,MAAMC,qBAAqB,CAAC;EACxBC,WAAWA,CAACC,MAAM,EAAEC,cAAc,EAAEC,aAAa,GAAG,EAAE,EAAEC,gBAAgB,EAAEC,YAAY,EAAEC,cAAc,GAAG;IACrGC;EACR,CAAK,EAAE;IACC,IAAI,CAACN,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACE,SAAS,GAAG,IAAIC,OAAO,EAAE;IAC9B,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,gBAAgB,GAAG,IAAIC,wBAAwB,EAAE;EAC9D;EACIC,iBAAiBA,CAACC,SAAS,EAAEC,KAAK,EAAEC,uBAAuB,EAAEC,eAAe,EAAEC,gBAAgB,EAAEC,QAAQ,EAAEC,SAAS,GAAG,KAAK,EAAE;IACzH,MAAM;MAAEC;IAA8B,CAAE,GAAG,IAAI,CAAClB,aAAa;IAC7D,MAAM;MAAEmB,OAAO;MAAEC,UAAU;MAAEC;IAAU,CAAE,GAAG,IAAI,CAACC,oBAAoB,CAACV,KAAK,EAAEE,eAAe,EAAEI,8BAA8B,EAAEH,gBAAgB,EAAEC,QAAQ,CAAC,IAAI,EAAE;IAC/J,MAAM,CAACO,MAAM,EAAEC,MAAM,EAAEC,KAAK,CAAC,GAAGC,iCAAiC,CAACf,SAAS,EAAEC,KAAK,EAAEC,uBAAuB,EAAEM,OAAO,EAAEC,UAAU,EAAEH,SAAS,CAAC;IAC5I,OAAO;MAAED,QAAQ;MAAEO,MAAM;MAAEC,MAAM;MAAEC,KAAK;MAAEN,OAAO;MAAEC,UAAU;MAAEC;IAAU,CAAE;EACnF;EACIC,oBAAoBA,CAACV,KAAK,EAAEE,eAAe,EAAEa,eAAe,EAAEZ,gBAAgB,EAAEC,QAAQ,EAAE;IACtF,MAAMY,KAAK,GAAGC,qBAAqB,CAACjB,KAAK,CAAC;IAClD;IACQ,MAAMkB,cAAc,GAAGd,QAAQ,KAAK,KAAK,IACrCY,KAAK,CAACG,IAAI,CAACC,IAAI,IAAIA,IAAI,CAACC,YAAY,KAAK,SAAS,IAAID,IAAI,CAACE,QAAQ,KAAK,KAAK,CAAC;IAClF,IAAIJ,cAAc,IAAIhB,eAAe,KAAKnB,gBAAgB,CAACwC,MAAM,EAAE;MAC/D,OAAO,IAAI;IACvB;IACA;IACA;IACA;IACA;IACQ,MAAMC,cAAc,GAAGR,KAAK,CAACS,MAAM,CAACL,IAAI,IAAIA,IAAI,CAACC,YAAY,KAAK,QAAQ,IACtE,CAAC,WAAW,EAAE,MAAM,CAAC,CAACK,QAAQ,CAACN,IAAI,CAACE,QAAQ,CAAC,CAAC;IAClD,MAAMK,UAAU,GAAG,CAACvB,QAAQ,KAAK,MAAM,IAAIA,QAAQ,KAAK,UAAU,KAC9DoB,cAAc,CAACL,IAAI,CAACS,aAAa,IAAI;MACjD;MACgB,IAAIzB,gBAAgB,EAAE;QAClB,MAAM0B,cAAc,GAAGC,sBAAsB,CAAC3B,gBAAgB,EAAEyB,aAAa,CAAC;QAC9E,OAAO,CAAC,GAAGC,cAAc,CAAC,CAACV,IAAI,CAACY,SAAS,IAAI;UACzC,OAAOH,aAAa,CAACI,MAAM,CAACb,IAAI,CAACc,KAAK,IAAIA,KAAK,KAAKF,SAAS,CAAC;QACtF,CAAqB,CAAC;MACtB;IACA,CAAa,CAAC;IACN,IAAIJ,UAAU,EAAE;MACZ,OAAO;QACHvB,QAAQ;QACRG,OAAO,EAAE;MACzB,CAAa;IACb;IACQ,IAAI2B,aAAa;IACjB,IAAIA,aAAa,EAAE;MACf,OAAOA,aAAa;IAChC;IACA;IACA;IACA;IACQ,MAAMC,kBAAkB,GAAG/B,QAAQ,KAAK,MAAM,IAAIA,QAAQ,KAAK,UAAU,GACnEY,KAAK,CAACS,MAAM,CAACL,IAAI,IAAIA,IAAI,CAACC,YAAY,KAAK,OAAO,KAC/CD,IAAI,CAACE,QAAQ,KAAK,MAAM,IAAIF,IAAI,CAACE,QAAQ,KAAK,WAAW,CAAC,CAAC,GAC9D,EAAE;IACRa,kBAAkB,CAACC,OAAO,CAACC,aAAa,IAAI;MACxC,MAAM5B,UAAU,GAAGN,gBAAgB,CAACkC,aAAa,CAACC,aAAa,CAAC;MAChE,MAAMC,WAAW,GAAGvC,KAAK,CAACwC,MAAM,CAACH,aAAa,CAAC7B,UAAU,CAAC,EAAEiC,OAAO,KAAK,IAAI;MAC5E,MAAMC,kBAAkB,GAAGH,WAAW,IAAI,CAACF,aAAa,CAACM,sBAAsB;MAC/E,IAAIlC,UAAU,EAAE;QACZyB,aAAa,GAAG;UACZ9B,QAAQ;UACRG,OAAO,EAAEmC,kBAAkB;UAC3BlC,UAAU,EAAE6B,aAAa,CAAC7B,UAAU;UACpCC,UAAU,EAAEmC,MAAM,CAACnC,UAAU;QACjD,CAAiB;MACjB;IACA,CAAS,CAAC;IACF,IAAIyB,aAAa,EAAE;MACf,OAAOA,aAAa;IAChC;IACA;IACQ,OAAO;MACH9B,QAAQ,EAAEA,QAAQ,IAAIW,eAAe;MACrCR,OAAO,EAAE;IACrB,CAAS;EACT;EACIsC,0BAA0BA,CAACC,SAAS,EAAEC,OAAO,EAAE;IAC3C,MAAM;MAAEC,OAAO,EAAE;QAAEC;MAAK;IAAE,CAAG,GAAGF,OAAO;IACvC,IAAIE,KAAK,KAAKC,aAAkB,CAACC,gBAAgB,EAAE;MAC/CL,SAAS,EAAE;IACvB;EACA;EACIM,KAAKA,CAAA,EAAG;IACJ,IAAI,CAACxD,gBAAgB,GACjB,IAAI,CAACA,gBAAgB,IAAI,IAAIC,wBAAwB,EAAE;IAC3D,MAAMwD,aAAa,GAAG,IAAIC,UAAU,CAACC,QAAQ,IAAI;MAC7C,MAAMC,QAAQ,GAAG,EAAE;MAC/B;MACA;MACY,IAAIC,aAAa,GAAG,EAAE;MACtB,IAAItD,gBAAgB;MACpB,IAAID,eAAe,GAAGnB,gBAAgB,CAAC2E,IAAI;MAC3C,IAAI,CAAC9D,gBAAgB,CAAC+D,GAAG,CAAC,YAAY;QAClC,IAAI;UACpB;UACoB,MAAMC,WAAW,GAAG,CAAC,MAAMC,gBAAgB,EAAE,EAAEC,MAAM,EAAEC,WAAW;UAClE7D,eAAe,GAAG0D,WAAW,GACvB7E,gBAAgB,CAACiF,IAAI,GACrBjF,gBAAgB,CAACwC,MAAM;QACjD,CAAiB,CACD,OAAO0C,GAAG,EAAE;UAC5B;QAAA;QAEgB,IAAI;UACpB;UACoB,MAAMC,OAAO,GAAG,MAAML,gBAAgB,EAAE;UACxC1D,gBAAgB,GAAG+D,OAAO,CAACJ,MAAM,EAAEK,OAAO,EAAEnB,OAAO;QACvE,CAAiB,CACD,OAAOiB,GAAG,EAAE;UAC5B;QAAA;QAEgBG,MAAM,CAACC,MAAM,CAAC,IAAI,CAACnF,MAAM,CAACoF,UAAU,CAAC,CAAClC,OAAO,CAACrC,SAAS,IAAI;UACvDqE,MAAM,CAACC,MAAM,CAACtE,SAAS,CAACwE,MAAM,CAAC,CAC1B9C,MAAM,CAAC,CAAC;YAAE+C;UAAQ,CAAE,KAAKA,QAAQ,CAAC,CAClCpC,OAAO,CAACqC,eAAe,IAAI,IAAI,CAAC7E,gBAAgB,CAAC8E,MAAM,IACxD,IAAI,CAAC9E,gBAAgB,CAAC+D,GAAG,CAAC,YAAY;YAClC,MAAMgB,cAAc,GAAG,MAAMC,iBAAiB,CAAC;cAC3CvF,gBAAgB,EAAE,IAAI,CAACA,gBAAgB;cACvCwF,eAAe,EAAE,IAAI,CAACzF,aAAa,CAACkB,8BAA8B;cAClEwE,SAAS,EAAEL,eAAe,CAACM,IAAI;cAC/B7F,MAAM,EAAE,IAAI,CAACA;YAC7C,CAA6B,CAAC;YAC9B;YAC4B,MAAM8F,aAAa,GAAGL,cAAc,CAACM,IAAI;YACzCxB,aAAa,GAAG;cACZ,GAAGA,aAAa;cAChB,CAACgB,eAAe,CAACM,IAAI,GAAG;gBACpB,CAACG,uBAAuB,CAACC,MAAM,GAAG,EAAE;gBACpC,CAACD,uBAAuB,CAACE,MAAM,GAAG,EAAE;gBACpC,CAACF,uBAAuB,CAACG,MAAM,GAAG;cACtE;YACA,CAA6B;YACD,MAAMC,UAAU,GAAG,CACfJ,uBAAuB,CAACC,MAAM,EAC9BD,uBAAuB,CAACE,MAAM,EAC9BF,uBAAuB,CAACG,MAAM,CACjC;YACD,MAAME,yBAAyB,GAAG;cAC9B,CAACL,uBAAuB,CAACC,MAAM,GAAG,CAAC;cACnC,CAACD,uBAAuB,CAACE,MAAM,GAAG,CAAC;cACnC,CAACF,uBAAuB,CAACG,MAAM,GAAG;YAClE,CAA6B;YACD,MAAMG,eAAe,GAAGC,qBAAqB,CAACC,aAAa,CAAC,IAAI,CAACvG,cAAc,CAACwG,GAAG,CAAClB,eAAe,CAAC,EAAE,KAAK,CAAC;YAC5G,MAAMmB,YAAY,GAAGJ,eAAe,KAAKK,SAAS;YAC9E;YACA;YACA;YAC4B,MAAMC,iBAAiB,GAAG,MAAAA,CAAOC,SAAS,EAAEC,SAAS,GAAGJ,YAAY,KAAK;cACrE,MAAM;gBAAEjF,MAAM,EAAEV,uBAAuB;gBAAEW,MAAM;gBAAEC,KAAK;gBAAEN,OAAO;gBAAEC,UAAU;gBAAEC,UAAU;gBAAEL;cAAQ,CAAG,GAAG,IAAI,CAACN,iBAAiB,CAACC,SAAS,EAAE0E,eAAe,EAAEsB,SAAS,EAAE7F,eAAe,EAAEC,gBAAgB,EAAE6E,aAAa,CAACO,yBAAyB,CAACQ,SAAS,CAAC,CAAC,EAAEC,SAAS,CAAC;cACvQ,MAAMC,SAAS,GAAG,MAAMC,qBAAqB,CAAC9F,QAAQ,EAAE,IAAI,CAAChB,aAAa,CAAC;cAC3E,MAAM+G,SAAS,GAAG,EAAE;cACpB,MAAMC,sBAAsB,GAAG;gBAC3BC,QAAQ,EAAEC,QAAQ,CAACC,SAAS;gBAC5BC,MAAM,EAAEC,eAAe,CAACC;cAC5D,CAAiC;cACD,IAAIV,SAAS,IAAIR,eAAe,EAAE;gBAC9BW,SAAS,CAAC,QAAQ,CAAC,GACfQ,wBAAwB,CAACnB,eAAe,CAAC;cACjF;cACgC,IAAIjF,OAAO,EAAE;gBACT,IAAI,CAACE,UAAU,EAAE;kBACb8C,QAAQ,CAACqD,KAAK,CAAC,4EAA4E,CAAC;kBAC5F;gBACxC;gBACoCT,SAAS,CAAC3F,UAAU,CAAC,GAAGC,UAAU;cACtE;cACgC7B,MAAM,CAACiI,KAAK,CAAE,cAAad,SAAU,gCAA+Bf,aAAa,CAACO,yBAAyB,CAACQ,SAAS,CAAC,CAAE,EAAC,CAAC;cAC1H,MAAMe,eAAe,GAAG,IAAI,CAACvH,cAAc,CAACC,WAAW,CAACuH,OAAO,CAAC;gBAC5DlG,KAAK;gBACLsF,SAAS;gBACT,GAAG;kBAAE/F;gBAAQ,CAAE;gBACf6F;cACpC,CAAiC,EAAEJ,SAAS,EAAEO,sBAAsB,CAAC;cACrC,IAAIY,yBAAyB;cAC7D;cACgCvD,aAAa,CAACgB,eAAe,CAACM,IAAI,CAAC,CAAC9E,uBAAuB,CAAC,CAACgH,IAAI,CAACH,eAAe,CAACI,SAAS,CAAC;gBACxFC,IAAI,EAAEC,MAAM,IAAI;kBACZ,MAAM;oBAAEC,IAAI;oBAAEC;kBAAM,CAAE,GAAGF,MAAM;kBAC/B,IAAIG,KAAK,CAAC9E,OAAO,CAAC6E,MAAM,CAAC,IAAIA,MAAM,CAACE,MAAM,GAAG,CAAC,EAAE;oBAC5C,MAAMC,QAAQ,GAAGH,MAAM,CAACI,GAAG,CAAC,CAAC;sBAAEC;oBAAO,CAAE,KAAKA,OAAO,CAAC;oBACrD/I,MAAM,CAACgJ,IAAI,CAAE,6CAA4CH,QAAQ,CAACI,IAAI,CAAC,IAAI,CAAE,EAAC,CAAC;oBAC/E,IAAI,CAACC,WAAW,EAAE;oBAClB;kBAC5C;kBACwC,MAAMtC,eAAe,GAAGC,qBAAqB,CAACC,aAAa,CAAC,IAAI,CAACvG,cAAc,CAACwG,GAAG,CAAClB,eAAe,CAAC,EAAE,KAAK,CAAC;kBACpJ;kBACwC,MAAM;oBAAE,CAAC7D,MAAM,GAAGmH;kBAAM,CAAE,GAAGV,IAAI;kBACzE;kBACA;kBACA;kBACA;kBACwC,IAAI,IAAI,CAACW,yBAAyB,CAACD,MAAM,EAAEvC,eAAe,CAAC,EAAE;oBACzD,IAAI,CAACyC,YAAY,CAAChI,uBAAuB,EAAEwE,eAAe,EAAEsD,MAAM,CAAC;kBAC/G;kBACwC,IAAI,CAACD,WAAW,EAAE;gBAC1D,CAAqC;gBACDlB,KAAK,EAAE,MAAOsB,iBAAiB,IAAK;kBAChC,MAAM;oBAAEZ,MAAM,EAAE,CAAC;sBAAEK,OAAO,GAAG;oBAAE,CAAE,GAAG,EAAE;kBAAC,CAAG,GAEtCO,iBAAkB;kBACtB,MAAMC,UAAU;kBACxD;kBACwCnC,SAAS,IACL,IAAI,CAACoC,aAAa,CAACT,OAAO,EAAElD,eAAe,EAAEe,eAAe,CAAC;kBACzG;kBACwC,IAAI2C,UAAU,EAAE;oBACxD;oBAC4C1E,aAAa,CAACgB,eAAe,CAACM,IAAI,CAAC,CAAC9E,uBAAuB,CAAC,CAACmC,OAAO,CAACiG,YAAY,IAAIA,YAAY,CAACC,WAAW,EAAE,CAAC;oBAChH7E,aAAa,CAACgB,eAAe,CAACM,IAAI,CAAC,CAAC9E,uBAAuB,CAAC,GAAG,EAAE;oBAC7G;oBAC4C6F,iBAAiB,CAACC,SAAS,EAAE,KAAK,CAAC;oBACnC;kBAC5C;kBACwC,IAAI4B,OAAO,CAACjG,QAAQ,CAACwB,aAAkB,CAACqF,gCAAgC,CAAC,IACrEZ,OAAO,CAACjG,QAAQ,CAACwB,aAAkB,CAACsF,iBAAiB,CAAC,EAAE;oBACpG;oBAC4C/E,aAAa,CAACgB,eAAe,CAACM,IAAI,CAAC,CAAC9E,uBAAuB,CAAC,CAACmC,OAAO,CAACiG,YAAY,IAAIA,YAAY,CAACC,WAAW,EAAE,CAAC;oBAChH7E,aAAa,CAACgB,eAAe,CAACM,IAAI,CAAC,CAAC9E,uBAAuB,CAAC,GAAG,EAAE;oBACjEsF,yBAAyB,CAACQ,SAAS,CAAC,EAAE;oBACtC,IAAIR,yBAAyB,CAACQ,SAAS,CAAC,IACpCf,aAAa,CAACwC,MAAM,EAAE;sBACtE;sBACgD5I,MAAM,CAACiI,KAAK,CAAE,GAAEd,SAAU,uCAAsCf,aAAa,CAACO,yBAAyB,CAACQ,SAAS,CAAC,GAAG,CAAC,CAAE,EAAC,CAAC;oBAC1K,CAA6C,MACI;sBACjD;sBACA;sBACgDnH,MAAM,CAACiI,KAAK,CAAE,GAAEd,SAAU,uCAAsCf,aAAa,CAACO,yBAAyB,CAACQ,SAAS,CAAC,GAAG,CAAC,CAAE,6BAA4Bf,aAAa,CAACO,yBAAyB,CAACQ,SAAS,CAAC,CAAE,EAAC,CAAC;sBAC1MD,iBAAiB,CAACC,SAAS,CAAC;sBAC5B;oBAChD;kBACA;kBACwCnH,MAAM,CAACgJ,IAAI,CAAC,mBAAmB,EAAED,OAAO,CAAC;kBACzC,IAAI;oBACA,MAAM,IAAI,CAACrI,YAAY,CAAC;sBACpBmJ,kBAAkB,EAAE,qQAAqQ;sBACzRC,UAAU,EAAE,IAAI;sBAChBf,OAAO;sBACP3H,KAAK,EAAEyE,eAAe,CAACM,IAAI;sBAC3BgB,SAAS;sBACT4C,SAAS,EAAEC,wBAAwB,CAACV,iBAAiB,CAAC;sBACtDW,OAAO,EAAEC,WAAW,CAAC5B,SAAS;sBAC9B6B,WAAW,EAAE,IAAI;sBACjBC,KAAK,EAAEd;oBACvD,CAA6C,CAAC;kBAC9C,CAAyC,CACD,OAAOe,CAAC,EAAE;oBACNrK,MAAM,CAACgI,KAAK,CAAC,yCAAyC,EAAEqC,CAAC,CAAC;kBACtG;kBACwC,IAAI,OAAOjC,yBAAyB,KAAK,UAAU,EAAE;oBACjDA,yBAAyB,EAAE;kBACvE;kBACwC,IAAIW,OAAO,CAACjG,QAAQ,CAAC,4BAA4B,CAAC,IAC9CiG,OAAO,CAACjG,QAAQ,CAAC,iCAAiC,CAAC,EAAE;oBACrD;kBAC5C;kBACwC6B,QAAQ,CAACqD,KAAK,CAACe,OAAO,CAAC;gBAC/D;cACA,CAAiC,CAAC,CAAC;cACHnE,QAAQ,CAACyD,IAAI,CAAC,CAAC,YAAY;gBACvB,IAAIiC,aAAa;gBACjB,IAAIC,2BAA2B;gBAC/B,MAAM,IAAIC,OAAO,CAACC,GAAG,IAAI;kBACrBrC,yBAAyB,GAAGqC,GAAG;kBAC/BH,aAAa,GAAG,IAAI,CAACrG,0BAA0B,CAACyG,IAAI,CAAC,IAAI,EAAED,GAAG,CAAC;kBAC/DF,2BAA2B,GAAGI,GAAG,CAACC,MAAM,CAAC,KAAK,EAAEN,aAAa,CAAC;gBACtG,CAAqC,CAAC;gBACFC,2BAA2B,EAAE;cACjE,CAAiC,GAAG,CAAC;YACrC,CAA6B;YACD7D,UAAU,CAAClD,OAAO,CAACqH,EAAE,IAAI3D,iBAAiB,CAAC2D,EAAE,CAAC,CAAC;UAC3E,CAAyB,CAAC,CAAC;QAC3B,CAAiB,CAAC;QACF,IAAI,CAAC7J,gBAAgB,CAAC8E,MAAM,IACxB,IAAI,CAAC9E,gBAAgB,CAAC+D,GAAG,CAAC,MAAMyF,OAAO,CAACM,GAAG,CAAClG,QAAQ,CAAC,CAACmG,IAAI,CAAC,MAAM;UAC7DpG,QAAQ,CAAC4D,IAAI,CAACrI,WAAW,CAAC8K,SAAS,CAAC;QAC5D,CAAqB,CAAC,CAAC;MACvB,CAAa,EAAE,uCAAuC,CAAC;MAC3C,OAAO,IAAI,CAAChK,gBAAgB,CAACiK,UAAU,CAAC,YAAY;QAChDzF,MAAM,CAAC0F,IAAI,CAACrG,aAAa,CAAC,CAACrB,OAAO,CAAC0C,SAAS,IAAI;UAC5CrB,aAAa,CAACqB,SAAS,CAAC,CAACI,uBAAuB,CAACC,MAAM,CAAC,CAAC/C,OAAO,CAACiG,YAAY,IAAIA,YAAY,CAACC,WAAW,EAAE,CAAC;UAC5G7E,aAAa,CAACqB,SAAS,CAAC,CAACI,uBAAuB,CAACE,MAAM,CAAC,CAAChD,OAAO,CAACiG,YAAY,IAAIA,YAAY,CAACC,WAAW,EAAE,CAAC;UAC5G7E,aAAa,CAACqB,SAAS,CAAC,CAACI,uBAAuB,CAACG,MAAM,CAAC,CAACjD,OAAO,CAACiG,YAAY,IAAIA,YAAY,CAACC,WAAW,EAAE,CAAC;QAChI,CAAiB,CAAC;MAClB,CAAa,CAAC;IACd,CAAS,CAAC;IACF,MAAMyB,cAAc,GAAG,IAAIzG,UAAU,CAACC,QAAQ,IAAI;MAC9C,IAAI,CAACyG,YAAY,GAAGzG,QAAQ;MAC5B,IAAI,CAACuE,WAAW,EAAE;MAClB,OAAO,IAAI,CAAClI,gBAAgB,CAACiK,UAAU,CAAC,YAAY;QAChD,IAAI,CAACG,YAAY,GAAG,IAAI;MACxC,CAAa,CAAC;IACd,CAAS,CAAC;IACF,OAAO,CAAC3G,aAAa,EAAE0G,cAAc,CAAC;EAC9C;EACI,MAAME,IAAIA,CAAA,EAAG;IACT,MAAM,IAAI,CAACrK,gBAAgB,CAACsK,KAAK,EAAE;IACnC,MAAM,IAAI,CAACtK,gBAAgB,CAACuK,IAAI,EAAE;EAC1C;EACInC,yBAAyBA,CAACD,MAAM,EAAEvC,eAAe,EAAE;IAC/C,IAAI,CAACA,eAAe,EAAE;MAClB,OAAO,IAAI;IACvB;IACQ,MAAM;MAAE4E,UAAU;MAAEC;IAAI,CAAE,GAAG7E,eAAe;IAC5C,OAAO8E,iBAAiB,CAACvC,MAAM,EAAEsC,IAAI,EAAED,UAAU,CAAC;EAC1D;EACInC,YAAYA,CAAChI,uBAAuB,EAAEwE,eAAe,EAAE4C,IAAI,EAAE;IACzD,IAAI,CAAC1H,MAAM,CAACsH,IAAI,CAAC,CAAChH,uBAAuB,EAAEwE,eAAe,EAAE4C,IAAI,CAAC,CAAC;EAC1E;EACIS,WAAWA,CAAA,EAAG;IACV,IAAI,IAAI,CAACkC,YAAY,EAAE;MACnB,IAAI,CAACrK,MAAM,CAACyC,OAAO,CAACiF,IAAI,IAAI,IAAI,CAAC2C,YAAY,CAAC7C,IAAI,CAACE,IAAI,CAAC,CAAC;MACzD,IAAI,CAAC1H,MAAM,GAAG,EAAE;IAC5B;EACA;EACA;AACA;AACA;AACA;AACA;EACIyI,aAAaA,CAACT,OAAO,EAAElD,eAAe,EAAEe,eAAe,EAAE;IACrD,MAAM+E,MAAM,GAAG,0CAA0C,GACrD,uDAAuD;IAC3D,MAAMC,mBAAmB,GAAG;MACxB,gDAAgD,EAAEC,QAAQ,CAACC,YAAY;MACvE,yCAAyC,EAAED,QAAQ,CAACE,aAAa;MACjE,0CAA0C,EAAEF,QAAQ,CAACG,eAAe;MACpE,0CAA0C,EAAEH,QAAQ,CAACI,iBAAiB;MACtE,iDAAiD,EAAEJ,QAAQ,CAACK,QAAQ;MACpE,gFAAgF,EAAEL,QAAQ,CAACM;IACvG,CAAS;IACD,MAAM,CAACC,SAAS,EAAErC,SAAS,CAAC,GAAGvE,MAAM,CAAC6G,OAAO,CAACT,mBAAmB,CAAC,CAACrJ,IAAI,CAAC,CAAC,CAAC+J,QAAQ,CAAC,KAAKvD,OAAO,CAACjG,QAAQ,CAACwJ,QAAQ,CAAC,CAAC,IAAI,EAAE;IACzH,IAAIvC,SAAS,KAAK9C,SAAS,EAAE;MACzB,MAAMsF,kBAAkB,GAAGC,sBAAsB,CAACzC,SAAS,EAAElE,eAAe,EAAEe,eAAe,CAAC;MAC9F5G,MAAM,CAACgJ,IAAI,CAAE,GAAE2C,MAAO,KAAI5C,OAAQ,KAAIwD,kBAAmB,EAAC,CAAC;MAC3D,OAAO,IAAI;IACvB;IACQ,OAAO,KAAK;EACpB;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}