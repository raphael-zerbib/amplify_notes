{"ast":null,"code":"import { InternalAPI } from '@aws-amplify/api/internals';\nimport { ConsoleLogger, Hub, Cache, Amplify } from '@aws-amplify/core';\nimport { setAutoFreeze, enablePatches, immerable, produce } from 'immer';\nimport { BackgroundProcessManager, amplifyUuid } from '@aws-amplify/core/internals/utils';\nimport { Observable, filter } from 'rxjs';\nimport { defaultAuthStrategy } from '../authModeStrategies/defaultAuthStrategy.mjs';\nimport { multiAuthStrategy } from '../authModeStrategies/multiAuthStrategy.mjs';\nimport { ModelPredicateCreator, isPredicatesAll } from '../predicates/index.mjs';\nimport { ExclusiveStorage } from '../storage/storage.mjs';\nimport { ModelRelationship } from '../storage/relationship.mjs';\nimport { SyncEngine, ControlMessage } from '../sync/index.mjs';\nimport { isIdentifierObject, AuthModeStrategyType, isNonModelFieldType, isModelFieldType, isSchemaModelWithAttributes, isGraphQLScalarType, GraphQLScalarType } from '../types.mjs';\nimport { isNode } from './utils.mjs';\nimport { monotonicUlidFactory, USER, establishRelationAndKeys, isModelConstructor, extractPrimaryKeyFieldNames, registerNonModelClass, errorMessages, inMemoryPagination, extractPrimaryKeysAndValues, DeferredCallbackResolver, isIdManaged, isIdOptionallyManaged, mergePatches, STORAGE, SYNC, DATASTORE, sortCompareFunction, getTimestampFields, isNullOrUndefined } from '../util.mjs';\nimport { recursivePredicateFor, internals, predicateFor } from '../predicates/next.mjs';\nimport { getIdentifierValue } from '../sync/utils.mjs';\nimport { ModelSortPredicateCreator } from '../predicates/sort.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nsetAutoFreeze(true);\nenablePatches();\nconst logger = new ConsoleLogger('DataStore');\nconst ulid = monotonicUlidFactory(Date.now());\nconst SETTING_SCHEMA_VERSION = 'schemaVersion';\nlet schema;\nconst modelNamespaceMap = new WeakMap();\n/**\n * Stores data for crafting the correct update mutation input for a model.\n *\n * - `Patch[]` - array of changed fields and metadata.\n * - `PersistentModel` - the source model, used for diffing object-type fields.\n */\nconst modelPatchesMap = new WeakMap();\nconst getModelDefinition = modelConstructor => {\n  const namespace = modelNamespaceMap.get(modelConstructor);\n  const definition = namespace ? schema.namespaces[namespace].models[modelConstructor.name] : undefined;\n  return definition;\n};\n/**\n * Determines whether the given object is a Model Constructor that DataStore can\n * safely use to construct objects and discover related metadata.\n *\n * @param obj The object to test.\n */\nconst isValidModelConstructor = obj => {\n  return isModelConstructor(obj) && modelNamespaceMap.has(obj);\n};\nconst namespaceResolver = modelConstructor => {\n  const resolver = modelNamespaceMap.get(modelConstructor);\n  if (!resolver) {\n    throw new Error(\"Namespace Resolver for '\".concat(modelConstructor.name, \"' not found! This is probably a bug in '@amplify-js/datastore'.\"));\n  }\n  return resolver;\n};\n/**\n * Creates a predicate without any conditions that can be passed to customer\n * code to have conditions added to it.\n *\n * For example, in this query:\n *\n * ```ts\n * await DataStore.query(\n * \tModel,\n * \titem => item.field.eq('value')\n * );\n * ```\n *\n * `buildSeedPredicate(Model)` is used to create `item`, which is passed to the\n * predicate function, which in turn uses that \"seed\" predicate (`item`) to build\n * a predicate tree.\n *\n * @param modelConstructor The model the predicate will query.\n */\nconst buildSeedPredicate = modelConstructor => {\n  if (!modelConstructor) throw new Error('Missing modelConstructor');\n  const modelSchema = getModelDefinition(modelConstructor);\n  if (!modelSchema) throw new Error('Missing modelSchema');\n  const pks = extractPrimaryKeyFieldNames(modelSchema);\n  if (!pks) throw new Error('Could not determine PK');\n  return recursivePredicateFor({\n    builder: modelConstructor,\n    schema: modelSchema,\n    pkField: pks\n  });\n};\n// exporting syncClasses for testing outbox.test.ts\nlet syncClasses;\nlet userClasses;\nlet dataStoreClasses;\nlet storageClasses;\n/**\n * Maps a model to its related models for memoization/immutability.\n */\nconst modelInstanceAssociationsMap = new WeakMap();\n/**\n * Describes whether and to what a model is attached for lazy loading purposes.\n */\nvar ModelAttachment;\n(function (ModelAttachment) {\n  /**\n   * Model doesn't lazy load from any data source.\n   *\n   * Related entity properties provided at instantiation are returned\n   * via the respective lazy interfaces when their properties are invoked.\n   */\n  ModelAttachment[\"Detached\"] = \"Detached\";\n  /**\n   * Model lazy loads from the global DataStore.\n   */\n  ModelAttachment[\"DataStore\"] = \"DataStore\";\n  /**\n   * Demonstrative. Not yet implemented.\n   */\n  ModelAttachment[\"API\"] = \"API\";\n})(ModelAttachment || (ModelAttachment = {}));\n/**\n * Tells us which data source a model is attached to (lazy loads from).\n *\n * If `Deatched`, the model's lazy properties will only ever return properties\n * from memory provided at construction time.\n */\nconst attachedModelInstances = new WeakMap();\n/**\n * Registers a model instance against a data source (DataStore, API, or\n * Detached/None).\n *\n * The API option is demonstrative. Lazy loading against API is not yet\n * implemented.\n *\n * @param result A model instance or array of instances\n * @param attachment A ModelAttachment data source\n * @returns passes the `result` back through after attachment\n */\nfunction attached(result, attachment) {\n  if (Array.isArray(result)) {\n    result.map(record => attached(record, attachment));\n  } else {\n    result && attachedModelInstances.set(result, attachment);\n  }\n  return result;\n}\n/**\n * Determines what source a model instance should lazy load from.\n *\n * If the instace was never explicitly registered, it is detached by default.\n *\n * @param instance A model instance\n */\nconst getAttachment = instance => {\n  return attachedModelInstances.has(instance) ? attachedModelInstances.get(instance) : ModelAttachment.Detached;\n};\nconst initSchema = userSchema => {\n  if (schema !== undefined) {\n    console.warn('The schema has already been initialized');\n    return userClasses;\n  }\n  logger.log('validating schema', {\n    schema: userSchema\n  });\n  checkSchemaCodegenVersion(userSchema.codegenVersion);\n  const internalUserNamespace = {\n    name: USER,\n    ...userSchema\n  };\n  logger.log('DataStore', 'Init models');\n  userClasses = createTypeClasses(internalUserNamespace);\n  logger.log('DataStore', 'Models initialized');\n  const dataStoreNamespace = getNamespace();\n  const storageNamespace = ExclusiveStorage.getNamespace();\n  const syncNamespace = SyncEngine.getNamespace();\n  dataStoreClasses = createTypeClasses(dataStoreNamespace);\n  storageClasses = createTypeClasses(storageNamespace);\n  syncClasses = createTypeClasses(syncNamespace);\n  schema = {\n    namespaces: {\n      [dataStoreNamespace.name]: dataStoreNamespace,\n      [internalUserNamespace.name]: internalUserNamespace,\n      [storageNamespace.name]: storageNamespace,\n      [syncNamespace.name]: syncNamespace\n    },\n    version: userSchema.version,\n    codegenVersion: userSchema.codegenVersion\n  };\n  Object.keys(schema.namespaces).forEach(namespace => {\n    const [relations, keys] = establishRelationAndKeys(schema.namespaces[namespace]);\n    schema.namespaces[namespace].relationships = relations;\n    schema.namespaces[namespace].keys = keys;\n    const modelAssociations = new Map();\n    Object.values(schema.namespaces[namespace].models).forEach(model => {\n      const connectedModels = [];\n      Object.values(model.fields).filter(field => field.association && field.association.connectionType === 'BELONGS_TO' && field.type.model !== model.name).forEach(field => connectedModels.push(field.type.model));\n      modelAssociations.set(model.name, connectedModels);\n      // Precompute model info (such as pk fields) so that downstream schema consumers\n      // (such as predicate builders) don't have to reach back into \"DataStore\" space\n      // to go looking for it.\n      Object.values(model.fields).forEach(field => {\n        const relatedModel = userClasses[field.type.model];\n        if (isModelConstructor(relatedModel)) {\n          Object.defineProperty(field.type, 'modelConstructor', {\n            get: () => {\n              const relatedModelDefinition = getModelDefinition(relatedModel);\n              if (!relatedModelDefinition) throw new Error(\"Could not find model definition for \".concat(relatedModel.name));\n              return {\n                builder: relatedModel,\n                schema: relatedModelDefinition,\n                pkField: extractPrimaryKeyFieldNames(relatedModelDefinition)\n              };\n            }\n          });\n        }\n      });\n      // compatibility with legacy/pre-PK codegen for lazy loading to inject\n      // index fields into the model definition.\n      // definition.cloudFields = { ...definition.fields };\n      const indexes = schema.namespaces[namespace].relationships[model.name].indexes;\n      const indexFields = new Set();\n      for (const index of indexes) {\n        for (const indexField of index[1]) {\n          indexFields.add(indexField);\n        }\n      }\n      model.allFields = {\n        ...Object.fromEntries([...indexFields.values()].map(name => [name, {\n          name,\n          type: 'ID',\n          isArray: false\n        }])),\n        ...model.fields\n      };\n    });\n    const result = new Map();\n    let count = 1000;\n    while (count > 0) {\n      if (modelAssociations.size === 0) {\n        break;\n      }\n      count--;\n      if (count === 0) {\n        throw new Error('Models are not topologically sortable. Please verify your schema.');\n      }\n      for (const modelName of Array.from(modelAssociations.keys())) {\n        const parents = modelAssociations.get(modelName);\n        if (parents !== null && parents !== void 0 && parents.every(x => result.has(x))) {\n          result.set(modelName, parents);\n        }\n      }\n      Array.from(result.keys()).forEach(x => modelAssociations.delete(x));\n    }\n    schema.namespaces[namespace].modelTopologicalOrdering = result;\n  });\n  return userClasses;\n};\n/**\n * Throws an exception if the schema has *not* been initialized\n * by `initSchema()`.\n *\n * **To be called before trying to access schema.**\n *\n * Currently this only needs to be called in `start()` and `clear()` because\n * all other functions will call start first.\n */\nconst checkSchemaInitialized = () => {\n  if (schema === undefined) {\n    const message = 'Schema is not initialized. DataStore will not function as expected. This could happen if you have multiple versions of DataStore installed. Please see https://docs.amplify.aws/lib/troubleshooting/upgrading/q/platform/js/#check-for-duplicate-versions';\n    logger.error(message);\n    throw new Error(message);\n  }\n};\n/**\n * Throws an exception if the schema is using a codegen version that is not supported.\n *\n * Set the supported version by setting majorVersion and minorVersion\n * This functions similar to ^ version range.\n * The tested codegenVersion major version must exactly match the set majorVersion\n * The tested codegenVersion minor version must be gt or equal to the set minorVersion\n * Example: For a min supported version of 5.4.0 set majorVersion = 5 and minorVersion = 4\n *\n * This regex will not work when setting a supported range with minor version\n * of 2 or more digits.\n * i.e. minorVersion = 10 will not work\n * The regex will work for testing a codegenVersion with multi digit minor\n * versions as long as the minimum minorVersion is single digit.\n * i.e. codegenVersion = 5.30.1, majorVersion = 5, minorVersion = 4 PASSES\n *\n * @param codegenVersion schema codegenVersion\n */\nconst checkSchemaCodegenVersion = codegenVersion => {\n  const majorVersion = 3;\n  const minorVersion = 2;\n  let isValid = false;\n  try {\n    const versionParts = codegenVersion.split('.');\n    const [major, minor, patch, patchrevision] = versionParts;\n    isValid = Number(major) === majorVersion && Number(minor) >= minorVersion;\n  } catch (err) {\n    console.log(\"Error parsing codegen version: \".concat(codegenVersion, \"\\n\").concat(err));\n  }\n  if (!isValid) {\n    const message = \"Models were generated with an unsupported version of codegen. Codegen artifacts are from \".concat(codegenVersion || 'an unknown version', \", whereas ^\").concat(majorVersion, \".\").concat(minorVersion, \".0 is required. \") + \"Update to the latest CLI and run 'amplify codegen models'.\";\n    logger.error(message);\n    throw new Error(message);\n  }\n};\nconst createTypeClasses = namespace => {\n  const classes = {};\n  Object.entries(namespace.models).forEach(_ref => {\n    let [modelName, modelDefinition] = _ref;\n    const clazz = createModelClass(modelDefinition);\n    classes[modelName] = clazz;\n    modelNamespaceMap.set(clazz, namespace.name);\n  });\n  Object.entries(namespace.nonModels || {}).forEach(_ref2 => {\n    let [typeName, typeDefinition] = _ref2;\n    const clazz = createNonModelClass(typeDefinition);\n    classes[typeName] = clazz;\n  });\n  return classes;\n};\n/**\n * Collection of instantiated models to allow storage of metadata apart from\n * the model visible to the consuming app -- in case the app doesn't have\n * metadata fields (_version, _deleted, etc.) exposed on the model itself.\n */\nconst instancesMetadata = new WeakSet();\nfunction modelInstanceCreator(modelConstructor, init) {\n  instancesMetadata.add(init);\n  return new modelConstructor(init);\n}\nconst validateModelFields = modelDefinition => (k, v) => {\n  const fieldDefinition = modelDefinition.fields[k];\n  if (fieldDefinition !== undefined) {\n    const {\n      type,\n      isRequired,\n      isArrayNullable,\n      name,\n      isArray\n    } = fieldDefinition;\n    const timestamps = isSchemaModelWithAttributes(modelDefinition) ? getTimestampFields(modelDefinition) : {};\n    const isTimestampField = !!timestamps[name];\n    if ((!isArray && isRequired || isArray && !isArrayNullable) && !isTimestampField && (v === null || v === undefined)) {\n      throw new Error(\"Field \".concat(name, \" is required\"));\n    }\n    if (isSchemaModelWithAttributes(modelDefinition) && !isIdManaged(modelDefinition)) {\n      const keys = extractPrimaryKeyFieldNames(modelDefinition);\n      if (keys.includes(k) && v === '') {\n        logger.error(errorMessages.idEmptyString, {\n          k,\n          value: v\n        });\n        throw new Error(errorMessages.idEmptyString);\n      }\n    }\n    if (isGraphQLScalarType(type)) {\n      const jsType = GraphQLScalarType.getJSType(type);\n      const validateScalar = GraphQLScalarType.getValidationFunction(type);\n      if (type === 'AWSJSON') {\n        if (typeof v === jsType) {\n          return;\n        }\n        if (typeof v === 'string') {\n          try {\n            JSON.parse(v);\n            return;\n          } catch (error) {\n            throw new Error(\"Field \".concat(name, \" is an invalid JSON object. \").concat(v));\n          }\n        }\n      }\n      if (isArray) {\n        let errorTypeText = jsType;\n        if (!isRequired) {\n          errorTypeText = \"\".concat(jsType, \" | null | undefined\");\n        }\n        if (!Array.isArray(v) && !isArrayNullable) {\n          throw new Error(\"Field \".concat(name, \" should be of type [\").concat(errorTypeText, \"], \").concat(typeof v, \" received. \").concat(v));\n        }\n        if (!isNullOrUndefined(v) && v.some(e => isNullOrUndefined(e) ? isRequired : typeof e !== jsType)) {\n          const elemTypes = v.map(e => e === null ? 'null' : typeof e).join(',');\n          throw new Error(\"All elements in the \".concat(name, \" array should be of type \").concat(errorTypeText, \", [\").concat(elemTypes, \"] received. \").concat(v));\n        }\n        if (validateScalar && !isNullOrUndefined(v)) {\n          const validationStatus = v.map(e => {\n            if (!isNullOrUndefined(e)) {\n              return validateScalar(e);\n            } else if (isNullOrUndefined(e) && !isRequired) {\n              return true;\n            } else {\n              return false;\n            }\n          });\n          if (!validationStatus.every(s => s)) {\n            throw new Error(\"All elements in the \".concat(name, \" array should be of type \").concat(type, \", validation failed for one or more elements. \").concat(v));\n          }\n        }\n      } else if (!isRequired && v === undefined) {\n        return;\n      } else if (typeof v !== jsType && v !== null) {\n        throw new Error(\"Field \".concat(name, \" should be of type \").concat(jsType, \", \").concat(typeof v, \" received. \").concat(v));\n      } else if (!isNullOrUndefined(v) && validateScalar && !validateScalar(v) // TODO: why never, TS ... why ...\n      ) {\n        throw new Error(\"Field \".concat(name, \" should be of type \").concat(type, \", validation failed. \").concat(v));\n      }\n    } else if (isNonModelFieldType(type)) {\n      // do not check non model fields if undefined or null\n      if (!isNullOrUndefined(v)) {\n        const subNonModelDefinition = schema.namespaces.user.nonModels[type.nonModel];\n        const modelValidator = validateModelFields(subNonModelDefinition);\n        if (isArray) {\n          let errorTypeText = type.nonModel;\n          if (!isRequired) {\n            errorTypeText = \"\".concat(type.nonModel, \" | null | undefined\");\n          }\n          if (!Array.isArray(v)) {\n            throw new Error(\"Field \".concat(name, \" should be of type [\").concat(errorTypeText, \"], \").concat(typeof v, \" received. \").concat(v));\n          }\n          v.forEach(item => {\n            if (isNullOrUndefined(item) && isRequired || typeof item !== 'object' && typeof item !== 'undefined') {\n              throw new Error(\"All elements in the \".concat(name, \" array should be of type \").concat(type.nonModel, \", [\").concat(typeof item, \"] received. \").concat(item));\n            }\n            if (!isNullOrUndefined(item)) {\n              Object.keys(subNonModelDefinition.fields).forEach(subKey => {\n                modelValidator(subKey, item[subKey]);\n              });\n            }\n          });\n        } else {\n          if (typeof v !== 'object') {\n            throw new Error(\"Field \".concat(name, \" should be of type \").concat(type.nonModel, \", \").concat(typeof v, \" recieved. \").concat(v));\n          }\n          Object.keys(subNonModelDefinition.fields).forEach(subKey => {\n            modelValidator(subKey, v[subKey]);\n          });\n        }\n      }\n    }\n  }\n};\nconst castInstanceType = (modelDefinition, k, v) => {\n  const {\n    isArray,\n    type\n  } = modelDefinition.fields[k] || {};\n  // attempt to parse stringified JSON\n  if (typeof v === 'string' && (isArray || type === 'AWSJSON' || isNonModelFieldType(type) || isModelFieldType(type))) {\n    try {\n      return JSON.parse(v);\n    } catch {\n      // if JSON is invalid, don't throw and let modelValidator handle it\n    }\n  }\n  // cast from numeric representation of boolean to JS boolean\n  if (typeof v === 'number' && type === 'Boolean') {\n    return Boolean(v);\n  }\n  return v;\n};\n/**\n * Records the patches (as if against an empty object) used to initialize\n * an instance of a Model. This can be used for determining which fields to\n * send to the cloud durnig a CREATE mutation.\n */\nconst initPatches = new WeakMap();\n/**\n * Attempts to apply type-aware, casted field values from a given `init`\n * object to the given `draft`.\n *\n * @param init The initialization object to extract field values from.\n * @param modelDefinition The definition describing the target object shape.\n * @param draft The draft to apply field values to.\n */\nconst initializeInstance = (init, modelDefinition, draft) => {\n  const modelValidator = validateModelFields(modelDefinition);\n  Object.entries(init).forEach(_ref3 => {\n    let [k, v] = _ref3;\n    const parsedValue = castInstanceType(modelDefinition, k, v);\n    modelValidator(k, parsedValue);\n    draft[k] = parsedValue;\n  });\n};\n/**\n * Updates a draft to standardize its customer-defined fields so that they are\n * consistent with the data as it would look after having been synchronized from\n * Cloud storage.\n *\n * The exceptions to this are:\n *\n * 1. Non-schema/Internal [sync] metadata fields.\n * 2. Cloud-managed fields, which are `null` until set by cloud storage.\n *\n * This function should be expanded if/when deviations between canonical Cloud\n * storage data and locally managed data are found. For now, the known areas\n * that require normalization are:\n *\n * 1. Ensuring all non-metadata fields are *defined*. (I.e., turn `undefined` -> `null`.)\n *\n * @param modelDefinition Definition for the draft. Used to discover all fields.\n * @param draft The instance draft to apply normalizations to.\n */\nconst normalize = (modelDefinition, draft) => {\n  for (const k of Object.keys(modelDefinition.fields)) {\n    if (draft[k] === undefined) draft[k] = null;\n  }\n};\nconst createModelClass = modelDefinition => {\n  const clazz = class Model {\n    constructor(init) {\n      // we create a base instance first so we can distinguish which fields were explicitly\n      // set by customer code versus those set by normalization. only those fields\n      // which are explicitly set by customers should be part of create mutations.\n      let patches = [];\n      const baseInstance = produce(this, draft => {\n        initializeInstance(init, modelDefinition, draft);\n        // model is initialized inside a DataStore component (e.g. by Sync Engine, Storage Engine, etc.)\n        const isInternallyInitialized = instancesMetadata.has(init);\n        const modelInstanceMetadata = isInternallyInitialized ? init : {};\n        const {\n          id: _id\n        } = modelInstanceMetadata;\n        if (isIdManaged(modelDefinition)) {\n          const isInternalModel = _id !== null && _id !== undefined;\n          const id = isInternalModel ? _id : modelDefinition.syncable ? amplifyUuid() : ulid();\n          draft.id = id;\n        } else if (isIdOptionallyManaged(modelDefinition)) {\n          // only auto-populate if the id was not provided\n          draft.id = draft.id || amplifyUuid();\n        }\n        if (!isInternallyInitialized) {\n          checkReadOnlyPropertyOnCreate(draft, modelDefinition);\n        }\n        const {\n          _version,\n          _lastChangedAt,\n          _deleted\n        } = modelInstanceMetadata;\n        if (modelDefinition.syncable) {\n          draft._version = _version;\n          draft._lastChangedAt = _lastChangedAt;\n          draft._deleted = _deleted;\n        }\n      }, p => patches = p);\n      // now that we have a list of patches that encapsulate the explicit, customer-provided\n      // fields, we can normalize. patches from normalization are ignored, because the changes\n      // are only create to provide a consistent view of the data for fields pre/post sync\n      // where possible. (not all fields can be normalized pre-sync, because they're generally\n      // \"cloud managed\" fields, like createdAt and updatedAt.)\n      const normalized = produce(baseInstance, draft => normalize(modelDefinition, draft));\n      initPatches.set(normalized, patches);\n      return normalized;\n    }\n    static copyOf(source, fn) {\n      const modelConstructor = Object.getPrototypeOf(source || {}).constructor;\n      if (!isValidModelConstructor(modelConstructor)) {\n        const msg = 'The source object is not a valid model';\n        logger.error(msg, {\n          source\n        });\n        throw new Error(msg);\n      }\n      let patches = [];\n      const model = produce(source, draft => {\n        fn(draft);\n        const keyNames = extractPrimaryKeyFieldNames(modelDefinition);\n        // Keys are immutable\n        keyNames.forEach(key => {\n          if (draft[key] !== source[key]) {\n            logger.warn(\"copyOf() does not update PK fields. The '\".concat(key, \"' update is being ignored.\"), {\n              source\n            });\n          }\n          draft[key] = source[key];\n        });\n        const modelValidator = validateModelFields(modelDefinition);\n        Object.entries(draft).forEach(_ref4 => {\n          let [k, v] = _ref4;\n          const parsedValue = castInstanceType(modelDefinition, k, v);\n          modelValidator(k, parsedValue);\n        });\n        normalize(modelDefinition, draft);\n      }, p => patches = p);\n      const hasExistingPatches = modelPatchesMap.has(source);\n      if (patches.length || hasExistingPatches) {\n        if (hasExistingPatches) {\n          const [existingPatches, existingSource] = modelPatchesMap.get(source);\n          const mergedPatches = mergePatches(existingSource, existingPatches, patches);\n          modelPatchesMap.set(model, [mergedPatches, existingSource]);\n          checkReadOnlyPropertyOnUpdate(mergedPatches, modelDefinition);\n        } else {\n          modelPatchesMap.set(model, [patches, source]);\n          checkReadOnlyPropertyOnUpdate(patches, modelDefinition);\n        }\n      } else {\n        // always register patches when performing a copyOf, even if the\n        // patches list is empty. this allows `save()` to recognize when an\n        // instance is the result of a `copyOf()`. without more significant\n        // refactoring, this is the only way for `save()` to know which\n        // diffs (patches) are relevant for `storage` to use in building\n        // the list of \"changed\" fields for mutations.\n        modelPatchesMap.set(model, [[], source]);\n      }\n      return attached(model, ModelAttachment.DataStore);\n    }\n    // \"private\" method (that's hidden via `Setting`) for `withSSRContext` to use\n    // to gain access to `modelInstanceCreator` and `clazz` for persisting IDs from server to client.\n    static fromJSON(json) {\n      if (Array.isArray(json)) {\n        return json.map(init => this.fromJSON(init));\n      }\n      const instance = modelInstanceCreator(clazz, json);\n      const modelValidator = validateModelFields(modelDefinition);\n      Object.entries(instance).forEach(_ref5 => {\n        let [k, v] = _ref5;\n        modelValidator(k, v);\n      });\n      return attached(instance, ModelAttachment.DataStore);\n    }\n  };\n  clazz[immerable] = true;\n  Object.defineProperty(clazz, 'name', {\n    value: modelDefinition.name\n  });\n  // Add getters/setters for relationship fields.\n  //  getter - for lazy loading\n  //  setter - for FK management\n  const allModelRelationships = ModelRelationship.allFrom({\n    builder: clazz,\n    schema: modelDefinition,\n    pkField: extractPrimaryKeyFieldNames(modelDefinition)\n  });\n  for (const relationship of allModelRelationships) {\n    const field = relationship.field;\n    Object.defineProperty(clazz.prototype, modelDefinition.fields[field].name, {\n      set(model) {\n        if (!(typeof model === 'object' || typeof model === 'undefined')) return;\n        // if model is undefined or null, the connection should be removed\n        if (model) {\n          // Avoid validation error when processing AppSync response with nested\n          // selection set. Nested entitites lack version field and can not be validated\n          // TODO: explore a more reliable method to solve this\n          if (model.hasOwnProperty('_version')) {\n            const modelConstructor = Object.getPrototypeOf(model || {}).constructor;\n            if (!isValidModelConstructor(modelConstructor)) {\n              const msg = \"Value passed to \".concat(modelDefinition.name, \".\").concat(field, \" is not a valid instance of a model\");\n              logger.error(msg, {\n                model\n              });\n              throw new Error(msg);\n            }\n            if (modelConstructor.name.toLowerCase() !== relationship.remoteModelConstructor.name.toLowerCase()) {\n              const msg = \"Value passed to \".concat(modelDefinition.name, \".\").concat(field, \" is not an instance of \").concat(relationship.remoteModelConstructor.name);\n              logger.error(msg, {\n                model\n              });\n              throw new Error(msg);\n            }\n          }\n        }\n        // if the relationship can be managed automagically, set the FK's\n        if (relationship.isComplete) {\n          for (let i = 0; i < relationship.localJoinFields.length; i++) {\n            this[relationship.localJoinFields[i]] = model === null || model === void 0 ? void 0 : model[relationship.remoteJoinFields[i]];\n          }\n          const instanceMemos = modelInstanceAssociationsMap.has(this) ? modelInstanceAssociationsMap.get(this) : modelInstanceAssociationsMap.set(this, {}).get(this);\n          instanceMemos[field] = model || undefined;\n        }\n      },\n      get() {\n        /**\n         * Bucket for holding related models instances specific to `this` instance.\n         */\n        const instanceMemos = modelInstanceAssociationsMap.has(this) ? modelInstanceAssociationsMap.get(this) : modelInstanceAssociationsMap.set(this, {}).get(this);\n        // if the memos already has a result for this field, we'll use it.\n        // there is no \"cache\" invalidation of any kind; memos are permanent to\n        // keep an immutable perception of the instance.\n        if (!instanceMemos.hasOwnProperty(field)) {\n          // before we populate the memo, we need to know where to look for relatives.\n          // today, this only supports DataStore. Models aren't managed elsewhere in Amplify.\n          if (getAttachment(this) === ModelAttachment.DataStore) {\n            // when we fetch the results using a query constructed under the guidance\n            // of the relationship metadata, we DO NOT AWAIT resolution. we want to\n            // drop the promise into the memo's synchronously, eliminating the chance\n            // for a race.\n            const resultPromise = instance.query(relationship.remoteModelConstructor, base => base.and(q => {\n              return relationship.remoteJoinFields.map((field, index) => {\n                // TODO: anything we can use instead of `any` here?\n                return q[field].eq(this[relationship.localJoinFields[index]]);\n              });\n            }));\n            // results in hand, how we return them to the caller depends on the relationship type.\n            if (relationship.type === 'HAS_MANY') {\n              // collections should support async iteration, even though we don't\n              // leverage it fully [yet].\n              instanceMemos[field] = new AsyncCollection(resultPromise);\n            } else {\n              // non-collections should only ever return 1 value *or nothing*.\n              // if we have more than 1 record, something's amiss. it's not our job\n              // pick a result for the customer. it's our job to say \"something's wrong.\"\n              instanceMemos[field] = resultPromise.then(rows => {\n                if (rows.length > 1) {\n                  // should never happen for a HAS_ONE or BELONGS_TO.\n                  const err = new Error(\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tData integrity error.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tToo many records found for a HAS_ONE/BELONGS_TO field '\".concat(modelDefinition.name, \".\").concat(field, \"'\\n\\t\\t\\t\\t\\t\\t\\t\\t\"));\n                  console.error(err);\n                  throw err;\n                } else {\n                  return rows[0];\n                }\n              });\n            }\n          } else if (getAttachment(this) === ModelAttachment.API) {\n            throw new Error('Lazy loading from API is not yet supported!');\n          } else {\n            if (relationship.type === 'HAS_MANY') {\n              return new AsyncCollection([]);\n            } else {\n              return Promise.resolve(undefined);\n            }\n          }\n        }\n        return instanceMemos[field];\n      }\n    });\n  }\n  return clazz;\n};\n/**\n * An eventually loaded related model instance.\n */\nclass AsyncItem extends Promise {}\n/**\n * A collection of related model instances.\n *\n * This collection can be async-iterated or turned directly into an array using `toArray()`.\n */\nclass AsyncCollection {\n  constructor(values) {\n    this.values = values;\n  }\n  /**\n   * Facilitates async iteration.\n   *\n   * ```ts\n   * for await (const item of collection) {\n   *   handle(item)\n   * }\n   * ```\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\n   */\n  [Symbol.asyncIterator]() {\n    let values;\n    let index = 0;\n    return {\n      next: async () => {\n        if (!values) values = await this.values;\n        if (index < values.length) {\n          const result = {\n            value: values[index],\n            done: false\n          };\n          index++;\n          return result;\n        }\n        return {\n          value: null,\n          done: true\n        };\n      }\n    };\n  }\n  /**\n   * Turns the collection into an array, up to the amount specified in `max` param.\n   *\n   * ```ts\n   * const all = await collection.toArray();\n   * const first100 = await collection.toArray({max: 100});\n   * ```\n   */\n  async toArray() {\n    let {\n      max = Number.MAX_SAFE_INTEGER\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const output = [];\n    let i = 0;\n    for await (const element of this) {\n      if (i < max) {\n        output.push(element);\n        i++;\n      } else {\n        break;\n      }\n    }\n    return output;\n  }\n}\nconst checkReadOnlyPropertyOnCreate = (draft, modelDefinition) => {\n  const modelKeys = Object.keys(draft);\n  const {\n    fields\n  } = modelDefinition;\n  modelKeys.forEach(key => {\n    if (fields[key] && fields[key].isReadOnly) {\n      throw new Error(\"\".concat(key, \" is read-only.\"));\n    }\n  });\n};\nconst checkReadOnlyPropertyOnUpdate = (patches, modelDefinition) => {\n  const patchArray = patches.map(p => [p.path[0], p.value]);\n  const {\n    fields\n  } = modelDefinition;\n  patchArray.forEach(_ref6 => {\n    let [key, val] = _ref6;\n    if (!val || !fields[key]) return;\n    if (fields[key].isReadOnly) {\n      throw new Error(\"\".concat(key, \" is read-only.\"));\n    }\n  });\n};\nconst createNonModelClass = typeDefinition => {\n  const clazz = class Model {\n    constructor(init) {\n      const instance = produce(this, draft => {\n        initializeInstance(init, typeDefinition, draft);\n      });\n      return instance;\n    }\n  };\n  clazz[immerable] = true;\n  Object.defineProperty(clazz, 'name', {\n    value: typeDefinition.name\n  });\n  registerNonModelClass(clazz);\n  return clazz;\n};\nfunction isQueryOne(obj) {\n  return typeof obj === 'string';\n}\nfunction defaultConflictHandler(conflictData) {\n  const {\n    localModel,\n    modelConstructor,\n    remoteModel\n  } = conflictData;\n  const {\n    _version\n  } = remoteModel;\n  return modelInstanceCreator(modelConstructor, {\n    ...localModel,\n    _version\n  });\n}\nfunction defaultErrorHandler(error) {\n  logger.warn(error);\n}\nfunction getModelConstructorByModelName(namespaceName, modelName) {\n  let result;\n  switch (namespaceName) {\n    case DATASTORE:\n      result = dataStoreClasses[modelName];\n      break;\n    case USER:\n      result = userClasses[modelName];\n      break;\n    case SYNC:\n      result = syncClasses[modelName];\n      break;\n    case STORAGE:\n      result = storageClasses[modelName];\n      break;\n    default:\n      throw new Error(\"Invalid namespace: \".concat(namespaceName));\n  }\n  if (isValidModelConstructor(result)) {\n    return result;\n  } else {\n    const msg = \"Model name is not valid for namespace. modelName: \".concat(modelName, \", namespace: \").concat(namespaceName);\n    logger.error(msg);\n    throw new Error(msg);\n  }\n}\n/**\n * Queries the DataStore metadata tables to see if they are the expected\n * version. If not, clobbers the whole DB. If so, leaves them alone.\n * Otherwise, simply writes the schema version.\n *\n * SIDE EFFECT:\n * 1. Creates a transaction\n * 1. Updates data.\n *\n * @param storage Storage adapter containing the metadata.\n * @param version The expected schema version.\n */\nasync function checkSchemaVersion(storage, version) {\n  const Setting = dataStoreClasses.Setting;\n  const modelDefinition = schema.namespaces[DATASTORE].models.Setting;\n  await storage.runExclusive(async s => {\n    const [schemaVersionSetting] = await s.query(Setting, ModelPredicateCreator.createFromAST(modelDefinition, {\n      and: {\n        key: {\n          eq: SETTING_SCHEMA_VERSION\n        }\n      }\n    }), {\n      page: 0,\n      limit: 1\n    });\n    if (schemaVersionSetting !== undefined && schemaVersionSetting.value !== undefined) {\n      const storedValue = JSON.parse(schemaVersionSetting.value);\n      if (storedValue !== version) {\n        await s.clear(false);\n      }\n    } else {\n      await s.save(modelInstanceCreator(Setting, {\n        key: SETTING_SCHEMA_VERSION,\n        value: JSON.stringify(version)\n      }));\n    }\n  });\n}\nlet syncSubscription;\nfunction getNamespace() {\n  const namespace = {\n    name: DATASTORE,\n    relationships: {},\n    enums: {},\n    nonModels: {},\n    models: {\n      Setting: {\n        name: 'Setting',\n        pluralName: 'Settings',\n        syncable: false,\n        fields: {\n          id: {\n            name: 'id',\n            type: 'ID',\n            isRequired: true,\n            isArray: false\n          },\n          key: {\n            name: 'key',\n            type: 'String',\n            isRequired: true,\n            isArray: false\n          },\n          value: {\n            name: 'value',\n            type: 'String',\n            isRequired: true,\n            isArray: false\n          }\n        }\n      }\n    }\n  };\n  return namespace;\n}\nvar DataStoreState;\n(function (DataStoreState) {\n  DataStoreState[\"NotRunning\"] = \"Not Running\";\n  DataStoreState[\"Starting\"] = \"Starting\";\n  DataStoreState[\"Running\"] = \"Running\";\n  DataStoreState[\"Stopping\"] = \"Stopping\";\n  DataStoreState[\"Clearing\"] = \"Clearing\";\n})(DataStoreState || (DataStoreState = {}));\n// TODO: How can we get rid of the non-null assertions?\n// https://github.com/aws-amplify/amplify-js/pull/10477/files#r1007363485\nclass DataStore {\n  constructor() {\n    var _this = this;\n    // reference to configured category instances. Used for preserving SSR context\n    this.InternalAPI = InternalAPI;\n    this.Cache = Cache;\n    // Non-null assertions (bang operator) have been added to most of these properties\n    // to make TS happy. These properties are all expected to be set immediately after\n    // construction.\n    // TODO: Refactor to use proper DI if possible. If not possible, change these to\n    // optionals and implement conditional checks throughout. Rinse/repeat on all\n    // sync engine processors, storage engine, adapters, etc..\n    this.amplifyConfig = {};\n    this.syncPredicates = new WeakMap();\n    // object that gets passed to descendent classes. Allows us to pass these down by reference\n    this.amplifyContext = {\n      InternalAPI: this.InternalAPI\n    };\n    /**\n     * **IMPORTANT!**\n     *\n     * Accumulator for background things that can **and MUST** be called when\n     * DataStore stops.\n     *\n     * These jobs **MUST** be *idempotent promises* that resolve ONLY\n     * once the intended jobs are completely finished and/or otherwise destroyed\n     * and cleaned up with ZERO outstanding:\n     *\n     * 1. side effects (e.g., state changes)\n     * 1. callbacks\n     * 1. subscriptions\n     * 1. calls to storage\n     * 1. *etc.*\n     *\n     * Methods that create pending promises, subscriptions, callbacks, or any\n     * type of side effect **MUST** be registered with the manager. And, a new\n     * manager must be created after each `exit()`.\n     *\n     * Failure to comply will put DataStore into a highly unpredictable state\n     * when it needs to stop or clear -- which occurs when restarting with new\n     * sync expressions, during testing, and potentially during app code\n     * recovery handling, etc..\n     *\n     * It is up to the discretion of each disposer whether to wait for job\n     * completion or to cancel operations and issue failures *as long as the\n     * disposer returns in a reasonable amount of time.*\n     *\n     * (Reasonable = *seconds*, not minutes.)\n     */\n    this.runningProcesses = new BackgroundProcessManager();\n    /**\n     * Indicates what state DataStore is in.\n     *\n     * Not [yet?] used for actual state management; but for messaging\n     * when errors occur, to help troubleshoot.\n     */\n    this.state = DataStoreState.NotRunning;\n    /**\n     * If not already done:\n     * 1. Attaches and initializes storage.\n     * 2. Loads the schema and records metadata.\n     * 3. If `this.amplifyConfig.aws_appsync_graphqlEndpoint` contains a URL,\n     * attaches a sync engine, starts it, and subscribes.\n     */\n    this.start = async () => {\n      return this.runningProcesses.add(async () => {\n        this.state = DataStoreState.Starting;\n        if (this.initialized === undefined) {\n          logger.debug('Starting DataStore');\n          this.initialized = new Promise((res, rej) => {\n            this.initResolve = res;\n            this.initReject = rej;\n          });\n        } else {\n          await this.initialized;\n          return;\n        }\n        this.storage = new ExclusiveStorage(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, this.storageAdapter, this.sessionId);\n        await this.storage.init();\n        checkSchemaInitialized();\n        await checkSchemaVersion(this.storage, schema.version);\n        const {\n          aws_appsync_graphqlEndpoint\n        } = this.amplifyConfig;\n        if (aws_appsync_graphqlEndpoint) {\n          logger.debug('GraphQL endpoint available', aws_appsync_graphqlEndpoint);\n          this.syncPredicates = await this.processSyncExpressions();\n          this.sync = new SyncEngine(schema, namespaceResolver, syncClasses, userClasses, this.storage, modelInstanceCreator, this.conflictHandler, this.errorHandler, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, this.amplifyContext, this.connectivityMonitor);\n          const fullSyncIntervalInMilliseconds = this.fullSyncInterval * 1000 * 60; // fullSyncInterval from param is in minutes\n          syncSubscription = this.sync.start({\n            fullSyncInterval: fullSyncIntervalInMilliseconds\n          }).subscribe({\n            next: _ref7 => {\n              let {\n                type,\n                data\n              } = _ref7;\n              /**\n               * In Node, we need to wait for queries to be synced to prevent returning empty arrays.\n               * In non-Node environments (the browser or React Native), we can begin returning data\n               * once subscriptions are in place.\n               */\n              const readyType = isNode() ? ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY : ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED;\n              if (type === readyType) {\n                this.initResolve();\n              }\n              Hub.dispatch('datastore', {\n                event: type,\n                data\n              });\n            },\n            error: err => {\n              logger.warn('Sync error', err);\n              this.initReject();\n            }\n          });\n        } else {\n          logger.warn(\"Data won't be synchronized. No GraphQL endpoint configured. Did you forget `Amplify.configure(awsconfig)`?\", {\n            config: this.amplifyConfig\n          });\n          this.initResolve();\n        }\n        await this.initialized;\n        this.state = DataStoreState.Running;\n      }, 'datastore start').catch(this.handleAddProcError('DataStore.start()'));\n    };\n    this.query = async (modelConstructor, identifierOrCriteria, paginationProducer) => {\n      return this.runningProcesses.add(async () => {\n        await this.start();\n        let result;\n        if (!this.storage) {\n          throw new Error('No storage to query');\n        }\n        //#region Input validation\n        if (!isValidModelConstructor(modelConstructor)) {\n          const msg = 'Constructor is not for a valid model';\n          logger.error(msg, {\n            modelConstructor\n          });\n          throw new Error(msg);\n        }\n        if (typeof identifierOrCriteria === 'string') {\n          if (paginationProducer !== undefined) {\n            logger.warn('Pagination is ignored when querying by id');\n          }\n        }\n        const modelDefinition = getModelDefinition(modelConstructor);\n        if (!modelDefinition) {\n          throw new Error('Invalid model definition provided!');\n        }\n        const pagination = this.processPagination(modelDefinition, paginationProducer);\n        const keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n        if (isQueryOne(identifierOrCriteria)) {\n          if (keyFields.length > 1) {\n            const msg = errorMessages.queryByPkWithCompositeKeyPresent;\n            logger.error(msg, {\n              keyFields\n            });\n            throw new Error(msg);\n          }\n          const predicate = ModelPredicateCreator.createFromFlatEqualities(modelDefinition, {\n            [keyFields[0]]: identifierOrCriteria\n          });\n          result = await this.storage.query(modelConstructor, predicate, pagination);\n        } else {\n          // Object is being queried using object literal syntax\n          if (isIdentifierObject(identifierOrCriteria, modelDefinition)) {\n            const predicate = ModelPredicateCreator.createForPk(modelDefinition, identifierOrCriteria);\n            result = await this.storage.query(modelConstructor, predicate, pagination);\n          } else if (!identifierOrCriteria || isPredicatesAll(identifierOrCriteria)) {\n            var _this$storage;\n            result = await ((_this$storage = this.storage) === null || _this$storage === void 0 ? void 0 : _this$storage.query(modelConstructor, undefined, pagination));\n          } else {\n            const seedPredicate = recursivePredicateFor({\n              builder: modelConstructor,\n              schema: modelDefinition,\n              pkField: extractPrimaryKeyFieldNames(modelDefinition)\n            });\n            const predicate = internals(identifierOrCriteria(seedPredicate));\n            result = await predicate.fetch(this.storage);\n            result = inMemoryPagination(result, pagination);\n          }\n        }\n        //#endregion\n        const returnOne = isQueryOne(identifierOrCriteria) || isIdentifierObject(identifierOrCriteria, modelDefinition);\n        return attached(returnOne ? result[0] : result, ModelAttachment.DataStore);\n      }, 'datastore query').catch(this.handleAddProcError('DataStore.query()'));\n    };\n    this.save = async (model, condition) => {\n      return this.runningProcesses.add(async () => {\n        await this.start();\n        if (!this.storage) {\n          throw new Error('No storage to save to');\n        }\n        // Immer patches for constructing a correct update mutation input\n        // Allows us to only include changed fields for updates\n        const updatedPatchesTuple = modelPatchesMap.get(model);\n        // Immer patches for initial object construction. These are used if\n        // there are no `update` patches under the assumption we're performing\n        // a CREATE and wish to send only explicitly specified fields to the cloud.\n        const initPatchesTuple = initPatches.has(model) ? [initPatches.get(model), {}] : undefined;\n        // favor update patches over init/create patches, because init patches\n        // are ALWAYS present, whereas update patches are only present if copyOf\n        // was used to create the instance.\n        const patchesTuple = updatedPatchesTuple || initPatchesTuple;\n        const modelConstructor = model ? model.constructor : undefined;\n        if (!isValidModelConstructor(modelConstructor)) {\n          const msg = 'Object is not an instance of a valid model';\n          logger.error(msg, {\n            model\n          });\n          throw new Error(msg);\n        }\n        const modelDefinition = getModelDefinition(modelConstructor);\n        if (!modelDefinition) {\n          throw new Error('Model Definition could not be found for model');\n        }\n        const modelMeta = {\n          builder: modelConstructor,\n          schema: modelDefinition,\n          pkField: extractPrimaryKeyFieldNames(modelDefinition)\n        };\n        await this.storage.runExclusive(async s => {\n          // no enforcement for HAS_MANY on save, because the ~related~ entities\n          // hold the FK in that case.\n          const nonHasManyRelationships = ModelRelationship.allFrom(modelMeta).filter(r => r.type === 'BELONGS_TO');\n          for (const relationship of nonHasManyRelationships) {\n            const queryObject = relationship.createRemoteQueryObject(model);\n            if (queryObject !== null) {\n              const related = await s.query(relationship.remoteModelConstructor, ModelPredicateCreator.createFromFlatEqualities(relationship.remoteDefinition, queryObject));\n              if (related.length === 0) {\n                var _relationship$remoteD;\n                throw new Error([\"Data integrity error. You tried to save a \".concat(modelDefinition.name, \" (\").concat(JSON.stringify(model), \")\"), \"but the instance assigned to the \\\"\".concat(relationship.field, \"\\\" property\"), \"does not exist in the local database. If you're trying to create the related\", \"\\\"\".concat((_relationship$remoteD = relationship.remoteDefinition) === null || _relationship$remoteD === void 0 ? void 0 : _relationship$remoteD.name, \"\\\", you must save it independently first.\")].join(' '));\n              }\n            }\n          }\n        });\n        const producedCondition = condition ? internals(condition(predicateFor(modelMeta))).toStoragePredicate() : undefined;\n        const [savedModel] = await this.storage.runExclusive(async s => {\n          await s.save(model, producedCondition, undefined, patchesTuple);\n          return s.query(modelConstructor, ModelPredicateCreator.createForPk(modelDefinition, model));\n        });\n        return attached(savedModel, ModelAttachment.DataStore);\n      }, 'datastore save').catch(this.handleAddProcError('DataStore.save()'));\n    };\n    this.setConflictHandler = config => {\n      const {\n        DataStore: configDataStore\n      } = config;\n      const conflictHandlerIsDefault = () => this.conflictHandler === defaultConflictHandler;\n      if (configDataStore && configDataStore.conflictHandler) {\n        return configDataStore.conflictHandler;\n      }\n      if (conflictHandlerIsDefault() && config.conflictHandler) {\n        return config.conflictHandler;\n      }\n      return this.conflictHandler || defaultConflictHandler;\n    };\n    this.setErrorHandler = config => {\n      const {\n        DataStore: configDataStore\n      } = config;\n      const errorHandlerIsDefault = () => this.errorHandler === defaultErrorHandler;\n      if (configDataStore && configDataStore.errorHandler) {\n        return configDataStore.errorHandler;\n      }\n      if (errorHandlerIsDefault() && config.errorHandler) {\n        return config.errorHandler;\n      }\n      return this.errorHandler || defaultErrorHandler;\n    };\n    this.delete = async (modelOrConstructor, identifierOrCriteria) => {\n      return this.runningProcesses.add(async () => {\n        await this.start();\n        if (!this.storage) {\n          throw new Error('No storage to delete from');\n        }\n        let condition;\n        if (!modelOrConstructor) {\n          const msg = 'Model or Model Constructor required';\n          logger.error(msg, {\n            modelOrConstructor\n          });\n          throw new Error(msg);\n        }\n        if (isValidModelConstructor(modelOrConstructor)) {\n          const modelConstructor = modelOrConstructor;\n          if (!identifierOrCriteria) {\n            const msg = 'Id to delete or criteria required. Do you want to delete all? Pass Predicates.ALL';\n            logger.error(msg, {\n              identifierOrCriteria\n            });\n            throw new Error(msg);\n          }\n          const modelDefinition = getModelDefinition(modelConstructor);\n          if (!modelDefinition) {\n            throw new Error('Could not find model definition for modelConstructor.');\n          }\n          if (typeof identifierOrCriteria === 'string') {\n            const keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n            if (keyFields.length > 1) {\n              const msg = errorMessages.deleteByPkWithCompositeKeyPresent;\n              logger.error(msg, {\n                keyFields\n              });\n              throw new Error(msg);\n            }\n            condition = ModelPredicateCreator.createFromFlatEqualities(modelDefinition, {\n              [keyFields[0]]: identifierOrCriteria\n            });\n          } else {\n            if (isIdentifierObject(identifierOrCriteria, modelDefinition)) {\n              condition = ModelPredicateCreator.createForPk(modelDefinition, identifierOrCriteria);\n            } else {\n              condition = internals(identifierOrCriteria(predicateFor({\n                builder: modelConstructor,\n                schema: modelDefinition,\n                pkField: extractPrimaryKeyFieldNames(modelDefinition)\n              }))).toStoragePredicate();\n            }\n            if (!condition || !ModelPredicateCreator.isValidPredicate(condition)) {\n              const msg = 'Criteria required. Do you want to delete all? Pass Predicates.ALL';\n              logger.error(msg, {\n                condition\n              });\n              throw new Error(msg);\n            }\n          }\n          const [deleted] = await this.storage.delete(modelConstructor, condition);\n          return attached(deleted, ModelAttachment.DataStore);\n        } else {\n          const model = modelOrConstructor;\n          const modelConstructor = Object.getPrototypeOf(model || {}).constructor;\n          if (!isValidModelConstructor(modelConstructor)) {\n            const msg = 'Object is not an instance of a valid model';\n            logger.error(msg, {\n              model\n            });\n            throw new Error(msg);\n          }\n          const modelDefinition = getModelDefinition(modelConstructor);\n          if (!modelDefinition) {\n            throw new Error('Could not find model definition for modelConstructor.');\n          }\n          const pkPredicate = ModelPredicateCreator.createForPk(modelDefinition, model);\n          if (identifierOrCriteria) {\n            if (typeof identifierOrCriteria !== 'function') {\n              const msg = 'Invalid criteria';\n              logger.error(msg, {\n                identifierOrCriteria\n              });\n              throw new Error(msg);\n            }\n            condition = internals(identifierOrCriteria(predicateFor({\n              builder: modelConstructor,\n              schema: modelDefinition,\n              pkField: extractPrimaryKeyFieldNames(modelDefinition)\n            }))).toStoragePredicate();\n          } else {\n            condition = pkPredicate;\n          }\n          const [[deleted]] = await this.storage.delete(model, condition);\n          return attached(deleted, ModelAttachment.DataStore);\n        }\n      }, 'datastore delete').catch(this.handleAddProcError('DataStore.delete()'));\n    };\n    this.observe = (modelOrConstructor, identifierOrCriteria) => {\n      let executivePredicate;\n      const modelConstructor = modelOrConstructor && isValidModelConstructor(modelOrConstructor) ? modelOrConstructor : undefined;\n      if (modelOrConstructor && modelConstructor === undefined) {\n        const model = modelOrConstructor;\n        const modelConstructor = model && Object.getPrototypeOf(model).constructor;\n        if (isValidModelConstructor(modelConstructor)) {\n          if (identifierOrCriteria) {\n            logger.warn('idOrCriteria is ignored when using a model instance', {\n              model,\n              identifierOrCriteria\n            });\n          }\n          return this.observe(modelConstructor, model.id);\n        } else {\n          const msg = 'The model is not an instance of a PersistentModelConstructor';\n          logger.error(msg, {\n            model\n          });\n          throw new Error(msg);\n        }\n      }\n      // observe should not accept object literal syntax\n      if (identifierOrCriteria && modelConstructor && isIdentifierObject(identifierOrCriteria, getModelDefinition(modelConstructor))) {\n        const msg = errorMessages.observeWithObjectLiteral;\n        logger.error(msg, {\n          objectLiteral: identifierOrCriteria\n        });\n        throw new Error(msg);\n      }\n      if (identifierOrCriteria !== undefined && modelConstructor === undefined) {\n        const msg = 'Cannot provide criteria without a modelConstructor';\n        logger.error(msg, identifierOrCriteria);\n        throw new Error(msg);\n      }\n      if (modelConstructor && !isValidModelConstructor(modelConstructor)) {\n        const msg = 'Constructor is not for a valid model';\n        logger.error(msg, {\n          modelConstructor\n        });\n        throw new Error(msg);\n      }\n      if (modelConstructor && typeof identifierOrCriteria === 'string') {\n        const buildIdPredicate = seed => seed.id.eq(identifierOrCriteria);\n        executivePredicate = internals(buildIdPredicate(buildSeedPredicate(modelConstructor)));\n      } else if (modelConstructor && typeof identifierOrCriteria === 'function') {\n        executivePredicate = internals(identifierOrCriteria(buildSeedPredicate(modelConstructor)));\n      }\n      return new Observable(observer => {\n        let source;\n        this.runningProcesses.add(async () => {\n          await this.start();\n          // Filter the events returned by Storage according to namespace,\n          // append original element data, and subscribe to the observable\n          source = this.storage.observe(modelConstructor).pipe(filter(_ref8 => {\n            let {\n              model\n            } = _ref8;\n            return namespaceResolver(model) === USER;\n          })).subscribe({\n            next: item => this.runningProcesses.isOpen && this.runningProcesses.add(async () => {\n              // the `element` doesn't necessarily contain all item details or\n              // have related records attached consistently with that of a query()\n              // result item. for consistency, we attach them here.\n              let message = item;\n              // as long as we're not dealing with a DELETE, we need to fetch a fresh\n              // item from storage to ensure it's fully populated.\n              if (item.opType !== 'DELETE') {\n                const modelDefinition = getModelDefinition(item.model);\n                const keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n                const primaryKeysAndValues = extractPrimaryKeysAndValues(item.element, keyFields);\n                const freshElement = await this.query(item.model, primaryKeysAndValues);\n                message = {\n                  ...message,\n                  element: freshElement\n                };\n              }\n              if (!executivePredicate || (await executivePredicate.matches(message.element))) {\n                observer.next(message);\n              }\n            }, 'datastore observe message handler'),\n            error: err => observer.error(err),\n            complete: () => observer.complete()\n          });\n        }, 'datastore observe observable initialization').catch(this.handleAddProcError('DataStore.observe()')).catch(error => {\n          observer.error(error);\n        });\n        // better than no cleaner, but if the subscriber is handling the\n        // complete() message async and not registering with the context,\n        // this will still be problematic.\n        return this.runningProcesses.addCleaner(async () => {\n          if (source) {\n            source.unsubscribe();\n          }\n        }, 'DataStore.observe() cleanup');\n      });\n    };\n    this.observeQuery = (model, criteria, options) => {\n      return new Observable(observer => {\n        const items = new Map();\n        const itemsChanged = new Map();\n        let deletedItemIds = [];\n        let handle;\n        // let predicate: ModelPredicate<T> | undefined;\n        let executivePredicate;\n        /**\n         * As the name suggests, this geneates a snapshot in the form of\n         * \t`{items: T[], isSynced: boolean}`\n         * and sends it to the observer.\n         *\n         * SIDE EFFECT: The underlying generation and emission methods may touch:\n         * `items`, `itemsChanged`, and `deletedItemIds`.\n         *\n         * Refer to `generateSnapshot` and `emitSnapshot` for more details.\n         */\n        const generateAndEmitSnapshot = () => {\n          const snapshot = generateSnapshot();\n          emitSnapshot(snapshot);\n        };\n        // a mechanism to return data after X amount of seconds OR after the\n        // \"limit\" (itemsChanged >= this.syncPageSize) has been reached, whichever comes first\n        const limitTimerRace = new DeferredCallbackResolver({\n          callback: generateAndEmitSnapshot,\n          errorHandler: observer.error,\n          maxInterval: 2000\n        });\n        const {\n          sort\n        } = options || {};\n        const sortOptions = sort ? {\n          sort\n        } : undefined;\n        const modelDefinition = getModelDefinition(model);\n        if (!modelDefinition) {\n          throw new Error('Could not find model definition.');\n        }\n        if (model && typeof criteria === 'function') {\n          executivePredicate = internals(criteria(buildSeedPredicate(model)));\n        } else if (isPredicatesAll(criteria)) {\n          executivePredicate = undefined;\n        }\n        this.runningProcesses.add(async () => {\n          try {\n            // first, query and return any locally-available records\n            (await this.query(model, criteria, sortOptions)).forEach(item => {\n              const itemModelDefinition = getModelDefinition(model);\n              const idOrPk = getIdentifierValue(itemModelDefinition, item);\n              items.set(idOrPk, item);\n            });\n            // Observe the model and send a stream of updates (debounced).\n            // We need to post-filter results instead of passing criteria through\n            // to have visibility into items that move from in-set to out-of-set.\n            // We need to explicitly remove those items from the existing snapshot.\n            handle = this.observe(model).subscribe(_ref9 => {\n              let {\n                element,\n                model,\n                opType\n              } = _ref9;\n              return this.runningProcesses.isOpen && this.runningProcesses.add(async () => {\n                var _this$sync$getModelSy, _this$sync;\n                const itemModelDefinition = getModelDefinition(model);\n                const idOrPk = getIdentifierValue(itemModelDefinition, element);\n                if (executivePredicate && !(await executivePredicate.matches(element))) {\n                  if (opType === 'UPDATE' && (items.has(idOrPk) || itemsChanged.has(idOrPk))) {\n                    // tracking as a \"deleted item\" will include the item in\n                    // page limit calculations and ensure it is removed from the\n                    // final items collection, regardless of which collection(s)\n                    // it is currently in. (I mean, it could be in both, right!?)\n                    deletedItemIds.push(idOrPk);\n                  } else {\n                    // ignore updates for irrelevant/filtered items.\n                    return;\n                  }\n                }\n                // Flag items which have been recently deleted\n                // NOTE: Merging of separate operations to the same model instance is handled upstream\n                // in the `mergePage` method within src/sync/merger.ts. The final state of a model instance\n                // depends on the LATEST record (for a given id).\n                if (opType === 'DELETE') {\n                  deletedItemIds.push(idOrPk);\n                } else {\n                  itemsChanged.set(idOrPk, element);\n                }\n                const isSynced = (_this$sync$getModelSy = (_this$sync = this.sync) === null || _this$sync === void 0 ? void 0 : _this$sync.getModelSyncedStatus(model)) !== null && _this$sync$getModelSy !== void 0 ? _this$sync$getModelSy : false;\n                const limit = itemsChanged.size - deletedItemIds.length >= this.syncPageSize;\n                if (limit || isSynced) {\n                  limitTimerRace.resolve();\n                }\n                // kicks off every subsequent race as results sync down\n                limitTimerRace.start();\n              }, 'handle observeQuery observed event');\n            });\n            // returns a set of initial/locally-available results\n            generateAndEmitSnapshot();\n          } catch (err) {\n            observer.error(err);\n          }\n        }, 'datastore observequery startup').catch(this.handleAddProcError('DataStore.observeQuery()')).catch(error => {\n          observer.error(error);\n        });\n        /**\n         * Combines the `items`, `itemsChanged`, and `deletedItemIds` collections into\n         * a snapshot in the form of `{ items: T[], isSynced: boolean}`.\n         *\n         * SIDE EFFECT: The shared `items` collection is recreated.\n         */\n        const generateSnapshot = () => {\n          var _this$sync$getModelSy2, _this$sync2;\n          const isSynced = (_this$sync$getModelSy2 = (_this$sync2 = this.sync) === null || _this$sync2 === void 0 ? void 0 : _this$sync2.getModelSyncedStatus(model)) !== null && _this$sync$getModelSy2 !== void 0 ? _this$sync$getModelSy2 : false;\n          const itemsArray = [...Array.from(items.values()), ...Array.from(itemsChanged.values())];\n          items.clear();\n          itemsArray.forEach(item => {\n            const itemModelDefinition = getModelDefinition(model);\n            const idOrPk = getIdentifierValue(itemModelDefinition, item);\n            items.set(idOrPk, item);\n          });\n          // remove deleted items from the final result set\n          deletedItemIds.forEach(idOrPk => items.delete(idOrPk));\n          const snapshot = Array.from(items.values());\n          // we sort after we merge the snapshots (items, itemsChanged)\n          // otherwise, the merge may not\n          if (options !== null && options !== void 0 && options.sort) {\n            sortItems(snapshot);\n          }\n          return {\n            items: snapshot,\n            isSynced\n          };\n        };\n        /**\n         * Emits the list of items to the observer.\n         *\n         * SIDE EFFECT: `itemsChanged` and `deletedItemIds` are cleared to prepare\n         * for the next snapshot.\n         *\n         * @param snapshot The generated items data to emit.\n         */\n        const emitSnapshot = snapshot => {\n          // send the generated snapshot to the primary subscription.\n          // NOTE: This observer's handler *could* be async ...\n          observer.next(snapshot);\n          // reset the changed items sets\n          itemsChanged.clear();\n          deletedItemIds = [];\n        };\n        /**\n         * Sorts an `Array` of `T` according to the sort instructions given in the\n         * original  `observeQuery()` call.\n         *\n         * @param itemsToSort A array of model type.\n         */\n        const sortItems = itemsToSort => {\n          const modelDefinition = getModelDefinition(model);\n          const pagination = this.processPagination(modelDefinition, options);\n          const sortPredicates = ModelSortPredicateCreator.getPredicates(pagination.sort);\n          if (sortPredicates.length) {\n            const compareFn = sortCompareFunction(sortPredicates);\n            itemsToSort.sort(compareFn);\n          }\n        };\n        /**\n         * Force one last snapshot when the model is fully synced.\n         *\n         * This reduces latency for that last snapshot, which will otherwise\n         * wait for the configured timeout.\n         *\n         * @param payload The payload from the Hub event.\n         */\n        const hubCallback = _ref10 => {\n          var _data$model;\n          let {\n            payload\n          } = _ref10;\n          const {\n            event,\n            data\n          } = payload;\n          if (event === ControlMessage.SYNC_ENGINE_MODEL_SYNCED && (data === null || data === void 0 || (_data$model = data.model) === null || _data$model === void 0 ? void 0 : _data$model.name) === model.name) {\n            generateAndEmitSnapshot();\n            hubRemove();\n          }\n        };\n        const hubRemove = Hub.listen('datastore', hubCallback);\n        return this.runningProcesses.addCleaner(async () => {\n          if (handle) {\n            handle.unsubscribe();\n          }\n        }, 'datastore observequery cleaner');\n      });\n    };\n    this.configure = function () {\n      var _Amplify$getConfig$AP;\n      let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      _this.amplifyContext.InternalAPI = _this.InternalAPI;\n      const {\n        DataStore: configDataStore,\n        authModeStrategyType: configAuthModeStrategyType,\n        conflictHandler: configConflictHandler,\n        errorHandler: configErrorHandler,\n        maxRecordsToSync: configMaxRecordsToSync,\n        syncPageSize: configSyncPageSize,\n        fullSyncInterval: configFullSyncInterval,\n        syncExpressions: configSyncExpressions,\n        authProviders: configAuthProviders,\n        storageAdapter: configStorageAdapter,\n        ...configFromAmplify\n      } = config;\n      const currentAppSyncConfig = (_Amplify$getConfig$AP = Amplify.getConfig().API) === null || _Amplify$getConfig$AP === void 0 ? void 0 : _Amplify$getConfig$AP.GraphQL;\n      const appSyncConfig = {\n        aws_appsync_graphqlEndpoint: currentAppSyncConfig === null || currentAppSyncConfig === void 0 ? void 0 : currentAppSyncConfig.endpoint,\n        aws_appsync_authenticationType: currentAppSyncConfig === null || currentAppSyncConfig === void 0 ? void 0 : currentAppSyncConfig.defaultAuthMode,\n        aws_appsync_region: currentAppSyncConfig === null || currentAppSyncConfig === void 0 ? void 0 : currentAppSyncConfig.region,\n        aws_appsync_apiKey: currentAppSyncConfig === null || currentAppSyncConfig === void 0 ? void 0 : currentAppSyncConfig.apiKey\n      };\n      _this.amplifyConfig = {\n        ..._this.amplifyConfig,\n        ...configFromAmplify,\n        ...(currentAppSyncConfig && appSyncConfig)\n      };\n      _this.conflictHandler = _this.setConflictHandler(config);\n      _this.errorHandler = _this.setErrorHandler(config);\n      const authModeStrategyType = configDataStore && configDataStore.authModeStrategyType || configAuthModeStrategyType || AuthModeStrategyType.DEFAULT;\n      switch (authModeStrategyType) {\n        case AuthModeStrategyType.MULTI_AUTH:\n          _this.authModeStrategy = multiAuthStrategy(_this.amplifyContext);\n          break;\n        case AuthModeStrategyType.DEFAULT:\n          _this.authModeStrategy = defaultAuthStrategy;\n          break;\n        default:\n          _this.authModeStrategy = defaultAuthStrategy;\n          break;\n      }\n      // store on config object, so that Sync, Subscription, and Mutation processors can have access\n      _this.amplifyConfig.authProviders = configDataStore && configDataStore.authProviders || configAuthProviders;\n      _this.syncExpressions = configDataStore && configDataStore.syncExpressions || configSyncExpressions || _this.syncExpressions;\n      _this.maxRecordsToSync = configDataStore && configDataStore.maxRecordsToSync || configMaxRecordsToSync || _this.maxRecordsToSync || 10000;\n      // store on config object, so that Sync, Subscription, and Mutation processors can have access\n      _this.amplifyConfig.maxRecordsToSync = _this.maxRecordsToSync;\n      _this.syncPageSize = configDataStore && configDataStore.syncPageSize || configSyncPageSize || _this.syncPageSize || 1000;\n      // store on config object, so that Sync, Subscription, and Mutation processors can have access\n      _this.amplifyConfig.syncPageSize = _this.syncPageSize;\n      _this.fullSyncInterval = configDataStore && configDataStore.fullSyncInterval || configFullSyncInterval || _this.fullSyncInterval || 24 * 60; // 1 day\n      _this.storageAdapter = configDataStore && configDataStore.storageAdapter || configStorageAdapter || _this.storageAdapter || undefined;\n      _this.sessionId = _this.retrieveSessionId();\n    };\n  }\n  getModuleName() {\n    return 'DataStore';\n  }\n  /**\n   * Builds a function to capture `BackgroundManagerNotOpenError`'s to produce friendlier,\n   * more instructive errors for customers.\n   *\n   * @param operation The name of the operation (usually a Datastore method) the customer\n   * tried to call.\n   */\n  handleAddProcError(operation) {\n    /**\n     * If the tested error is a `BackgroundManagerNotOpenError`, it will be captured\n     * and replaced with a friendlier message that instructs the App Developer.\n     *\n     * @param err An error to test.\n     */\n    const handler = err => {\n      if (err.message.startsWith('BackgroundManagerNotOpenError')) {\n        throw new Error([\"DataStoreStateError: Tried to execute `\".concat(operation, \"` while DataStore was \\\"\").concat(this.state, \"\\\".\"), \"This can only be done while DataStore is \\\"Started\\\" or \\\"Stopped\\\". To remedy:\", 'Ensure all calls to `stop()` and `clear()` have completed first.', 'If this is not possible, retry the operation until it succeeds.'].join('\\n'));\n      } else {\n        throw err;\n      }\n    };\n    return handler;\n  }\n  /**\n   * Clears all data from storage and removes all data, schema info, other\n   * initialization details, and then stops DataStore.\n   *\n   * That said, reinitialization is required after clearing. This can be done\n   * by explicitiliy calling `start()` or any method that implicitly starts\n   * DataStore, such as `query()`, `save()`, or `delete()`.\n   */\n  async clear() {\n    checkSchemaInitialized();\n    this.state = DataStoreState.Clearing;\n    await this.runningProcesses.close();\n    if (this.storage === undefined) {\n      // connect to storage so that it can be cleared without fully starting DataStore\n      this.storage = new ExclusiveStorage(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, this.storageAdapter, this.sessionId);\n      await this.storage.init();\n    }\n    if (syncSubscription && !syncSubscription.closed) {\n      syncSubscription.unsubscribe();\n    }\n    if (this.sync) {\n      await this.sync.stop();\n    }\n    await this.storage.clear();\n    this.initialized = undefined; // Should re-initialize when start() is called.\n    this.storage = undefined;\n    this.sync = undefined;\n    this.syncPredicates = new WeakMap();\n    await this.runningProcesses.open();\n    this.state = DataStoreState.NotRunning;\n  }\n  /**\n   * Stops all DataStore sync activities.\n   *\n   * TODO: \"Waits for graceful termination of\n   * running queries and terminates subscriptions.\"\n   */\n  async stop() {\n    this.state = DataStoreState.Stopping;\n    await this.runningProcesses.close();\n    if (syncSubscription && !syncSubscription.closed) {\n      syncSubscription.unsubscribe();\n    }\n    if (this.sync) {\n      await this.sync.stop();\n    }\n    this.initialized = undefined; // Should re-initialize when start() is called.\n    this.sync = undefined;\n    await this.runningProcesses.open();\n    this.state = DataStoreState.NotRunning;\n  }\n  /**\n   * Validates given pagination input from a query and creates a pagination\n   * argument for use against the storage layer.\n   *\n   * @param modelDefinition\n   * @param paginationProducer\n   */\n  processPagination(modelDefinition, paginationProducer) {\n    let sortPredicate;\n    const {\n      limit,\n      page,\n      sort\n    } = paginationProducer || {};\n    if (limit === undefined && page === undefined && sort === undefined) {\n      return undefined;\n    }\n    if (page !== undefined && limit === undefined) {\n      throw new Error('Limit is required when requesting a page');\n    }\n    if (page !== undefined) {\n      if (typeof page !== 'number') {\n        throw new Error('Page should be a number');\n      }\n      if (page < 0) {\n        throw new Error(\"Page can't be negative\");\n      }\n    }\n    if (limit !== undefined) {\n      if (typeof limit !== 'number') {\n        throw new Error('Limit should be a number');\n      }\n      if (limit < 0) {\n        throw new Error(\"Limit can't be negative\");\n      }\n    }\n    if (sort) {\n      sortPredicate = ModelSortPredicateCreator.createFromExisting(modelDefinition, sort);\n    }\n    return {\n      limit,\n      page,\n      sort: sortPredicate\n    };\n  }\n  /**\n   * Examines the configured `syncExpressions` and produces a WeakMap of\n   * SchemaModel -> predicate to use during sync.\n   */\n  async processSyncExpressions() {\n    if (!this.syncExpressions || !this.syncExpressions.length) {\n      return new WeakMap();\n    }\n    const syncPredicates = await Promise.all(this.syncExpressions.map(async syncExpression => {\n      const {\n        modelConstructor,\n        conditionProducer\n      } = await syncExpression;\n      const modelDefinition = getModelDefinition(modelConstructor);\n      // conditionProducer is either a predicate, e.g. (c) => c.field.eq(1)\n      // OR a function/promise that returns a predicate\n      const condition = await this.unwrapPromise(conditionProducer);\n      if (isPredicatesAll(condition)) {\n        return [modelDefinition, null];\n      }\n      const predicate = internals(condition(predicateFor({\n        builder: modelConstructor,\n        schema: modelDefinition,\n        pkField: extractPrimaryKeyFieldNames(modelDefinition)\n      }))).toStoragePredicate();\n      return [modelDefinition, predicate];\n    }));\n    return this.weakMapFromEntries(syncPredicates);\n  }\n  async unwrapPromise(conditionProducer) {\n    try {\n      const condition = await conditionProducer();\n      return condition || conditionProducer;\n    } catch (error) {\n      if (error instanceof TypeError) {\n        return conditionProducer;\n      }\n      throw error;\n    }\n  }\n  weakMapFromEntries(entries) {\n    return entries.reduce((map, _ref11) => {\n      let [modelDefinition, predicate] = _ref11;\n      if (map.has(modelDefinition)) {\n        const {\n          name\n        } = modelDefinition;\n        logger.warn(\"You can only utilize one Sync Expression per model.\\n          Subsequent sync expressions for the \".concat(name, \" model will be ignored.\"));\n        return map;\n      }\n      if (predicate) {\n        map.set(modelDefinition, predicate);\n      }\n      return map;\n    }, new WeakMap());\n  }\n  /**\n   * A session ID to allow CMS to open databases against multiple apps.\n   * This session ID is only expected be set by AWS Amplify Studio.\n   */\n  retrieveSessionId() {\n    try {\n      const sessionId = sessionStorage.getItem('datastoreSessionId');\n      if (sessionId) {\n        const {\n          aws_appsync_graphqlEndpoint\n        } = this.amplifyConfig;\n        const appSyncUrl = aws_appsync_graphqlEndpoint.split('/')[2];\n        const [appSyncId] = appSyncUrl.split('.');\n        return \"\".concat(sessionId, \"-\").concat(appSyncId);\n      }\n    } catch {}\n    return undefined;\n  }\n}\nconst instance = new DataStore();\ninstance.configure({});\nHub.listen('core', capsule => {\n  if (capsule.payload.event === 'configure') {\n    instance.configure({});\n  }\n});\nexport { AsyncCollection, AsyncItem, instance as DataStore, DataStore as DataStoreClass, attached, getAttachment, initSchema, syncClasses };","map":{"version":3,"names":["setAutoFreeze","enablePatches","logger","ConsoleLogger","ulid","monotonicUlidFactory","Date","now","SETTING_SCHEMA_VERSION","schema","modelNamespaceMap","WeakMap","modelPatchesMap","getModelDefinition","modelConstructor","namespace","get","definition","namespaces","models","name","undefined","isValidModelConstructor","obj","isModelConstructor","has","namespaceResolver","resolver","Error","concat","buildSeedPredicate","modelSchema","pks","extractPrimaryKeyFieldNames","recursivePredicateFor","builder","pkField","syncClasses","userClasses","dataStoreClasses","storageClasses","modelInstanceAssociationsMap","ModelAttachment","attachedModelInstances","attached","result","attachment","Array","isArray","map","record","set","getAttachment","instance","Detached","initSchema","userSchema","console","warn","log","checkSchemaCodegenVersion","codegenVersion","internalUserNamespace","USER","createTypeClasses","dataStoreNamespace","getNamespace","storageNamespace","ExclusiveStorage","syncNamespace","SyncEngine","version","Object","keys","forEach","relations","establishRelationAndKeys","relationships","modelAssociations","Map","values","model","connectedModels","fields","filter","field","association","connectionType","type","push","relatedModel","defineProperty","relatedModelDefinition","indexes","indexFields","Set","index","indexField","add","allFields","fromEntries","count","size","modelName","from","parents","every","x","delete","modelTopologicalOrdering","checkSchemaInitialized","message","error","majorVersion","minorVersion","isValid","versionParts","split","major","minor","patch","patchrevision","Number","err","classes","entries","_ref","modelDefinition","clazz","createModelClass","nonModels","_ref2","typeName","typeDefinition","createNonModelClass","instancesMetadata","WeakSet","modelInstanceCreator","init","validateModelFields","k","v","fieldDefinition","isRequired","isArrayNullable","timestamps","isSchemaModelWithAttributes","getTimestampFields","isTimestampField","isIdManaged","includes","errorMessages","idEmptyString","value","isGraphQLScalarType","jsType","GraphQLScalarType","getJSType","validateScalar","getValidationFunction","JSON","parse","errorTypeText","isNullOrUndefined","some","e","elemTypes","join","validationStatus","s","isNonModelFieldType","subNonModelDefinition","user","nonModel","modelValidator","item","subKey","castInstanceType","isModelFieldType","Boolean","initPatches","initializeInstance","draft","_ref3","parsedValue","normalize","Model","constructor","patches","baseInstance","produce","isInternallyInitialized","modelInstanceMetadata","id","_id","isInternalModel","syncable","amplifyUuid","isIdOptionallyManaged","checkReadOnlyPropertyOnCreate","_version","_lastChangedAt","_deleted","p","normalized","copyOf","source","fn","getPrototypeOf","msg","keyNames","key","_ref4","hasExistingPatches","length","existingPatches","existingSource","mergedPatches","mergePatches","checkReadOnlyPropertyOnUpdate","DataStore","fromJSON","json","_ref5","immerable","allModelRelationships","ModelRelationship","allFrom","relationship","prototype","hasOwnProperty","toLowerCase","remoteModelConstructor","isComplete","i","localJoinFields","remoteJoinFields","instanceMemos","resultPromise","query","base","and","q","eq","AsyncCollection","then","rows","API","Promise","resolve","AsyncItem","Symbol","asyncIterator","next","done","toArray","max","MAX_SAFE_INTEGER","arguments","output","element","modelKeys","isReadOnly","patchArray","path","_ref6","val","registerNonModelClass","isQueryOne","defaultConflictHandler","conflictData","localModel","remoteModel","defaultErrorHandler","getModelConstructorByModelName","namespaceName","DATASTORE","SYNC","STORAGE","checkSchemaVersion","storage","Setting","runExclusive","schemaVersionSetting","ModelPredicateCreator","createFromAST","page","limit","storedValue","clear","save","stringify","syncSubscription","enums","pluralName","DataStoreState","_this","InternalAPI","Cache","amplifyConfig","syncPredicates","amplifyContext","runningProcesses","BackgroundProcessManager","state","NotRunning","start","Starting","initialized","debug","res","rej","initResolve","initReject","storageAdapter","sessionId","aws_appsync_graphqlEndpoint","processSyncExpressions","sync","conflictHandler","errorHandler","authModeStrategy","connectivityMonitor","fullSyncIntervalInMilliseconds","fullSyncInterval","subscribe","_ref7","data","readyType","isNode","ControlMessage","SYNC_ENGINE_SYNC_QUERIES_READY","SYNC_ENGINE_STORAGE_SUBSCRIBED","Hub","dispatch","event","config","Running","catch","handleAddProcError","identifierOrCriteria","paginationProducer","pagination","processPagination","keyFields","queryByPkWithCompositeKeyPresent","predicate","createFromFlatEqualities","isIdentifierObject","createForPk","isPredicatesAll","_this$storage","seedPredicate","internals","fetch","inMemoryPagination","returnOne","condition","updatedPatchesTuple","initPatchesTuple","patchesTuple","modelMeta","nonHasManyRelationships","r","queryObject","createRemoteQueryObject","related","remoteDefinition","_relationship$remoteD","producedCondition","predicateFor","toStoragePredicate","savedModel","setConflictHandler","configDataStore","conflictHandlerIsDefault","setErrorHandler","errorHandlerIsDefault","modelOrConstructor","deleteByPkWithCompositeKeyPresent","isValidPredicate","deleted","pkPredicate","observe","executivePredicate","observeWithObjectLiteral","objectLiteral","buildIdPredicate","seed","Observable","observer","pipe","_ref8","isOpen","opType","primaryKeysAndValues","extractPrimaryKeysAndValues","freshElement","matches","complete","addCleaner","unsubscribe","observeQuery","criteria","options","items","itemsChanged","deletedItemIds","handle","generateAndEmitSnapshot","snapshot","generateSnapshot","emitSnapshot","limitTimerRace","DeferredCallbackResolver","callback","maxInterval","sort","sortOptions","itemModelDefinition","idOrPk","getIdentifierValue","_ref9","_this$sync$getModelSy","_this$sync","isSynced","getModelSyncedStatus","syncPageSize","_this$sync$getModelSy2","_this$sync2","itemsArray","sortItems","itemsToSort","sortPredicates","ModelSortPredicateCreator","getPredicates","compareFn","sortCompareFunction","hubCallback","_ref10","_data$model","payload","SYNC_ENGINE_MODEL_SYNCED","hubRemove","listen","configure","_Amplify$getConfig$AP","authModeStrategyType","configAuthModeStrategyType","configConflictHandler","configErrorHandler","maxRecordsToSync","configMaxRecordsToSync","configSyncPageSize","configFullSyncInterval","syncExpressions","configSyncExpressions","authProviders","configAuthProviders","configStorageAdapter","configFromAmplify","currentAppSyncConfig","Amplify","getConfig","GraphQL","appSyncConfig","endpoint","aws_appsync_authenticationType","defaultAuthMode","aws_appsync_region","region","aws_appsync_apiKey","apiKey","AuthModeStrategyType","DEFAULT","MULTI_AUTH","multiAuthStrategy","defaultAuthStrategy","retrieveSessionId","getModuleName","operation","handler","startsWith","Clearing","close","closed","stop","open","Stopping","sortPredicate","createFromExisting","all","syncExpression","conditionProducer","unwrapPromise","weakMapFromEntries","TypeError","reduce","_ref11","sessionStorage","getItem","appSyncUrl","appSyncId","capsule"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/datastore/datastore.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { InternalAPI } from '@aws-amplify/api/internals';\nimport { Amplify, Hub, Cache, ConsoleLogger } from '@aws-amplify/core';\nimport { immerable, produce, setAutoFreeze, enablePatches, } from 'immer';\nimport { amplifyUuid } from '@aws-amplify/core/internals/utils';\nimport { Observable, filter } from 'rxjs';\nimport { defaultAuthStrategy, multiAuthStrategy } from '../authModeStrategies';\nimport { isPredicatesAll, ModelPredicateCreator, ModelSortPredicateCreator, } from '../predicates';\nimport { ExclusiveStorage as Storage } from '../storage/storage';\nimport { ModelRelationship } from '../storage/relationship';\nimport { ControlMessage, SyncEngine } from '../sync';\nimport { GraphQLScalarType, isGraphQLScalarType, isSchemaModelWithAttributes, AuthModeStrategyType, isNonModelFieldType, isModelFieldType, isIdentifierObject, } from '../types';\nimport { isNode } from './utils';\nimport { DATASTORE, errorMessages, establishRelationAndKeys, isModelConstructor, monotonicUlidFactory, STORAGE, SYNC, USER, isNullOrUndefined, registerNonModelClass, sortCompareFunction, DeferredCallbackResolver, inMemoryPagination, extractPrimaryKeyFieldNames, extractPrimaryKeysAndValues, isIdManaged, isIdOptionallyManaged, mergePatches, getTimestampFields, } from '../util';\nimport { recursivePredicateFor, predicateFor, internals, } from '../predicates/next';\nimport { getIdentifierValue } from '../sync/utils';\nimport { BackgroundProcessManager } from '@aws-amplify/core/internals/utils';\nsetAutoFreeze(true);\nenablePatches();\nconst logger = new ConsoleLogger('DataStore');\nconst ulid = monotonicUlidFactory(Date.now());\nconst SETTING_SCHEMA_VERSION = 'schemaVersion';\nlet schema;\nconst modelNamespaceMap = new WeakMap();\n/**\n * Stores data for crafting the correct update mutation input for a model.\n *\n * - `Patch[]` - array of changed fields and metadata.\n * - `PersistentModel` - the source model, used for diffing object-type fields.\n */\nconst modelPatchesMap = new WeakMap();\nconst getModelDefinition = (modelConstructor) => {\n    const namespace = modelNamespaceMap.get(modelConstructor);\n    const definition = namespace\n        ? schema.namespaces[namespace].models[modelConstructor.name]\n        : undefined;\n    return definition;\n};\n/**\n * Determines whether the given object is a Model Constructor that DataStore can\n * safely use to construct objects and discover related metadata.\n *\n * @param obj The object to test.\n */\nconst isValidModelConstructor = (obj) => {\n    return isModelConstructor(obj) && modelNamespaceMap.has(obj);\n};\nconst namespaceResolver = modelConstructor => {\n    const resolver = modelNamespaceMap.get(modelConstructor);\n    if (!resolver) {\n        throw new Error(`Namespace Resolver for '${modelConstructor.name}' not found! This is probably a bug in '@amplify-js/datastore'.`);\n    }\n    return resolver;\n};\n/**\n * Creates a predicate without any conditions that can be passed to customer\n * code to have conditions added to it.\n *\n * For example, in this query:\n *\n * ```ts\n * await DataStore.query(\n * \tModel,\n * \titem => item.field.eq('value')\n * );\n * ```\n *\n * `buildSeedPredicate(Model)` is used to create `item`, which is passed to the\n * predicate function, which in turn uses that \"seed\" predicate (`item`) to build\n * a predicate tree.\n *\n * @param modelConstructor The model the predicate will query.\n */\nconst buildSeedPredicate = (modelConstructor) => {\n    if (!modelConstructor)\n        throw new Error('Missing modelConstructor');\n    const modelSchema = getModelDefinition(modelConstructor);\n    if (!modelSchema)\n        throw new Error('Missing modelSchema');\n    const pks = extractPrimaryKeyFieldNames(modelSchema);\n    if (!pks)\n        throw new Error('Could not determine PK');\n    return recursivePredicateFor({\n        builder: modelConstructor,\n        schema: modelSchema,\n        pkField: pks,\n    });\n};\n// exporting syncClasses for testing outbox.test.ts\nexport let syncClasses;\nlet userClasses;\nlet dataStoreClasses;\nlet storageClasses;\n/**\n * Maps a model to its related models for memoization/immutability.\n */\nconst modelInstanceAssociationsMap = new WeakMap();\n/**\n * Describes whether and to what a model is attached for lazy loading purposes.\n */\nvar ModelAttachment;\n(function (ModelAttachment) {\n    /**\n     * Model doesn't lazy load from any data source.\n     *\n     * Related entity properties provided at instantiation are returned\n     * via the respective lazy interfaces when their properties are invoked.\n     */\n    ModelAttachment[\"Detached\"] = \"Detached\";\n    /**\n     * Model lazy loads from the global DataStore.\n     */\n    ModelAttachment[\"DataStore\"] = \"DataStore\";\n    /**\n     * Demonstrative. Not yet implemented.\n     */\n    ModelAttachment[\"API\"] = \"API\";\n})(ModelAttachment || (ModelAttachment = {}));\n/**\n * Tells us which data source a model is attached to (lazy loads from).\n *\n * If `Deatched`, the model's lazy properties will only ever return properties\n * from memory provided at construction time.\n */\nconst attachedModelInstances = new WeakMap();\n/**\n * Registers a model instance against a data source (DataStore, API, or\n * Detached/None).\n *\n * The API option is demonstrative. Lazy loading against API is not yet\n * implemented.\n *\n * @param result A model instance or array of instances\n * @param attachment A ModelAttachment data source\n * @returns passes the `result` back through after attachment\n */\nexport function attached(result, attachment) {\n    if (Array.isArray(result)) {\n        result.map(record => attached(record, attachment));\n    }\n    else {\n        result && attachedModelInstances.set(result, attachment);\n    }\n    return result;\n}\n/**\n * Determines what source a model instance should lazy load from.\n *\n * If the instace was never explicitly registered, it is detached by default.\n *\n * @param instance A model instance\n */\nexport const getAttachment = (instance) => {\n    return attachedModelInstances.has(instance)\n        ? attachedModelInstances.get(instance)\n        : ModelAttachment.Detached;\n};\nconst initSchema = (userSchema) => {\n    if (schema !== undefined) {\n        console.warn('The schema has already been initialized');\n        return userClasses;\n    }\n    logger.log('validating schema', { schema: userSchema });\n    checkSchemaCodegenVersion(userSchema.codegenVersion);\n    const internalUserNamespace = {\n        name: USER,\n        ...userSchema,\n    };\n    logger.log('DataStore', 'Init models');\n    userClasses = createTypeClasses(internalUserNamespace);\n    logger.log('DataStore', 'Models initialized');\n    const dataStoreNamespace = getNamespace();\n    const storageNamespace = Storage.getNamespace();\n    const syncNamespace = SyncEngine.getNamespace();\n    dataStoreClasses = createTypeClasses(dataStoreNamespace);\n    storageClasses = createTypeClasses(storageNamespace);\n    syncClasses = createTypeClasses(syncNamespace);\n    schema = {\n        namespaces: {\n            [dataStoreNamespace.name]: dataStoreNamespace,\n            [internalUserNamespace.name]: internalUserNamespace,\n            [storageNamespace.name]: storageNamespace,\n            [syncNamespace.name]: syncNamespace,\n        },\n        version: userSchema.version,\n        codegenVersion: userSchema.codegenVersion,\n    };\n    Object.keys(schema.namespaces).forEach(namespace => {\n        const [relations, keys] = establishRelationAndKeys(schema.namespaces[namespace]);\n        schema.namespaces[namespace].relationships = relations;\n        schema.namespaces[namespace].keys = keys;\n        const modelAssociations = new Map();\n        Object.values(schema.namespaces[namespace].models).forEach(model => {\n            const connectedModels = [];\n            Object.values(model.fields)\n                .filter(field => field.association &&\n                field.association.connectionType === 'BELONGS_TO' &&\n                field.type.model !== model.name)\n                .forEach(field => connectedModels.push(field.type.model));\n            modelAssociations.set(model.name, connectedModels);\n            // Precompute model info (such as pk fields) so that downstream schema consumers\n            // (such as predicate builders) don't have to reach back into \"DataStore\" space\n            // to go looking for it.\n            Object.values(model.fields).forEach(field => {\n                const relatedModel = userClasses[field.type.model];\n                if (isModelConstructor(relatedModel)) {\n                    Object.defineProperty(field.type, 'modelConstructor', {\n                        get: () => {\n                            const relatedModelDefinition = getModelDefinition(relatedModel);\n                            if (!relatedModelDefinition)\n                                throw new Error(`Could not find model definition for ${relatedModel.name}`);\n                            return {\n                                builder: relatedModel,\n                                schema: relatedModelDefinition,\n                                pkField: extractPrimaryKeyFieldNames(relatedModelDefinition),\n                            };\n                        },\n                    });\n                }\n            });\n            // compatibility with legacy/pre-PK codegen for lazy loading to inject\n            // index fields into the model definition.\n            // definition.cloudFields = { ...definition.fields };\n            const indexes = schema.namespaces[namespace].relationships[model.name].indexes;\n            const indexFields = new Set();\n            for (const index of indexes) {\n                for (const indexField of index[1]) {\n                    indexFields.add(indexField);\n                }\n            }\n            model.allFields = {\n                ...Object.fromEntries([...indexFields.values()].map(name => [\n                    name,\n                    {\n                        name,\n                        type: 'ID',\n                        isArray: false,\n                    },\n                ])),\n                ...model.fields,\n            };\n        });\n        const result = new Map();\n        let count = 1000;\n        while (true && count > 0) {\n            if (modelAssociations.size === 0) {\n                break;\n            }\n            count--;\n            if (count === 0) {\n                throw new Error('Models are not topologically sortable. Please verify your schema.');\n            }\n            for (const modelName of Array.from(modelAssociations.keys())) {\n                const parents = modelAssociations.get(modelName);\n                if (parents?.every(x => result.has(x))) {\n                    result.set(modelName, parents);\n                }\n            }\n            Array.from(result.keys()).forEach(x => modelAssociations.delete(x));\n        }\n        schema.namespaces[namespace].modelTopologicalOrdering = result;\n    });\n    return userClasses;\n};\n/**\n * Throws an exception if the schema has *not* been initialized\n * by `initSchema()`.\n *\n * **To be called before trying to access schema.**\n *\n * Currently this only needs to be called in `start()` and `clear()` because\n * all other functions will call start first.\n */\nconst checkSchemaInitialized = () => {\n    if (schema === undefined) {\n        const message = 'Schema is not initialized. DataStore will not function as expected. This could happen if you have multiple versions of DataStore installed. Please see https://docs.amplify.aws/lib/troubleshooting/upgrading/q/platform/js/#check-for-duplicate-versions';\n        logger.error(message);\n        throw new Error(message);\n    }\n};\n/**\n * Throws an exception if the schema is using a codegen version that is not supported.\n *\n * Set the supported version by setting majorVersion and minorVersion\n * This functions similar to ^ version range.\n * The tested codegenVersion major version must exactly match the set majorVersion\n * The tested codegenVersion minor version must be gt or equal to the set minorVersion\n * Example: For a min supported version of 5.4.0 set majorVersion = 5 and minorVersion = 4\n *\n * This regex will not work when setting a supported range with minor version\n * of 2 or more digits.\n * i.e. minorVersion = 10 will not work\n * The regex will work for testing a codegenVersion with multi digit minor\n * versions as long as the minimum minorVersion is single digit.\n * i.e. codegenVersion = 5.30.1, majorVersion = 5, minorVersion = 4 PASSES\n *\n * @param codegenVersion schema codegenVersion\n */\nconst checkSchemaCodegenVersion = (codegenVersion) => {\n    const majorVersion = 3;\n    const minorVersion = 2;\n    let isValid = false;\n    try {\n        const versionParts = codegenVersion.split('.');\n        const [major, minor, patch, patchrevision] = versionParts;\n        isValid = Number(major) === majorVersion && Number(minor) >= minorVersion;\n    }\n    catch (err) {\n        console.log(`Error parsing codegen version: ${codegenVersion}\\n${err}`);\n    }\n    if (!isValid) {\n        const message = `Models were generated with an unsupported version of codegen. Codegen artifacts are from ${codegenVersion || 'an unknown version'}, whereas ^${majorVersion}.${minorVersion}.0 is required. ` +\n            \"Update to the latest CLI and run 'amplify codegen models'.\";\n        logger.error(message);\n        throw new Error(message);\n    }\n};\nconst createTypeClasses = namespace => {\n    const classes = {};\n    Object.entries(namespace.models).forEach(([modelName, modelDefinition]) => {\n        const clazz = createModelClass(modelDefinition);\n        classes[modelName] = clazz;\n        modelNamespaceMap.set(clazz, namespace.name);\n    });\n    Object.entries(namespace.nonModels || {}).forEach(([typeName, typeDefinition]) => {\n        const clazz = createNonModelClass(typeDefinition);\n        classes[typeName] = clazz;\n    });\n    return classes;\n};\n/**\n * Collection of instantiated models to allow storage of metadata apart from\n * the model visible to the consuming app -- in case the app doesn't have\n * metadata fields (_version, _deleted, etc.) exposed on the model itself.\n */\nconst instancesMetadata = new WeakSet();\nfunction modelInstanceCreator(modelConstructor, init) {\n    instancesMetadata.add(init);\n    return new modelConstructor(init);\n}\nconst validateModelFields = (modelDefinition) => (k, v) => {\n    const fieldDefinition = modelDefinition.fields[k];\n    if (fieldDefinition !== undefined) {\n        const { type, isRequired, isArrayNullable, name, isArray } = fieldDefinition;\n        const timestamps = isSchemaModelWithAttributes(modelDefinition)\n            ? getTimestampFields(modelDefinition)\n            : {};\n        const isTimestampField = !!timestamps[name];\n        if (((!isArray && isRequired) || (isArray && !isArrayNullable)) &&\n            !isTimestampField &&\n            (v === null || v === undefined)) {\n            throw new Error(`Field ${name} is required`);\n        }\n        if (isSchemaModelWithAttributes(modelDefinition) &&\n            !isIdManaged(modelDefinition)) {\n            const keys = extractPrimaryKeyFieldNames(modelDefinition);\n            if (keys.includes(k) && v === '') {\n                logger.error(errorMessages.idEmptyString, { k, value: v });\n                throw new Error(errorMessages.idEmptyString);\n            }\n        }\n        if (isGraphQLScalarType(type)) {\n            const jsType = GraphQLScalarType.getJSType(type);\n            const validateScalar = GraphQLScalarType.getValidationFunction(type);\n            if (type === 'AWSJSON') {\n                if (typeof v === jsType) {\n                    return;\n                }\n                if (typeof v === 'string') {\n                    try {\n                        JSON.parse(v);\n                        return;\n                    }\n                    catch (error) {\n                        throw new Error(`Field ${name} is an invalid JSON object. ${v}`);\n                    }\n                }\n            }\n            if (isArray) {\n                let errorTypeText = jsType;\n                if (!isRequired) {\n                    errorTypeText = `${jsType} | null | undefined`;\n                }\n                if (!Array.isArray(v) && !isArrayNullable) {\n                    throw new Error(`Field ${name} should be of type [${errorTypeText}], ${typeof v} received. ${v}`);\n                }\n                if (!isNullOrUndefined(v) &&\n                    v.some(e => isNullOrUndefined(e) ? isRequired : typeof e !== jsType)) {\n                    const elemTypes = v\n                        .map(e => (e === null ? 'null' : typeof e))\n                        .join(',');\n                    throw new Error(`All elements in the ${name} array should be of type ${errorTypeText}, [${elemTypes}] received. ${v}`);\n                }\n                if (validateScalar && !isNullOrUndefined(v)) {\n                    const validationStatus = v.map(e => {\n                        if (!isNullOrUndefined(e)) {\n                            return validateScalar(e);\n                        }\n                        else if (isNullOrUndefined(e) && !isRequired) {\n                            return true;\n                        }\n                        else {\n                            return false;\n                        }\n                    });\n                    if (!validationStatus.every(s => s)) {\n                        throw new Error(`All elements in the ${name} array should be of type ${type}, validation failed for one or more elements. ${v}`);\n                    }\n                }\n            }\n            else if (!isRequired && v === undefined) {\n                return;\n            }\n            else if (typeof v !== jsType && v !== null) {\n                throw new Error(`Field ${name} should be of type ${jsType}, ${typeof v} received. ${v}`);\n            }\n            else if (!isNullOrUndefined(v) &&\n                validateScalar &&\n                !validateScalar(v) // TODO: why never, TS ... why ...\n            ) {\n                throw new Error(`Field ${name} should be of type ${type}, validation failed. ${v}`);\n            }\n        }\n        else if (isNonModelFieldType(type)) {\n            // do not check non model fields if undefined or null\n            if (!isNullOrUndefined(v)) {\n                const subNonModelDefinition = schema.namespaces.user.nonModels[type.nonModel];\n                const modelValidator = validateModelFields(subNonModelDefinition);\n                if (isArray) {\n                    let errorTypeText = type.nonModel;\n                    if (!isRequired) {\n                        errorTypeText = `${type.nonModel} | null | undefined`;\n                    }\n                    if (!Array.isArray(v)) {\n                        throw new Error(`Field ${name} should be of type [${errorTypeText}], ${typeof v} received. ${v}`);\n                    }\n                    v.forEach(item => {\n                        if ((isNullOrUndefined(item) && isRequired) ||\n                            (typeof item !== 'object' && typeof item !== 'undefined')) {\n                            throw new Error(`All elements in the ${name} array should be of type ${type.nonModel}, [${typeof item}] received. ${item}`);\n                        }\n                        if (!isNullOrUndefined(item)) {\n                            Object.keys(subNonModelDefinition.fields).forEach(subKey => {\n                                modelValidator(subKey, item[subKey]);\n                            });\n                        }\n                    });\n                }\n                else {\n                    if (typeof v !== 'object') {\n                        throw new Error(`Field ${name} should be of type ${type.nonModel}, ${typeof v} recieved. ${v}`);\n                    }\n                    Object.keys(subNonModelDefinition.fields).forEach(subKey => {\n                        modelValidator(subKey, v[subKey]);\n                    });\n                }\n            }\n        }\n    }\n};\nconst castInstanceType = (modelDefinition, k, v) => {\n    const { isArray, type } = modelDefinition.fields[k] || {};\n    // attempt to parse stringified JSON\n    if (typeof v === 'string' &&\n        (isArray ||\n            type === 'AWSJSON' ||\n            isNonModelFieldType(type) ||\n            isModelFieldType(type))) {\n        try {\n            return JSON.parse(v);\n        }\n        catch {\n            // if JSON is invalid, don't throw and let modelValidator handle it\n        }\n    }\n    // cast from numeric representation of boolean to JS boolean\n    if (typeof v === 'number' && type === 'Boolean') {\n        return Boolean(v);\n    }\n    return v;\n};\n/**\n * Records the patches (as if against an empty object) used to initialize\n * an instance of a Model. This can be used for determining which fields to\n * send to the cloud durnig a CREATE mutation.\n */\nconst initPatches = new WeakMap();\n/**\n * Attempts to apply type-aware, casted field values from a given `init`\n * object to the given `draft`.\n *\n * @param init The initialization object to extract field values from.\n * @param modelDefinition The definition describing the target object shape.\n * @param draft The draft to apply field values to.\n */\nconst initializeInstance = (init, modelDefinition, draft) => {\n    const modelValidator = validateModelFields(modelDefinition);\n    Object.entries(init).forEach(([k, v]) => {\n        const parsedValue = castInstanceType(modelDefinition, k, v);\n        modelValidator(k, parsedValue);\n        draft[k] = parsedValue;\n    });\n};\n/**\n * Updates a draft to standardize its customer-defined fields so that they are\n * consistent with the data as it would look after having been synchronized from\n * Cloud storage.\n *\n * The exceptions to this are:\n *\n * 1. Non-schema/Internal [sync] metadata fields.\n * 2. Cloud-managed fields, which are `null` until set by cloud storage.\n *\n * This function should be expanded if/when deviations between canonical Cloud\n * storage data and locally managed data are found. For now, the known areas\n * that require normalization are:\n *\n * 1. Ensuring all non-metadata fields are *defined*. (I.e., turn `undefined` -> `null`.)\n *\n * @param modelDefinition Definition for the draft. Used to discover all fields.\n * @param draft The instance draft to apply normalizations to.\n */\nconst normalize = (modelDefinition, draft) => {\n    for (const k of Object.keys(modelDefinition.fields)) {\n        if (draft[k] === undefined)\n            draft[k] = null;\n    }\n};\nconst createModelClass = (modelDefinition) => {\n    const clazz = class Model {\n        constructor(init) {\n            // we create a base instance first so we can distinguish which fields were explicitly\n            // set by customer code versus those set by normalization. only those fields\n            // which are explicitly set by customers should be part of create mutations.\n            let patches = [];\n            const baseInstance = produce(this, (draft) => {\n                initializeInstance(init, modelDefinition, draft);\n                // model is initialized inside a DataStore component (e.g. by Sync Engine, Storage Engine, etc.)\n                const isInternallyInitialized = instancesMetadata.has(init);\n                const modelInstanceMetadata = isInternallyInitialized\n                    ? init\n                    : {};\n                const { id: _id } = modelInstanceMetadata;\n                if (isIdManaged(modelDefinition)) {\n                    const isInternalModel = _id !== null && _id !== undefined;\n                    const id = isInternalModel\n                        ? _id\n                        : modelDefinition.syncable\n                            ? amplifyUuid()\n                            : ulid();\n                    draft.id = id;\n                }\n                else if (isIdOptionallyManaged(modelDefinition)) {\n                    // only auto-populate if the id was not provided\n                    draft.id =\n                        draft.id || amplifyUuid();\n                }\n                if (!isInternallyInitialized) {\n                    checkReadOnlyPropertyOnCreate(draft, modelDefinition);\n                }\n                const { _version, _lastChangedAt, _deleted } = modelInstanceMetadata;\n                if (modelDefinition.syncable) {\n                    draft._version = _version;\n                    draft._lastChangedAt = _lastChangedAt;\n                    draft._deleted = _deleted;\n                }\n            }, p => (patches = p));\n            // now that we have a list of patches that encapsulate the explicit, customer-provided\n            // fields, we can normalize. patches from normalization are ignored, because the changes\n            // are only create to provide a consistent view of the data for fields pre/post sync\n            // where possible. (not all fields can be normalized pre-sync, because they're generally\n            // \"cloud managed\" fields, like createdAt and updatedAt.)\n            const normalized = produce(baseInstance, (draft) => normalize(modelDefinition, draft));\n            initPatches.set(normalized, patches);\n            return normalized;\n        }\n        static copyOf(source, fn) {\n            const modelConstructor = Object.getPrototypeOf(source || {}).constructor;\n            if (!isValidModelConstructor(modelConstructor)) {\n                const msg = 'The source object is not a valid model';\n                logger.error(msg, { source });\n                throw new Error(msg);\n            }\n            let patches = [];\n            const model = produce(source, draft => {\n                fn(draft);\n                const keyNames = extractPrimaryKeyFieldNames(modelDefinition);\n                // Keys are immutable\n                keyNames.forEach(key => {\n                    if (draft[key] !== source[key]) {\n                        logger.warn(`copyOf() does not update PK fields. The '${key}' update is being ignored.`, { source });\n                    }\n                    draft[key] = source[key];\n                });\n                const modelValidator = validateModelFields(modelDefinition);\n                Object.entries(draft).forEach(([k, v]) => {\n                    const parsedValue = castInstanceType(modelDefinition, k, v);\n                    modelValidator(k, parsedValue);\n                });\n                normalize(modelDefinition, draft);\n            }, p => (patches = p));\n            const hasExistingPatches = modelPatchesMap.has(source);\n            if (patches.length || hasExistingPatches) {\n                if (hasExistingPatches) {\n                    const [existingPatches, existingSource] = modelPatchesMap.get(source);\n                    const mergedPatches = mergePatches(existingSource, existingPatches, patches);\n                    modelPatchesMap.set(model, [mergedPatches, existingSource]);\n                    checkReadOnlyPropertyOnUpdate(mergedPatches, modelDefinition);\n                }\n                else {\n                    modelPatchesMap.set(model, [patches, source]);\n                    checkReadOnlyPropertyOnUpdate(patches, modelDefinition);\n                }\n            }\n            else {\n                // always register patches when performing a copyOf, even if the\n                // patches list is empty. this allows `save()` to recognize when an\n                // instance is the result of a `copyOf()`. without more significant\n                // refactoring, this is the only way for `save()` to know which\n                // diffs (patches) are relevant for `storage` to use in building\n                // the list of \"changed\" fields for mutations.\n                modelPatchesMap.set(model, [[], source]);\n            }\n            return attached(model, ModelAttachment.DataStore);\n        }\n        // \"private\" method (that's hidden via `Setting`) for `withSSRContext` to use\n        // to gain access to `modelInstanceCreator` and `clazz` for persisting IDs from server to client.\n        static fromJSON(json) {\n            if (Array.isArray(json)) {\n                return json.map(init => this.fromJSON(init));\n            }\n            const instance = modelInstanceCreator(clazz, json);\n            const modelValidator = validateModelFields(modelDefinition);\n            Object.entries(instance).forEach(([k, v]) => {\n                modelValidator(k, v);\n            });\n            return attached(instance, ModelAttachment.DataStore);\n        }\n    };\n    clazz[immerable] = true;\n    Object.defineProperty(clazz, 'name', { value: modelDefinition.name });\n    // Add getters/setters for relationship fields.\n    //  getter - for lazy loading\n    //  setter - for FK management\n    const allModelRelationships = ModelRelationship.allFrom({\n        builder: clazz,\n        schema: modelDefinition,\n        pkField: extractPrimaryKeyFieldNames(modelDefinition),\n    });\n    for (const relationship of allModelRelationships) {\n        const field = relationship.field;\n        Object.defineProperty(clazz.prototype, modelDefinition.fields[field].name, {\n            set(model) {\n                if (!(typeof model === 'object' || typeof model === 'undefined'))\n                    return;\n                // if model is undefined or null, the connection should be removed\n                if (model) {\n                    // Avoid validation error when processing AppSync response with nested\n                    // selection set. Nested entitites lack version field and can not be validated\n                    // TODO: explore a more reliable method to solve this\n                    if (model.hasOwnProperty('_version')) {\n                        const modelConstructor = Object.getPrototypeOf(model || {})\n                            .constructor;\n                        if (!isValidModelConstructor(modelConstructor)) {\n                            const msg = `Value passed to ${modelDefinition.name}.${field} is not a valid instance of a model`;\n                            logger.error(msg, { model });\n                            throw new Error(msg);\n                        }\n                        if (modelConstructor.name.toLowerCase() !==\n                            relationship.remoteModelConstructor.name.toLowerCase()) {\n                            const msg = `Value passed to ${modelDefinition.name}.${field} is not an instance of ${relationship.remoteModelConstructor.name}`;\n                            logger.error(msg, { model });\n                            throw new Error(msg);\n                        }\n                    }\n                }\n                // if the relationship can be managed automagically, set the FK's\n                if (relationship.isComplete) {\n                    for (let i = 0; i < relationship.localJoinFields.length; i++) {\n                        this[relationship.localJoinFields[i]] =\n                            model?.[relationship.remoteJoinFields[i]];\n                    }\n                    const instanceMemos = modelInstanceAssociationsMap.has(this)\n                        ? modelInstanceAssociationsMap.get(this)\n                        : modelInstanceAssociationsMap.set(this, {}).get(this);\n                    instanceMemos[field] = model || undefined;\n                }\n            },\n            get() {\n                /**\n                 * Bucket for holding related models instances specific to `this` instance.\n                 */\n                const instanceMemos = modelInstanceAssociationsMap.has(this)\n                    ? modelInstanceAssociationsMap.get(this)\n                    : modelInstanceAssociationsMap.set(this, {}).get(this);\n                // if the memos already has a result for this field, we'll use it.\n                // there is no \"cache\" invalidation of any kind; memos are permanent to\n                // keep an immutable perception of the instance.\n                if (!instanceMemos.hasOwnProperty(field)) {\n                    // before we populate the memo, we need to know where to look for relatives.\n                    // today, this only supports DataStore. Models aren't managed elsewhere in Amplify.\n                    if (getAttachment(this) === ModelAttachment.DataStore) {\n                        // when we fetch the results using a query constructed under the guidance\n                        // of the relationship metadata, we DO NOT AWAIT resolution. we want to\n                        // drop the promise into the memo's synchronously, eliminating the chance\n                        // for a race.\n                        const resultPromise = instance.query(relationship.remoteModelConstructor, base => base.and(q => {\n                            return relationship.remoteJoinFields.map((field, index) => {\n                                // TODO: anything we can use instead of `any` here?\n                                return q[field].eq(this[relationship.localJoinFields[index]]);\n                            });\n                        }));\n                        // results in hand, how we return them to the caller depends on the relationship type.\n                        if (relationship.type === 'HAS_MANY') {\n                            // collections should support async iteration, even though we don't\n                            // leverage it fully [yet].\n                            instanceMemos[field] = new AsyncCollection(resultPromise);\n                        }\n                        else {\n                            // non-collections should only ever return 1 value *or nothing*.\n                            // if we have more than 1 record, something's amiss. it's not our job\n                            // pick a result for the customer. it's our job to say \"something's wrong.\"\n                            instanceMemos[field] = resultPromise.then(rows => {\n                                if (rows.length > 1) {\n                                    // should never happen for a HAS_ONE or BELONGS_TO.\n                                    const err = new Error(`\n\t\t\t\t\t\t\t\t\tData integrity error.\n\t\t\t\t\t\t\t\t\tToo many records found for a HAS_ONE/BELONGS_TO field '${modelDefinition.name}.${field}'\n\t\t\t\t\t\t\t\t`);\n                                    console.error(err);\n                                    throw err;\n                                }\n                                else {\n                                    return rows[0];\n                                }\n                            });\n                        }\n                    }\n                    else if (getAttachment(this) === ModelAttachment.API) {\n                        throw new Error('Lazy loading from API is not yet supported!');\n                    }\n                    else {\n                        if (relationship.type === 'HAS_MANY') {\n                            return new AsyncCollection([]);\n                        }\n                        else {\n                            return Promise.resolve(undefined);\n                        }\n                    }\n                }\n                return instanceMemos[field];\n            },\n        });\n    }\n    return clazz;\n};\n/**\n * An eventually loaded related model instance.\n */\nexport class AsyncItem extends Promise {\n}\n/**\n * A collection of related model instances.\n *\n * This collection can be async-iterated or turned directly into an array using `toArray()`.\n */\nexport class AsyncCollection {\n    constructor(values) {\n        this.values = values;\n    }\n    /**\n     * Facilitates async iteration.\n     *\n     * ```ts\n     * for await (const item of collection) {\n     *   handle(item)\n     * }\n     * ```\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\n     */\n    [Symbol.asyncIterator]() {\n        let values;\n        let index = 0;\n        return {\n            next: async () => {\n                if (!values)\n                    values = await this.values;\n                if (index < values.length) {\n                    const result = {\n                        value: values[index],\n                        done: false,\n                    };\n                    index++;\n                    return result;\n                }\n                return {\n                    value: null,\n                    done: true,\n                };\n            },\n        };\n    }\n    /**\n     * Turns the collection into an array, up to the amount specified in `max` param.\n     *\n     * ```ts\n     * const all = await collection.toArray();\n     * const first100 = await collection.toArray({max: 100});\n     * ```\n     */\n    async toArray({ max = Number.MAX_SAFE_INTEGER, } = {}) {\n        const output = [];\n        let i = 0;\n        for await (const element of this) {\n            if (i < max) {\n                output.push(element);\n                i++;\n            }\n            else {\n                break;\n            }\n        }\n        return output;\n    }\n}\nconst checkReadOnlyPropertyOnCreate = (draft, modelDefinition) => {\n    const modelKeys = Object.keys(draft);\n    const { fields } = modelDefinition;\n    modelKeys.forEach(key => {\n        if (fields[key] && fields[key].isReadOnly) {\n            throw new Error(`${key} is read-only.`);\n        }\n    });\n};\nconst checkReadOnlyPropertyOnUpdate = (patches, modelDefinition) => {\n    const patchArray = patches.map(p => [p.path[0], p.value]);\n    const { fields } = modelDefinition;\n    patchArray.forEach(([key, val]) => {\n        if (!val || !fields[key])\n            return;\n        if (fields[key].isReadOnly) {\n            throw new Error(`${key} is read-only.`);\n        }\n    });\n};\nconst createNonModelClass = (typeDefinition) => {\n    const clazz = class Model {\n        constructor(init) {\n            const instance = produce(this, (draft) => {\n                initializeInstance(init, typeDefinition, draft);\n            });\n            return instance;\n        }\n    };\n    clazz[immerable] = true;\n    Object.defineProperty(clazz, 'name', { value: typeDefinition.name });\n    registerNonModelClass(clazz);\n    return clazz;\n};\nfunction isQueryOne(obj) {\n    return typeof obj === 'string';\n}\nfunction defaultConflictHandler(conflictData) {\n    const { localModel, modelConstructor, remoteModel } = conflictData;\n    const { _version } = remoteModel;\n    return modelInstanceCreator(modelConstructor, { ...localModel, _version });\n}\nfunction defaultErrorHandler(error) {\n    logger.warn(error);\n}\nfunction getModelConstructorByModelName(namespaceName, modelName) {\n    let result;\n    switch (namespaceName) {\n        case DATASTORE:\n            result = dataStoreClasses[modelName];\n            break;\n        case USER:\n            result = userClasses[modelName];\n            break;\n        case SYNC:\n            result = syncClasses[modelName];\n            break;\n        case STORAGE:\n            result = storageClasses[modelName];\n            break;\n        default:\n            throw new Error(`Invalid namespace: ${namespaceName}`);\n    }\n    if (isValidModelConstructor(result)) {\n        return result;\n    }\n    else {\n        const msg = `Model name is not valid for namespace. modelName: ${modelName}, namespace: ${namespaceName}`;\n        logger.error(msg);\n        throw new Error(msg);\n    }\n}\n/**\n * Queries the DataStore metadata tables to see if they are the expected\n * version. If not, clobbers the whole DB. If so, leaves them alone.\n * Otherwise, simply writes the schema version.\n *\n * SIDE EFFECT:\n * 1. Creates a transaction\n * 1. Updates data.\n *\n * @param storage Storage adapter containing the metadata.\n * @param version The expected schema version.\n */\nasync function checkSchemaVersion(storage, version) {\n    const Setting = dataStoreClasses.Setting;\n    const modelDefinition = schema.namespaces[DATASTORE].models.Setting;\n    await storage.runExclusive(async (s) => {\n        const [schemaVersionSetting] = await s.query(Setting, ModelPredicateCreator.createFromAST(modelDefinition, {\n            and: { key: { eq: SETTING_SCHEMA_VERSION } },\n        }), { page: 0, limit: 1 });\n        if (schemaVersionSetting !== undefined &&\n            schemaVersionSetting.value !== undefined) {\n            const storedValue = JSON.parse(schemaVersionSetting.value);\n            if (storedValue !== version) {\n                await s.clear(false);\n            }\n        }\n        else {\n            await s.save(modelInstanceCreator(Setting, {\n                key: SETTING_SCHEMA_VERSION,\n                value: JSON.stringify(version),\n            }));\n        }\n    });\n}\nlet syncSubscription;\nfunction getNamespace() {\n    const namespace = {\n        name: DATASTORE,\n        relationships: {},\n        enums: {},\n        nonModels: {},\n        models: {\n            Setting: {\n                name: 'Setting',\n                pluralName: 'Settings',\n                syncable: false,\n                fields: {\n                    id: {\n                        name: 'id',\n                        type: 'ID',\n                        isRequired: true,\n                        isArray: false,\n                    },\n                    key: {\n                        name: 'key',\n                        type: 'String',\n                        isRequired: true,\n                        isArray: false,\n                    },\n                    value: {\n                        name: 'value',\n                        type: 'String',\n                        isRequired: true,\n                        isArray: false,\n                    },\n                },\n            },\n        },\n    };\n    return namespace;\n}\nvar DataStoreState;\n(function (DataStoreState) {\n    DataStoreState[\"NotRunning\"] = \"Not Running\";\n    DataStoreState[\"Starting\"] = \"Starting\";\n    DataStoreState[\"Running\"] = \"Running\";\n    DataStoreState[\"Stopping\"] = \"Stopping\";\n    DataStoreState[\"Clearing\"] = \"Clearing\";\n})(DataStoreState || (DataStoreState = {}));\n// TODO: How can we get rid of the non-null assertions?\n// https://github.com/aws-amplify/amplify-js/pull/10477/files#r1007363485\nclass DataStore {\n    constructor() {\n        // reference to configured category instances. Used for preserving SSR context\n        this.InternalAPI = InternalAPI;\n        this.Cache = Cache;\n        // Non-null assertions (bang operator) have been added to most of these properties\n        // to make TS happy. These properties are all expected to be set immediately after\n        // construction.\n        // TODO: Refactor to use proper DI if possible. If not possible, change these to\n        // optionals and implement conditional checks throughout. Rinse/repeat on all\n        // sync engine processors, storage engine, adapters, etc..\n        this.amplifyConfig = {};\n        this.syncPredicates = new WeakMap();\n        // object that gets passed to descendent classes. Allows us to pass these down by reference\n        this.amplifyContext = {\n            InternalAPI: this.InternalAPI,\n        };\n        /**\n         * **IMPORTANT!**\n         *\n         * Accumulator for background things that can **and MUST** be called when\n         * DataStore stops.\n         *\n         * These jobs **MUST** be *idempotent promises* that resolve ONLY\n         * once the intended jobs are completely finished and/or otherwise destroyed\n         * and cleaned up with ZERO outstanding:\n         *\n         * 1. side effects (e.g., state changes)\n         * 1. callbacks\n         * 1. subscriptions\n         * 1. calls to storage\n         * 1. *etc.*\n         *\n         * Methods that create pending promises, subscriptions, callbacks, or any\n         * type of side effect **MUST** be registered with the manager. And, a new\n         * manager must be created after each `exit()`.\n         *\n         * Failure to comply will put DataStore into a highly unpredictable state\n         * when it needs to stop or clear -- which occurs when restarting with new\n         * sync expressions, during testing, and potentially during app code\n         * recovery handling, etc..\n         *\n         * It is up to the discretion of each disposer whether to wait for job\n         * completion or to cancel operations and issue failures *as long as the\n         * disposer returns in a reasonable amount of time.*\n         *\n         * (Reasonable = *seconds*, not minutes.)\n         */\n        this.runningProcesses = new BackgroundProcessManager();\n        /**\n         * Indicates what state DataStore is in.\n         *\n         * Not [yet?] used for actual state management; but for messaging\n         * when errors occur, to help troubleshoot.\n         */\n        this.state = DataStoreState.NotRunning;\n        /**\n         * If not already done:\n         * 1. Attaches and initializes storage.\n         * 2. Loads the schema and records metadata.\n         * 3. If `this.amplifyConfig.aws_appsync_graphqlEndpoint` contains a URL,\n         * attaches a sync engine, starts it, and subscribes.\n         */\n        this.start = async () => {\n            return this.runningProcesses\n                .add(async () => {\n                this.state = DataStoreState.Starting;\n                if (this.initialized === undefined) {\n                    logger.debug('Starting DataStore');\n                    this.initialized = new Promise((res, rej) => {\n                        this.initResolve = res;\n                        this.initReject = rej;\n                    });\n                }\n                else {\n                    await this.initialized;\n                    return;\n                }\n                this.storage = new Storage(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, this.storageAdapter, this.sessionId);\n                await this.storage.init();\n                checkSchemaInitialized();\n                await checkSchemaVersion(this.storage, schema.version);\n                const { aws_appsync_graphqlEndpoint } = this.amplifyConfig;\n                if (aws_appsync_graphqlEndpoint) {\n                    logger.debug('GraphQL endpoint available', aws_appsync_graphqlEndpoint);\n                    this.syncPredicates = await this.processSyncExpressions();\n                    this.sync = new SyncEngine(schema, namespaceResolver, syncClasses, userClasses, this.storage, modelInstanceCreator, this.conflictHandler, this.errorHandler, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, this.amplifyContext, this.connectivityMonitor);\n                    const fullSyncIntervalInMilliseconds = this.fullSyncInterval * 1000 * 60; // fullSyncInterval from param is in minutes\n                    syncSubscription = this.sync\n                        .start({ fullSyncInterval: fullSyncIntervalInMilliseconds })\n                        .subscribe({\n                        next: ({ type, data }) => {\n                            /**\n                             * In Node, we need to wait for queries to be synced to prevent returning empty arrays.\n                             * In non-Node environments (the browser or React Native), we can begin returning data\n                             * once subscriptions are in place.\n                             */\n                            const readyType = isNode()\n                                ? ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY\n                                : ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED;\n                            if (type === readyType) {\n                                this.initResolve();\n                            }\n                            Hub.dispatch('datastore', {\n                                event: type,\n                                data,\n                            });\n                        },\n                        error: err => {\n                            logger.warn('Sync error', err);\n                            this.initReject();\n                        },\n                    });\n                }\n                else {\n                    logger.warn(\"Data won't be synchronized. No GraphQL endpoint configured. Did you forget `Amplify.configure(awsconfig)`?\", {\n                        config: this.amplifyConfig,\n                    });\n                    this.initResolve();\n                }\n                await this.initialized;\n                this.state = DataStoreState.Running;\n            }, 'datastore start')\n                .catch(this.handleAddProcError('DataStore.start()'));\n        };\n        this.query = async (modelConstructor, identifierOrCriteria, paginationProducer) => {\n            return this.runningProcesses\n                .add(async () => {\n                await this.start();\n                let result;\n                if (!this.storage) {\n                    throw new Error('No storage to query');\n                }\n                //#region Input validation\n                if (!isValidModelConstructor(modelConstructor)) {\n                    const msg = 'Constructor is not for a valid model';\n                    logger.error(msg, { modelConstructor });\n                    throw new Error(msg);\n                }\n                if (typeof identifierOrCriteria === 'string') {\n                    if (paginationProducer !== undefined) {\n                        logger.warn('Pagination is ignored when querying by id');\n                    }\n                }\n                const modelDefinition = getModelDefinition(modelConstructor);\n                if (!modelDefinition) {\n                    throw new Error('Invalid model definition provided!');\n                }\n                const pagination = this.processPagination(modelDefinition, paginationProducer);\n                const keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n                if (isQueryOne(identifierOrCriteria)) {\n                    if (keyFields.length > 1) {\n                        const msg = errorMessages.queryByPkWithCompositeKeyPresent;\n                        logger.error(msg, { keyFields });\n                        throw new Error(msg);\n                    }\n                    const predicate = ModelPredicateCreator.createFromFlatEqualities(modelDefinition, { [keyFields[0]]: identifierOrCriteria });\n                    result = await this.storage.query(modelConstructor, predicate, pagination);\n                }\n                else {\n                    // Object is being queried using object literal syntax\n                    if (isIdentifierObject(identifierOrCriteria, modelDefinition)) {\n                        const predicate = ModelPredicateCreator.createForPk(modelDefinition, identifierOrCriteria);\n                        result = await this.storage.query(modelConstructor, predicate, pagination);\n                    }\n                    else if (!identifierOrCriteria ||\n                        isPredicatesAll(identifierOrCriteria)) {\n                        result = await this.storage?.query(modelConstructor, undefined, pagination);\n                    }\n                    else {\n                        const seedPredicate = recursivePredicateFor({\n                            builder: modelConstructor,\n                            schema: modelDefinition,\n                            pkField: extractPrimaryKeyFieldNames(modelDefinition),\n                        });\n                        const predicate = internals(identifierOrCriteria(seedPredicate));\n                        result = (await predicate.fetch(this.storage));\n                        result = inMemoryPagination(result, pagination);\n                    }\n                }\n                //#endregion\n                const returnOne = isQueryOne(identifierOrCriteria) ||\n                    isIdentifierObject(identifierOrCriteria, modelDefinition);\n                return attached(returnOne ? result[0] : result, ModelAttachment.DataStore);\n            }, 'datastore query')\n                .catch(this.handleAddProcError('DataStore.query()'));\n        };\n        this.save = async (model, condition) => {\n            return this.runningProcesses\n                .add(async () => {\n                await this.start();\n                if (!this.storage) {\n                    throw new Error('No storage to save to');\n                }\n                // Immer patches for constructing a correct update mutation input\n                // Allows us to only include changed fields for updates\n                const updatedPatchesTuple = modelPatchesMap.get(model);\n                // Immer patches for initial object construction. These are used if\n                // there are no `update` patches under the assumption we're performing\n                // a CREATE and wish to send only explicitly specified fields to the cloud.\n                const initPatchesTuple = initPatches.has(model)\n                    ? [initPatches.get(model), {}]\n                    : undefined;\n                // favor update patches over init/create patches, because init patches\n                // are ALWAYS present, whereas update patches are only present if copyOf\n                // was used to create the instance.\n                const patchesTuple = updatedPatchesTuple || initPatchesTuple;\n                const modelConstructor = model ? model.constructor : undefined;\n                if (!isValidModelConstructor(modelConstructor)) {\n                    const msg = 'Object is not an instance of a valid model';\n                    logger.error(msg, { model });\n                    throw new Error(msg);\n                }\n                const modelDefinition = getModelDefinition(modelConstructor);\n                if (!modelDefinition) {\n                    throw new Error('Model Definition could not be found for model');\n                }\n                const modelMeta = {\n                    builder: modelConstructor,\n                    schema: modelDefinition,\n                    pkField: extractPrimaryKeyFieldNames(modelDefinition),\n                };\n                await this.storage.runExclusive(async (s) => {\n                    // no enforcement for HAS_MANY on save, because the ~related~ entities\n                    // hold the FK in that case.\n                    const nonHasManyRelationships = ModelRelationship.allFrom(modelMeta).filter(r => r.type === 'BELONGS_TO');\n                    for (const relationship of nonHasManyRelationships) {\n                        const queryObject = relationship.createRemoteQueryObject(model);\n                        if (queryObject !== null) {\n                            const related = await s.query(relationship.remoteModelConstructor, ModelPredicateCreator.createFromFlatEqualities(relationship.remoteDefinition, queryObject));\n                            if (related.length === 0) {\n                                throw new Error([\n                                    `Data integrity error. You tried to save a ${modelDefinition.name} (${JSON.stringify(model)})`,\n                                    `but the instance assigned to the \"${relationship.field}\" property`,\n                                    `does not exist in the local database. If you're trying to create the related`,\n                                    `\"${relationship.remoteDefinition?.name}\", you must save it independently first.`,\n                                ].join(' '));\n                            }\n                        }\n                    }\n                });\n                const producedCondition = condition\n                    ? internals(condition(predicateFor(modelMeta))).toStoragePredicate()\n                    : undefined;\n                const [savedModel] = await this.storage.runExclusive(async (s) => {\n                    const saved = await s.save(model, producedCondition, undefined, patchesTuple);\n                    return s.query(modelConstructor, ModelPredicateCreator.createForPk(modelDefinition, model));\n                });\n                return attached(savedModel, ModelAttachment.DataStore);\n            }, 'datastore save')\n                .catch(this.handleAddProcError('DataStore.save()'));\n        };\n        this.setConflictHandler = (config) => {\n            const { DataStore: configDataStore } = config;\n            const conflictHandlerIsDefault = () => this.conflictHandler === defaultConflictHandler;\n            if (configDataStore && configDataStore.conflictHandler) {\n                return configDataStore.conflictHandler;\n            }\n            if (conflictHandlerIsDefault() && config.conflictHandler) {\n                return config.conflictHandler;\n            }\n            return this.conflictHandler || defaultConflictHandler;\n        };\n        this.setErrorHandler = (config) => {\n            const { DataStore: configDataStore } = config;\n            const errorHandlerIsDefault = () => this.errorHandler === defaultErrorHandler;\n            if (configDataStore && configDataStore.errorHandler) {\n                return configDataStore.errorHandler;\n            }\n            if (errorHandlerIsDefault() && config.errorHandler) {\n                return config.errorHandler;\n            }\n            return this.errorHandler || defaultErrorHandler;\n        };\n        this.delete = async (modelOrConstructor, identifierOrCriteria) => {\n            return this.runningProcesses\n                .add(async () => {\n                await this.start();\n                if (!this.storage) {\n                    throw new Error('No storage to delete from');\n                }\n                let condition;\n                if (!modelOrConstructor) {\n                    const msg = 'Model or Model Constructor required';\n                    logger.error(msg, { modelOrConstructor });\n                    throw new Error(msg);\n                }\n                if (isValidModelConstructor(modelOrConstructor)) {\n                    const modelConstructor = modelOrConstructor;\n                    if (!identifierOrCriteria) {\n                        const msg = 'Id to delete or criteria required. Do you want to delete all? Pass Predicates.ALL';\n                        logger.error(msg, { identifierOrCriteria });\n                        throw new Error(msg);\n                    }\n                    const modelDefinition = getModelDefinition(modelConstructor);\n                    if (!modelDefinition) {\n                        throw new Error('Could not find model definition for modelConstructor.');\n                    }\n                    if (typeof identifierOrCriteria === 'string') {\n                        const keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n                        if (keyFields.length > 1) {\n                            const msg = errorMessages.deleteByPkWithCompositeKeyPresent;\n                            logger.error(msg, { keyFields });\n                            throw new Error(msg);\n                        }\n                        condition = ModelPredicateCreator.createFromFlatEqualities(modelDefinition, { [keyFields[0]]: identifierOrCriteria });\n                    }\n                    else {\n                        if (isIdentifierObject(identifierOrCriteria, modelDefinition)) {\n                            condition = ModelPredicateCreator.createForPk(modelDefinition, identifierOrCriteria);\n                        }\n                        else {\n                            condition = internals(identifierOrCriteria(predicateFor({\n                                builder: modelConstructor,\n                                schema: modelDefinition,\n                                pkField: extractPrimaryKeyFieldNames(modelDefinition),\n                            }))).toStoragePredicate();\n                        }\n                        if (!condition ||\n                            !ModelPredicateCreator.isValidPredicate(condition)) {\n                            const msg = 'Criteria required. Do you want to delete all? Pass Predicates.ALL';\n                            logger.error(msg, { condition });\n                            throw new Error(msg);\n                        }\n                    }\n                    const [deleted] = await this.storage.delete(modelConstructor, condition);\n                    return attached(deleted, ModelAttachment.DataStore);\n                }\n                else {\n                    const model = modelOrConstructor;\n                    const modelConstructor = Object.getPrototypeOf(model || {})\n                        .constructor;\n                    if (!isValidModelConstructor(modelConstructor)) {\n                        const msg = 'Object is not an instance of a valid model';\n                        logger.error(msg, { model });\n                        throw new Error(msg);\n                    }\n                    const modelDefinition = getModelDefinition(modelConstructor);\n                    if (!modelDefinition) {\n                        throw new Error('Could not find model definition for modelConstructor.');\n                    }\n                    const pkPredicate = ModelPredicateCreator.createForPk(modelDefinition, model);\n                    if (identifierOrCriteria) {\n                        if (typeof identifierOrCriteria !== 'function') {\n                            const msg = 'Invalid criteria';\n                            logger.error(msg, { identifierOrCriteria });\n                            throw new Error(msg);\n                        }\n                        condition = internals(identifierOrCriteria(predicateFor({\n                            builder: modelConstructor,\n                            schema: modelDefinition,\n                            pkField: extractPrimaryKeyFieldNames(modelDefinition),\n                        }))).toStoragePredicate();\n                    }\n                    else {\n                        condition = pkPredicate;\n                    }\n                    const [[deleted]] = await this.storage.delete(model, condition);\n                    return attached(deleted, ModelAttachment.DataStore);\n                }\n            }, 'datastore delete')\n                .catch(this.handleAddProcError('DataStore.delete()'));\n        };\n        this.observe = (modelOrConstructor, identifierOrCriteria) => {\n            let executivePredicate;\n            const modelConstructor = modelOrConstructor && isValidModelConstructor(modelOrConstructor)\n                ? modelOrConstructor\n                : undefined;\n            if (modelOrConstructor && modelConstructor === undefined) {\n                const model = modelOrConstructor;\n                const modelConstructor = model && Object.getPrototypeOf(model).constructor;\n                if (isValidModelConstructor(modelConstructor)) {\n                    if (identifierOrCriteria) {\n                        logger.warn('idOrCriteria is ignored when using a model instance', {\n                            model,\n                            identifierOrCriteria,\n                        });\n                    }\n                    return this.observe(modelConstructor, model.id);\n                }\n                else {\n                    const msg = 'The model is not an instance of a PersistentModelConstructor';\n                    logger.error(msg, { model });\n                    throw new Error(msg);\n                }\n            }\n            // observe should not accept object literal syntax\n            if (identifierOrCriteria &&\n                modelConstructor &&\n                isIdentifierObject(identifierOrCriteria, getModelDefinition(modelConstructor))) {\n                const msg = errorMessages.observeWithObjectLiteral;\n                logger.error(msg, { objectLiteral: identifierOrCriteria });\n                throw new Error(msg);\n            }\n            if (identifierOrCriteria !== undefined && modelConstructor === undefined) {\n                const msg = 'Cannot provide criteria without a modelConstructor';\n                logger.error(msg, identifierOrCriteria);\n                throw new Error(msg);\n            }\n            if (modelConstructor && !isValidModelConstructor(modelConstructor)) {\n                const msg = 'Constructor is not for a valid model';\n                logger.error(msg, { modelConstructor });\n                throw new Error(msg);\n            }\n            if (modelConstructor && typeof identifierOrCriteria === 'string') {\n                const buildIdPredicate = seed => seed.id.eq(identifierOrCriteria);\n                executivePredicate = internals(buildIdPredicate(buildSeedPredicate(modelConstructor)));\n            }\n            else if (modelConstructor && typeof identifierOrCriteria === 'function') {\n                executivePredicate = internals(identifierOrCriteria(buildSeedPredicate(modelConstructor)));\n            }\n            return new Observable(observer => {\n                let source;\n                this.runningProcesses\n                    .add(async () => {\n                    await this.start();\n                    // Filter the events returned by Storage according to namespace,\n                    // append original element data, and subscribe to the observable\n                    source = this.storage.observe(modelConstructor)\n                        .pipe(filter(({ model }) => namespaceResolver(model) === USER))\n                        .subscribe({\n                        next: item => this.runningProcesses.isOpen &&\n                            this.runningProcesses.add(async () => {\n                                // the `element` doesn't necessarily contain all item details or\n                                // have related records attached consistently with that of a query()\n                                // result item. for consistency, we attach them here.\n                                let message = item;\n                                // as long as we're not dealing with a DELETE, we need to fetch a fresh\n                                // item from storage to ensure it's fully populated.\n                                if (item.opType !== 'DELETE') {\n                                    const modelDefinition = getModelDefinition(item.model);\n                                    const keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n                                    const primaryKeysAndValues = extractPrimaryKeysAndValues(item.element, keyFields);\n                                    const freshElement = await this.query(item.model, primaryKeysAndValues);\n                                    message = {\n                                        ...message,\n                                        element: freshElement,\n                                    };\n                                }\n                                if (!executivePredicate ||\n                                    (await executivePredicate.matches(message.element))) {\n                                    observer.next(message);\n                                }\n                            }, 'datastore observe message handler'),\n                        error: err => observer.error(err),\n                        complete: () => observer.complete(),\n                    });\n                }, 'datastore observe observable initialization')\n                    .catch(this.handleAddProcError('DataStore.observe()'))\n                    .catch(error => {\n                    observer.error(error);\n                });\n                // better than no cleaner, but if the subscriber is handling the\n                // complete() message async and not registering with the context,\n                // this will still be problematic.\n                return this.runningProcesses.addCleaner(async () => {\n                    if (source) {\n                        source.unsubscribe();\n                    }\n                }, 'DataStore.observe() cleanup');\n            });\n        };\n        this.observeQuery = (model, criteria, options) => {\n            return new Observable(observer => {\n                const items = new Map();\n                const itemsChanged = new Map();\n                let deletedItemIds = [];\n                let handle;\n                // let predicate: ModelPredicate<T> | undefined;\n                let executivePredicate;\n                /**\n                 * As the name suggests, this geneates a snapshot in the form of\n                 * \t`{items: T[], isSynced: boolean}`\n                 * and sends it to the observer.\n                 *\n                 * SIDE EFFECT: The underlying generation and emission methods may touch:\n                 * `items`, `itemsChanged`, and `deletedItemIds`.\n                 *\n                 * Refer to `generateSnapshot` and `emitSnapshot` for more details.\n                 */\n                const generateAndEmitSnapshot = () => {\n                    const snapshot = generateSnapshot();\n                    emitSnapshot(snapshot);\n                };\n                // a mechanism to return data after X amount of seconds OR after the\n                // \"limit\" (itemsChanged >= this.syncPageSize) has been reached, whichever comes first\n                const limitTimerRace = new DeferredCallbackResolver({\n                    callback: generateAndEmitSnapshot,\n                    errorHandler: observer.error,\n                    maxInterval: 2000,\n                });\n                const { sort } = options || {};\n                const sortOptions = sort ? { sort } : undefined;\n                const modelDefinition = getModelDefinition(model);\n                if (!modelDefinition) {\n                    throw new Error('Could not find model definition.');\n                }\n                if (model && typeof criteria === 'function') {\n                    executivePredicate = internals(criteria(buildSeedPredicate(model)));\n                }\n                else if (isPredicatesAll(criteria)) {\n                    executivePredicate = undefined;\n                }\n                this.runningProcesses\n                    .add(async () => {\n                    try {\n                        // first, query and return any locally-available records\n                        (await this.query(model, criteria, sortOptions)).forEach(item => {\n                            const itemModelDefinition = getModelDefinition(model);\n                            const idOrPk = getIdentifierValue(itemModelDefinition, item);\n                            items.set(idOrPk, item);\n                        });\n                        // Observe the model and send a stream of updates (debounced).\n                        // We need to post-filter results instead of passing criteria through\n                        // to have visibility into items that move from in-set to out-of-set.\n                        // We need to explicitly remove those items from the existing snapshot.\n                        handle = this.observe(model).subscribe(({ element, model, opType }) => this.runningProcesses.isOpen &&\n                            this.runningProcesses.add(async () => {\n                                const itemModelDefinition = getModelDefinition(model);\n                                const idOrPk = getIdentifierValue(itemModelDefinition, element);\n                                if (executivePredicate &&\n                                    !(await executivePredicate.matches(element))) {\n                                    if (opType === 'UPDATE' &&\n                                        (items.has(idOrPk) || itemsChanged.has(idOrPk))) {\n                                        // tracking as a \"deleted item\" will include the item in\n                                        // page limit calculations and ensure it is removed from the\n                                        // final items collection, regardless of which collection(s)\n                                        // it is currently in. (I mean, it could be in both, right!?)\n                                        deletedItemIds.push(idOrPk);\n                                    }\n                                    else {\n                                        // ignore updates for irrelevant/filtered items.\n                                        return;\n                                    }\n                                }\n                                // Flag items which have been recently deleted\n                                // NOTE: Merging of separate operations to the same model instance is handled upstream\n                                // in the `mergePage` method within src/sync/merger.ts. The final state of a model instance\n                                // depends on the LATEST record (for a given id).\n                                if (opType === 'DELETE') {\n                                    deletedItemIds.push(idOrPk);\n                                }\n                                else {\n                                    itemsChanged.set(idOrPk, element);\n                                }\n                                const isSynced = this.sync?.getModelSyncedStatus(model) ?? false;\n                                const limit = itemsChanged.size - deletedItemIds.length >=\n                                    this.syncPageSize;\n                                if (limit || isSynced) {\n                                    limitTimerRace.resolve();\n                                }\n                                // kicks off every subsequent race as results sync down\n                                limitTimerRace.start();\n                            }, 'handle observeQuery observed event'));\n                        // returns a set of initial/locally-available results\n                        generateAndEmitSnapshot();\n                    }\n                    catch (err) {\n                        observer.error(err);\n                    }\n                }, 'datastore observequery startup')\n                    .catch(this.handleAddProcError('DataStore.observeQuery()'))\n                    .catch(error => {\n                    observer.error(error);\n                });\n                /**\n                 * Combines the `items`, `itemsChanged`, and `deletedItemIds` collections into\n                 * a snapshot in the form of `{ items: T[], isSynced: boolean}`.\n                 *\n                 * SIDE EFFECT: The shared `items` collection is recreated.\n                 */\n                const generateSnapshot = () => {\n                    const isSynced = this.sync?.getModelSyncedStatus(model) ?? false;\n                    const itemsArray = [\n                        ...Array.from(items.values()),\n                        ...Array.from(itemsChanged.values()),\n                    ];\n                    items.clear();\n                    itemsArray.forEach(item => {\n                        const itemModelDefinition = getModelDefinition(model);\n                        const idOrPk = getIdentifierValue(itemModelDefinition, item);\n                        items.set(idOrPk, item);\n                    });\n                    // remove deleted items from the final result set\n                    deletedItemIds.forEach(idOrPk => items.delete(idOrPk));\n                    const snapshot = Array.from(items.values());\n                    // we sort after we merge the snapshots (items, itemsChanged)\n                    // otherwise, the merge may not\n                    if (options?.sort) {\n                        sortItems(snapshot);\n                    }\n                    return {\n                        items: snapshot,\n                        isSynced,\n                    };\n                };\n                /**\n                 * Emits the list of items to the observer.\n                 *\n                 * SIDE EFFECT: `itemsChanged` and `deletedItemIds` are cleared to prepare\n                 * for the next snapshot.\n                 *\n                 * @param snapshot The generated items data to emit.\n                 */\n                const emitSnapshot = (snapshot) => {\n                    // send the generated snapshot to the primary subscription.\n                    // NOTE: This observer's handler *could* be async ...\n                    observer.next(snapshot);\n                    // reset the changed items sets\n                    itemsChanged.clear();\n                    deletedItemIds = [];\n                };\n                /**\n                 * Sorts an `Array` of `T` according to the sort instructions given in the\n                 * original  `observeQuery()` call.\n                 *\n                 * @param itemsToSort A array of model type.\n                 */\n                const sortItems = (itemsToSort) => {\n                    const modelDefinition = getModelDefinition(model);\n                    const pagination = this.processPagination(modelDefinition, options);\n                    const sortPredicates = ModelSortPredicateCreator.getPredicates(pagination.sort);\n                    if (sortPredicates.length) {\n                        const compareFn = sortCompareFunction(sortPredicates);\n                        itemsToSort.sort(compareFn);\n                    }\n                };\n                /**\n                 * Force one last snapshot when the model is fully synced.\n                 *\n                 * This reduces latency for that last snapshot, which will otherwise\n                 * wait for the configured timeout.\n                 *\n                 * @param payload The payload from the Hub event.\n                 */\n                const hubCallback = ({ payload }) => {\n                    const { event, data } = payload;\n                    if (event === ControlMessage.SYNC_ENGINE_MODEL_SYNCED &&\n                        data?.model?.name === model.name) {\n                        generateAndEmitSnapshot();\n                        hubRemove();\n                    }\n                };\n                const hubRemove = Hub.listen('datastore', hubCallback);\n                return this.runningProcesses.addCleaner(async () => {\n                    if (handle) {\n                        handle.unsubscribe();\n                    }\n                }, 'datastore observequery cleaner');\n            });\n        };\n        this.configure = (config = {}) => {\n            this.amplifyContext.InternalAPI = this.InternalAPI;\n            const { DataStore: configDataStore, authModeStrategyType: configAuthModeStrategyType, conflictHandler: configConflictHandler, errorHandler: configErrorHandler, maxRecordsToSync: configMaxRecordsToSync, syncPageSize: configSyncPageSize, fullSyncInterval: configFullSyncInterval, syncExpressions: configSyncExpressions, authProviders: configAuthProviders, storageAdapter: configStorageAdapter, ...configFromAmplify } = config;\n            const currentAppSyncConfig = Amplify.getConfig().API?.GraphQL;\n            const appSyncConfig = {\n                aws_appsync_graphqlEndpoint: currentAppSyncConfig?.endpoint,\n                aws_appsync_authenticationType: currentAppSyncConfig?.defaultAuthMode,\n                aws_appsync_region: currentAppSyncConfig?.region,\n                aws_appsync_apiKey: currentAppSyncConfig?.apiKey,\n            };\n            this.amplifyConfig = {\n                ...this.amplifyConfig,\n                ...configFromAmplify,\n                ...(currentAppSyncConfig && appSyncConfig),\n            };\n            this.conflictHandler = this.setConflictHandler(config);\n            this.errorHandler = this.setErrorHandler(config);\n            const authModeStrategyType = (configDataStore && configDataStore.authModeStrategyType) ||\n                configAuthModeStrategyType ||\n                AuthModeStrategyType.DEFAULT;\n            switch (authModeStrategyType) {\n                case AuthModeStrategyType.MULTI_AUTH:\n                    this.authModeStrategy = multiAuthStrategy(this.amplifyContext);\n                    break;\n                case AuthModeStrategyType.DEFAULT:\n                    this.authModeStrategy = defaultAuthStrategy;\n                    break;\n                default:\n                    this.authModeStrategy = defaultAuthStrategy;\n                    break;\n            }\n            // store on config object, so that Sync, Subscription, and Mutation processors can have access\n            this.amplifyConfig.authProviders =\n                (configDataStore && configDataStore.authProviders) || configAuthProviders;\n            this.syncExpressions =\n                (configDataStore && configDataStore.syncExpressions) ||\n                    configSyncExpressions ||\n                    this.syncExpressions;\n            this.maxRecordsToSync =\n                (configDataStore && configDataStore.maxRecordsToSync) ||\n                    configMaxRecordsToSync ||\n                    this.maxRecordsToSync ||\n                    10000;\n            // store on config object, so that Sync, Subscription, and Mutation processors can have access\n            this.amplifyConfig.maxRecordsToSync = this.maxRecordsToSync;\n            this.syncPageSize =\n                (configDataStore && configDataStore.syncPageSize) ||\n                    configSyncPageSize ||\n                    this.syncPageSize ||\n                    1000;\n            // store on config object, so that Sync, Subscription, and Mutation processors can have access\n            this.amplifyConfig.syncPageSize = this.syncPageSize;\n            this.fullSyncInterval =\n                (configDataStore && configDataStore.fullSyncInterval) ||\n                    configFullSyncInterval ||\n                    this.fullSyncInterval ||\n                    24 * 60; // 1 day\n            this.storageAdapter =\n                (configDataStore && configDataStore.storageAdapter) ||\n                    configStorageAdapter ||\n                    this.storageAdapter ||\n                    undefined;\n            this.sessionId = this.retrieveSessionId();\n        };\n    }\n    getModuleName() {\n        return 'DataStore';\n    }\n    /**\n     * Builds a function to capture `BackgroundManagerNotOpenError`'s to produce friendlier,\n     * more instructive errors for customers.\n     *\n     * @param operation The name of the operation (usually a Datastore method) the customer\n     * tried to call.\n     */\n    handleAddProcError(operation) {\n        /**\n         * If the tested error is a `BackgroundManagerNotOpenError`, it will be captured\n         * and replaced with a friendlier message that instructs the App Developer.\n         *\n         * @param err An error to test.\n         */\n        const handler = (err) => {\n            if (err.message.startsWith('BackgroundManagerNotOpenError')) {\n                throw new Error([\n                    `DataStoreStateError: Tried to execute \\`${operation}\\` while DataStore was \"${this.state}\".`,\n                    `This can only be done while DataStore is \"Started\" or \"Stopped\". To remedy:`,\n                    'Ensure all calls to `stop()` and `clear()` have completed first.',\n                    'If this is not possible, retry the operation until it succeeds.',\n                ].join('\\n'));\n            }\n            else {\n                throw err;\n            }\n        };\n        return handler;\n    }\n    /**\n     * Clears all data from storage and removes all data, schema info, other\n     * initialization details, and then stops DataStore.\n     *\n     * That said, reinitialization is required after clearing. This can be done\n     * by explicitiliy calling `start()` or any method that implicitly starts\n     * DataStore, such as `query()`, `save()`, or `delete()`.\n     */\n    async clear() {\n        checkSchemaInitialized();\n        this.state = DataStoreState.Clearing;\n        await this.runningProcesses.close();\n        if (this.storage === undefined) {\n            // connect to storage so that it can be cleared without fully starting DataStore\n            this.storage = new Storage(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, this.storageAdapter, this.sessionId);\n            await this.storage.init();\n        }\n        if (syncSubscription && !syncSubscription.closed) {\n            syncSubscription.unsubscribe();\n        }\n        if (this.sync) {\n            await this.sync.stop();\n        }\n        await this.storage.clear();\n        this.initialized = undefined; // Should re-initialize when start() is called.\n        this.storage = undefined;\n        this.sync = undefined;\n        this.syncPredicates = new WeakMap();\n        await this.runningProcesses.open();\n        this.state = DataStoreState.NotRunning;\n    }\n    /**\n     * Stops all DataStore sync activities.\n     *\n     * TODO: \"Waits for graceful termination of\n     * running queries and terminates subscriptions.\"\n     */\n    async stop() {\n        this.state = DataStoreState.Stopping;\n        await this.runningProcesses.close();\n        if (syncSubscription && !syncSubscription.closed) {\n            syncSubscription.unsubscribe();\n        }\n        if (this.sync) {\n            await this.sync.stop();\n        }\n        this.initialized = undefined; // Should re-initialize when start() is called.\n        this.sync = undefined;\n        await this.runningProcesses.open();\n        this.state = DataStoreState.NotRunning;\n    }\n    /**\n     * Validates given pagination input from a query and creates a pagination\n     * argument for use against the storage layer.\n     *\n     * @param modelDefinition\n     * @param paginationProducer\n     */\n    processPagination(modelDefinition, paginationProducer) {\n        let sortPredicate;\n        const { limit, page, sort } = paginationProducer || {};\n        if (limit === undefined && page === undefined && sort === undefined) {\n            return undefined;\n        }\n        if (page !== undefined && limit === undefined) {\n            throw new Error('Limit is required when requesting a page');\n        }\n        if (page !== undefined) {\n            if (typeof page !== 'number') {\n                throw new Error('Page should be a number');\n            }\n            if (page < 0) {\n                throw new Error(\"Page can't be negative\");\n            }\n        }\n        if (limit !== undefined) {\n            if (typeof limit !== 'number') {\n                throw new Error('Limit should be a number');\n            }\n            if (limit < 0) {\n                throw new Error(\"Limit can't be negative\");\n            }\n        }\n        if (sort) {\n            sortPredicate = ModelSortPredicateCreator.createFromExisting(modelDefinition, sort);\n        }\n        return {\n            limit,\n            page,\n            sort: sortPredicate,\n        };\n    }\n    /**\n     * Examines the configured `syncExpressions` and produces a WeakMap of\n     * SchemaModel -> predicate to use during sync.\n     */\n    async processSyncExpressions() {\n        if (!this.syncExpressions || !this.syncExpressions.length) {\n            return new WeakMap();\n        }\n        const syncPredicates = await Promise.all(this.syncExpressions.map(async (syncExpression) => {\n            const { modelConstructor, conditionProducer } = await syncExpression;\n            const modelDefinition = getModelDefinition(modelConstructor);\n            // conditionProducer is either a predicate, e.g. (c) => c.field.eq(1)\n            // OR a function/promise that returns a predicate\n            const condition = await this.unwrapPromise(conditionProducer);\n            if (isPredicatesAll(condition)) {\n                return [modelDefinition, null];\n            }\n            const predicate = internals(condition(predicateFor({\n                builder: modelConstructor,\n                schema: modelDefinition,\n                pkField: extractPrimaryKeyFieldNames(modelDefinition),\n            }))).toStoragePredicate();\n            return [modelDefinition, predicate];\n        }));\n        return this.weakMapFromEntries(syncPredicates);\n    }\n    async unwrapPromise(conditionProducer) {\n        try {\n            const condition = await conditionProducer();\n            return condition || conditionProducer;\n        }\n        catch (error) {\n            if (error instanceof TypeError) {\n                return conditionProducer;\n            }\n            throw error;\n        }\n    }\n    weakMapFromEntries(entries) {\n        return entries.reduce((map, [modelDefinition, predicate]) => {\n            if (map.has(modelDefinition)) {\n                const { name } = modelDefinition;\n                logger.warn(`You can only utilize one Sync Expression per model.\n          Subsequent sync expressions for the ${name} model will be ignored.`);\n                return map;\n            }\n            if (predicate) {\n                map.set(modelDefinition, predicate);\n            }\n            return map;\n        }, new WeakMap());\n    }\n    /**\n     * A session ID to allow CMS to open databases against multiple apps.\n     * This session ID is only expected be set by AWS Amplify Studio.\n     */\n    retrieveSessionId() {\n        try {\n            const sessionId = sessionStorage.getItem('datastoreSessionId');\n            if (sessionId) {\n                const { aws_appsync_graphqlEndpoint } = this.amplifyConfig;\n                const appSyncUrl = aws_appsync_graphqlEndpoint.split('/')[2];\n                const [appSyncId] = appSyncUrl.split('.');\n                return `${sessionId}-${appSyncId}`;\n            }\n        }\n        catch { }\n        return undefined;\n    }\n}\nconst instance = new DataStore();\ninstance.configure({});\nHub.listen('core', capsule => {\n    if (capsule.payload.event === 'configure') {\n        instance.configure({});\n    }\n});\nexport { DataStore as DataStoreClass, initSchema, instance as DataStore };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}