{"ast":null,"code":"import { fetchAuthSession } from '@aws-amplify/core';\nimport { ModelAttributeAuthAllow, ModelAttributeAuthProvider } from '../types.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nfunction getProviderFromRule(rule) {\n  // private with no provider means userPools\n  if (rule.allow === 'private' && !rule.provider) {\n    return ModelAttributeAuthProvider.USER_POOLS;\n  }\n  // public with no provider means apiKey\n  if (rule.allow === 'public' && !rule.provider) {\n    return ModelAttributeAuthProvider.API_KEY;\n  }\n  return rule.provider;\n}\nfunction sortAuthRulesWithPriority(rules) {\n  const allowSortPriority = [ModelAttributeAuthAllow.CUSTOM, ModelAttributeAuthAllow.OWNER, ModelAttributeAuthAllow.GROUPS, ModelAttributeAuthAllow.PRIVATE, ModelAttributeAuthAllow.PUBLIC];\n  const providerSortPriority = [ModelAttributeAuthProvider.FUNCTION, ModelAttributeAuthProvider.USER_POOLS, ModelAttributeAuthProvider.OIDC, ModelAttributeAuthProvider.IAM, ModelAttributeAuthProvider.API_KEY];\n  return [...rules].sort((a, b) => {\n    if (a.allow === b.allow) {\n      return providerSortPriority.indexOf(getProviderFromRule(a)) - providerSortPriority.indexOf(getProviderFromRule(b));\n    }\n    return allowSortPriority.indexOf(a.allow) - allowSortPriority.indexOf(b.allow);\n  });\n}\nfunction getAuthRules(_ref) {\n  let {\n    rules,\n    currentUser\n  } = _ref;\n  // Using Set to ensure uniqueness\n  const authModes = new Set();\n  rules.forEach(rule => {\n    switch (rule.allow) {\n      case ModelAttributeAuthAllow.CUSTOM:\n        // custom with no provider -> function\n        if (!rule.provider || rule.provider === ModelAttributeAuthProvider.FUNCTION) {\n          authModes.add('lambda');\n        }\n        break;\n      case ModelAttributeAuthAllow.GROUPS:\n      case ModelAttributeAuthAllow.OWNER:\n        {\n          // We shouldn't attempt User Pool or OIDC if there isn't an authenticated user\n          if (currentUser) {\n            if (rule.provider === ModelAttributeAuthProvider.USER_POOLS) {\n              authModes.add('userPool');\n            } else if (rule.provider === ModelAttributeAuthProvider.OIDC) {\n              authModes.add('oidc');\n            }\n          }\n          break;\n        }\n      case ModelAttributeAuthAllow.PRIVATE:\n        {\n          // We shouldn't attempt private if there isn't an authenticated user\n          if (currentUser) {\n            // private with no provider means userPools\n            if (!rule.provider || rule.provider === ModelAttributeAuthProvider.USER_POOLS) {\n              authModes.add('userPool');\n            } else if (rule.provider === ModelAttributeAuthProvider.IAM) {\n              authModes.add('iam');\n            }\n          }\n          break;\n        }\n      case ModelAttributeAuthAllow.PUBLIC:\n        {\n          if (rule.provider === ModelAttributeAuthProvider.IAM) {\n            authModes.add('iam');\n          } else if (!rule.provider || rule.provider === ModelAttributeAuthProvider.API_KEY) {\n            // public with no provider means apiKey\n            authModes.add('apiKey');\n          }\n          break;\n        }\n    }\n  });\n  return Array.from(authModes);\n}\n/**\n * Returns an array of auth modes to try based on the schema, model, and\n * authenticated user (or lack thereof). Rules are sourced from `getAuthRules`\n * and returned in the order they ought to be attempted.\n *\n * @see sortAuthRulesWithPriority\n * @see getAuthRules\n *\n * @param param0 The `{schema, modelName}` to inspect.\n * @returns A sorted array of auth modes to attempt.\n */\nconst multiAuthStrategy = amplifyContext => async _ref2 => {\n  let {\n    schema,\n    modelName\n  } = _ref2;\n  let currentUser;\n  try {\n    const authSession = await fetchAuthSession();\n    if (authSession.tokens.accessToken) {\n      // the user is authenticated\n      currentUser = authSession;\n    }\n  } catch (e) {\n    // No current user\n  }\n  const {\n    attributes\n  } = schema.namespaces.user.models[modelName];\n  if (attributes) {\n    var _authAttribute$proper;\n    const authAttribute = attributes.find(attr => attr.type === 'auth');\n    if (authAttribute !== null && authAttribute !== void 0 && (_authAttribute$proper = authAttribute.properties) !== null && _authAttribute$proper !== void 0 && _authAttribute$proper.rules) {\n      const sortedRules = sortAuthRulesWithPriority(authAttribute.properties.rules);\n      return getAuthRules({\n        currentUser,\n        rules: sortedRules\n      });\n    }\n  }\n  return [];\n};\nexport { multiAuthStrategy };","map":{"version":3,"names":["getProviderFromRule","rule","allow","provider","ModelAttributeAuthProvider","USER_POOLS","API_KEY","sortAuthRulesWithPriority","rules","allowSortPriority","ModelAttributeAuthAllow","CUSTOM","OWNER","GROUPS","PRIVATE","PUBLIC","providerSortPriority","FUNCTION","OIDC","IAM","sort","a","b","indexOf","getAuthRules","_ref","currentUser","authModes","Set","forEach","add","Array","from","multiAuthStrategy","amplifyContext","_ref2","schema","modelName","authSession","fetchAuthSession","tokens","accessToken","e","attributes","namespaces","user","models","_authAttribute$proper","authAttribute","find","attr","type","properties","sortedRules"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/authModeStrategies/multiAuthStrategy.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { fetchAuthSession } from '@aws-amplify/core';\nimport { ModelAttributeAuthProvider, ModelAttributeAuthAllow, } from '../types';\nfunction getProviderFromRule(rule) {\n    // private with no provider means userPools\n    if (rule.allow === 'private' && !rule.provider) {\n        return ModelAttributeAuthProvider.USER_POOLS;\n    }\n    // public with no provider means apiKey\n    if (rule.allow === 'public' && !rule.provider) {\n        return ModelAttributeAuthProvider.API_KEY;\n    }\n    return rule.provider;\n}\nfunction sortAuthRulesWithPriority(rules) {\n    const allowSortPriority = [\n        ModelAttributeAuthAllow.CUSTOM,\n        ModelAttributeAuthAllow.OWNER,\n        ModelAttributeAuthAllow.GROUPS,\n        ModelAttributeAuthAllow.PRIVATE,\n        ModelAttributeAuthAllow.PUBLIC,\n    ];\n    const providerSortPriority = [\n        ModelAttributeAuthProvider.FUNCTION,\n        ModelAttributeAuthProvider.USER_POOLS,\n        ModelAttributeAuthProvider.OIDC,\n        ModelAttributeAuthProvider.IAM,\n        ModelAttributeAuthProvider.API_KEY,\n    ];\n    return [...rules].sort((a, b) => {\n        if (a.allow === b.allow) {\n            return (providerSortPriority.indexOf(getProviderFromRule(a)) -\n                providerSortPriority.indexOf(getProviderFromRule(b)));\n        }\n        return (allowSortPriority.indexOf(a.allow) - allowSortPriority.indexOf(b.allow));\n    });\n}\nfunction getAuthRules({ rules, currentUser, }) {\n    // Using Set to ensure uniqueness\n    const authModes = new Set();\n    rules.forEach(rule => {\n        switch (rule.allow) {\n            case ModelAttributeAuthAllow.CUSTOM:\n                // custom with no provider -> function\n                if (!rule.provider ||\n                    rule.provider === ModelAttributeAuthProvider.FUNCTION) {\n                    authModes.add('lambda');\n                }\n                break;\n            case ModelAttributeAuthAllow.GROUPS:\n            case ModelAttributeAuthAllow.OWNER: {\n                // We shouldn't attempt User Pool or OIDC if there isn't an authenticated user\n                if (currentUser) {\n                    if (rule.provider === ModelAttributeAuthProvider.USER_POOLS) {\n                        authModes.add('userPool');\n                    }\n                    else if (rule.provider === ModelAttributeAuthProvider.OIDC) {\n                        authModes.add('oidc');\n                    }\n                }\n                break;\n            }\n            case ModelAttributeAuthAllow.PRIVATE: {\n                // We shouldn't attempt private if there isn't an authenticated user\n                if (currentUser) {\n                    // private with no provider means userPools\n                    if (!rule.provider ||\n                        rule.provider === ModelAttributeAuthProvider.USER_POOLS) {\n                        authModes.add('userPool');\n                    }\n                    else if (rule.provider === ModelAttributeAuthProvider.IAM) {\n                        authModes.add('iam');\n                    }\n                }\n                break;\n            }\n            case ModelAttributeAuthAllow.PUBLIC: {\n                if (rule.provider === ModelAttributeAuthProvider.IAM) {\n                    authModes.add('iam');\n                }\n                else if (!rule.provider ||\n                    rule.provider === ModelAttributeAuthProvider.API_KEY) {\n                    // public with no provider means apiKey\n                    authModes.add('apiKey');\n                }\n                break;\n            }\n            default:\n                break;\n        }\n    });\n    return Array.from(authModes);\n}\n/**\n * Returns an array of auth modes to try based on the schema, model, and\n * authenticated user (or lack thereof). Rules are sourced from `getAuthRules`\n * and returned in the order they ought to be attempted.\n *\n * @see sortAuthRulesWithPriority\n * @see getAuthRules\n *\n * @param param0 The `{schema, modelName}` to inspect.\n * @returns A sorted array of auth modes to attempt.\n */\nexport const multiAuthStrategy = (amplifyContext) => async ({ schema, modelName }) => {\n    let currentUser;\n    try {\n        const authSession = await fetchAuthSession();\n        if (authSession.tokens.accessToken) {\n            // the user is authenticated\n            currentUser = authSession;\n        }\n    }\n    catch (e) {\n        // No current user\n    }\n    const { attributes } = schema.namespaces.user.models[modelName];\n    if (attributes) {\n        const authAttribute = attributes.find(attr => attr.type === 'auth');\n        if (authAttribute?.properties?.rules) {\n            const sortedRules = sortAuthRulesWithPriority(authAttribute.properties.rules);\n            return getAuthRules({ currentUser, rules: sortedRules });\n        }\n    }\n    return [];\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}