{"ast":null,"code":"import { InternalAPI } from '@aws-amplify/api/internals';\nimport { jitteredBackoff, BackgroundProcessManager, retry, Category, DataStoreAction, NonRetryableError } from '@aws-amplify/core/internals/utils';\nimport { Observable } from 'rxjs';\nimport { ProcessName, DISCARD, isModelFieldType, isTargetNameAssociation, OpType } from '../../types.mjs';\nimport { extractTargetNamesFromSrc, USER, ID } from '../../util.mjs';\nimport { buildGraphQLOperation, getModelAuthModes, getTokenForCustomAuth, createMutationInstanceFromModelOperation, TransformerMutationType } from '../utils.mjs';\nimport { getMutationErrorType } from './errorMaps.mjs';\nimport { ConsoleLogger } from '@aws-amplify/core';\nconst MAX_ATTEMPTS = 10;\nconst logger = new ConsoleLogger('DataStore');\nclass MutationProcessor {\n  constructor(schema, storage, userClasses, outbox, modelInstanceCreator, MutationEvent) {\n    let amplifyConfig = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n    let authModeStrategy = arguments.length > 7 ? arguments[7] : undefined;\n    let errorHandler = arguments.length > 8 ? arguments[8] : undefined;\n    let conflictHandler = arguments.length > 9 ? arguments[9] : undefined;\n    let amplifyContext = arguments.length > 10 ? arguments[10] : undefined;\n    this.schema = schema;\n    this.storage = storage;\n    this.userClasses = userClasses;\n    this.outbox = outbox;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.MutationEvent = MutationEvent;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.errorHandler = errorHandler;\n    this.conflictHandler = conflictHandler;\n    this.amplifyContext = amplifyContext;\n    this.typeQuery = new WeakMap();\n    this.processing = false;\n    this.runningProcesses = new BackgroundProcessManager();\n    this.amplifyContext.InternalAPI = this.amplifyContext.InternalAPI || InternalAPI;\n    this.generateQueries();\n  }\n  generateQueries() {\n    Object.values(this.schema.namespaces).forEach(namespace => {\n      Object.values(namespace.models).filter(_ref => {\n        let {\n          syncable\n        } = _ref;\n        return syncable;\n      }).forEach(model => {\n        const [createMutation] = buildGraphQLOperation(namespace, model, 'CREATE');\n        const [updateMutation] = buildGraphQLOperation(namespace, model, 'UPDATE');\n        const [deleteMutation] = buildGraphQLOperation(namespace, model, 'DELETE');\n        this.typeQuery.set(model, [createMutation, updateMutation, deleteMutation]);\n      });\n    });\n  }\n  isReady() {\n    return this.observer !== undefined;\n  }\n  start() {\n    this.runningProcesses = new BackgroundProcessManager();\n    const observable = new Observable(observer => {\n      this.observer = observer;\n      try {\n        this.resume();\n      } catch (error) {\n        logger.error('mutations processor start error', error);\n        throw error;\n      }\n      return this.runningProcesses.addCleaner(async () => {\n        // The observer has unsubscribed and/or `stop()` has been called.\n        this.removeObserver();\n        this.pause();\n      });\n    });\n    return observable;\n  }\n  async stop() {\n    this.removeObserver();\n    await this.runningProcesses.close();\n    await this.runningProcesses.open();\n  }\n  removeObserver() {\n    var _this$observer, _this$observer$comple;\n    (_this$observer = this.observer) === null || _this$observer === void 0 || (_this$observer$comple = _this$observer.complete) === null || _this$observer$comple === void 0 || _this$observer$comple.call(_this$observer);\n    this.observer = undefined;\n  }\n  async resume() {\n    if (this.runningProcesses.isOpen) {\n      await this.runningProcesses.add(async onTerminate => {\n        if (this.processing || !this.isReady() || !this.runningProcesses.isOpen) {\n          return;\n        }\n        this.processing = true;\n        let head;\n        const namespaceName = USER;\n        // start to drain outbox\n        while (this.processing && this.runningProcesses.isOpen && (head = await this.outbox.peek(this.storage)) !== undefined) {\n          var _this$observer2, _this$observer2$next, _this$observer3;\n          const {\n            model,\n            operation,\n            data,\n            condition\n          } = head;\n          const modelConstructor = this.userClasses[model];\n          let result = undefined;\n          let opName = undefined;\n          let modelDefinition = undefined;\n          try {\n            const modelAuthModes = await getModelAuthModes({\n              authModeStrategy: this.authModeStrategy,\n              defaultAuthMode: this.amplifyConfig.aws_appsync_authenticationType,\n              modelName: model,\n              schema: this.schema\n            });\n            const operationAuthModes = modelAuthModes[operation.toUpperCase()];\n            let authModeAttempts = 0;\n            const authModeRetry = async () => {\n              try {\n                logger.debug(\"Attempting mutation with authMode: \".concat(operationAuthModes[authModeAttempts]));\n                const response = await this.jitteredRetry(namespaceName, model, operation, data, condition, modelConstructor, this.MutationEvent, head, operationAuthModes[authModeAttempts], onTerminate);\n                logger.debug(\"Mutation sent successfully with authMode: \".concat(operationAuthModes[authModeAttempts]));\n                return response;\n              } catch (error) {\n                authModeAttempts++;\n                if (authModeAttempts >= operationAuthModes.length) {\n                  logger.debug(\"Mutation failed with authMode: \".concat(operationAuthModes[authModeAttempts - 1]));\n                  try {\n                    await this.errorHandler({\n                      recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                      localModel: null,\n                      message: error.message,\n                      model: modelConstructor.name,\n                      operation: opName,\n                      errorType: getMutationErrorType(error),\n                      process: ProcessName.sync,\n                      remoteModel: null,\n                      cause: error\n                    });\n                  } catch (e) {\n                    logger.error('Mutation error handler failed with:', e);\n                  }\n                  throw error;\n                }\n                logger.debug(\"Mutation failed with authMode: \".concat(operationAuthModes[authModeAttempts - 1], \". Retrying with authMode: \").concat(operationAuthModes[authModeAttempts]));\n                return await authModeRetry();\n              }\n            };\n            [result, opName, modelDefinition] = await authModeRetry();\n          } catch (error) {\n            if (error.message === 'Offline' || error.message === 'RetryMutation') {\n              continue;\n            }\n          }\n          if (result === undefined) {\n            logger.debug('done retrying');\n            await this.storage.runExclusive(async storage => {\n              await this.outbox.dequeue(storage);\n            });\n            continue;\n          }\n          const record = result.data[opName];\n          let hasMore = false;\n          await this.storage.runExclusive(async storage => {\n            // using runExclusive to prevent possible race condition\n            // when another record gets enqueued between dequeue and peek\n            await this.outbox.dequeue(storage, record, operation);\n            hasMore = (await this.outbox.peek(storage)) !== undefined;\n          });\n          (_this$observer2 = this.observer) === null || _this$observer2 === void 0 || (_this$observer2$next = (_this$observer3 = _this$observer2).next) === null || _this$observer2$next === void 0 || _this$observer2$next.call(_this$observer3, {\n            operation,\n            modelDefinition,\n            model: record,\n            hasMore\n          });\n        }\n        // pauses itself\n        this.pause();\n      }, 'mutation resume loop');\n    }\n  }\n  async jitteredRetry(namespaceName, model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent, authMode, onTerminate) {\n    return await retry(async (model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent) => {\n      const [query, variables, graphQLCondition, opName, modelDefinition] = this.createQueryVariables(namespaceName, model, operation, data, condition);\n      const authToken = await getTokenForCustomAuth(authMode, this.amplifyConfig);\n      const tryWith = {\n        query,\n        variables,\n        authMode,\n        authToken\n      };\n      let attempt = 0;\n      const opType = this.opTypeFromTransformerOperation(operation);\n      const customUserAgentDetails = {\n        category: Category.DataStore,\n        action: DataStoreAction.GraphQl\n      };\n      do {\n        try {\n          const result = await this.amplifyContext.InternalAPI.graphql(tryWith, undefined, customUserAgentDetails);\n          // Use `as any` because TypeScript doesn't seem to like passing tuples\n          // through generic params.\n          return [result, opName, modelDefinition];\n        } catch (err) {\n          if (err.errors && err.errors.length > 0) {\n            const [error] = err.errors;\n            const {\n              originalError: {\n                code = null\n              } = {}\n            } = error;\n            if (error.errorType === 'Unauthorized') {\n              throw new NonRetryableError('Unauthorized');\n            }\n            if (error.message === 'Network Error' || code === 'ECONNABORTED' // refers to axios timeout error caused by device's bad network condition\n            ) {\n              if (!this.processing) {\n                throw new NonRetryableError('Offline');\n              }\n              // TODO: Check errors on different env (react-native or other browsers)\n              throw new Error('Network Error');\n            }\n            if (error.errorType === 'ConflictUnhandled') {\n              // TODO: add on ConflictConditionalCheck error query last from server\n              attempt++;\n              let retryWith;\n              if (attempt > MAX_ATTEMPTS) {\n                retryWith = DISCARD;\n              } else {\n                try {\n                  retryWith = await this.conflictHandler({\n                    modelConstructor,\n                    localModel: this.modelInstanceCreator(modelConstructor, variables.input),\n                    remoteModel: this.modelInstanceCreator(modelConstructor, error.data),\n                    operation: opType,\n                    attempts: attempt\n                  });\n                } catch (err) {\n                  logger.warn('conflict trycatch', err);\n                  continue;\n                }\n              }\n              if (retryWith === DISCARD) {\n                // Query latest from server and notify merger\n                const [[, opName, query]] = buildGraphQLOperation(this.schema.namespaces[namespaceName], modelDefinition, 'GET');\n                const authToken = await getTokenForCustomAuth(authMode, this.amplifyConfig);\n                const serverData = await this.amplifyContext.InternalAPI.graphql({\n                  query,\n                  variables: {\n                    id: variables.input.id\n                  },\n                  authMode,\n                  authToken\n                }, undefined, customUserAgentDetails);\n                // onTerminate cancel graphql()\n                return [serverData, opName, modelDefinition];\n              }\n              const namespace = this.schema.namespaces[namespaceName];\n              // convert retry with to tryWith\n              const updatedMutation = createMutationInstanceFromModelOperation(namespace.relationships, modelDefinition, opType, modelConstructor, retryWith, graphQLCondition, MutationEvent, this.modelInstanceCreator, mutationEvent.id);\n              await this.storage.save(updatedMutation);\n              throw new NonRetryableError('RetryMutation');\n            } else {\n              try {\n                this.errorHandler({\n                  recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                  localModel: variables.input,\n                  message: error.message,\n                  operation,\n                  errorType: getMutationErrorType(error),\n                  errorInfo: error.errorInfo,\n                  process: ProcessName.mutate,\n                  cause: error,\n                  remoteModel: error.data ? this.modelInstanceCreator(modelConstructor, error.data) : null\n                });\n              } catch (err) {\n                logger.warn('Mutation error handler failed with:', err);\n              } finally {\n                // Return empty tuple, dequeues the mutation\n                return error.data ? [{\n                  data: {\n                    [opName]: error.data\n                  }\n                }, opName, modelDefinition] : [];\n              }\n            }\n          } else {\n            // Catch-all for client-side errors that don't come back in the `GraphQLError` format.\n            // These errors should not be retried.\n            throw new NonRetryableError(err);\n          }\n        }\n      } while (tryWith);\n    }, [model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent], safeJitteredBackoff, onTerminate);\n  }\n  createQueryVariables(namespaceName, model, operation, data, condition) {\n    var _modelDefinition$attr, _auth$properties;\n    const modelDefinition = this.schema.namespaces[namespaceName].models[model];\n    const {\n      primaryKey\n    } = this.schema.namespaces[namespaceName].keys[model];\n    const auth = (_modelDefinition$attr = modelDefinition.attributes) === null || _modelDefinition$attr === void 0 ? void 0 : _modelDefinition$attr.find(a => a.type === 'auth');\n    const ownerFields = (auth === null || auth === void 0 || (_auth$properties = auth.properties) === null || _auth$properties === void 0 ? void 0 : _auth$properties.rules.map(rule => rule.ownerField).filter(f => f)) || ['owner'];\n    const queriesTuples = this.typeQuery.get(modelDefinition);\n    const [, opName, query] = queriesTuples.find(_ref2 => {\n      let [transformerMutationType] = _ref2;\n      return transformerMutationType === operation;\n    });\n    const {\n      _version,\n      ...parsedData\n    } = JSON.parse(data);\n    // include all the fields that comprise a custom PK if one is specified\n    const deleteInput = {};\n    if (primaryKey && primaryKey.length) {\n      for (const pkField of primaryKey) {\n        deleteInput[pkField] = parsedData[pkField];\n      }\n    } else {\n      deleteInput[ID] = parsedData.id;\n    }\n    let mutationInput;\n    if (operation === TransformerMutationType.DELETE) {\n      // For DELETE mutations, only the key(s) are included in the input\n      mutationInput = deleteInput;\n    } else {\n      // Otherwise, we construct the mutation input with the following logic\n      mutationInput = {};\n      const modelFields = Object.values(modelDefinition.fields);\n      for (const {\n        name,\n        type,\n        association,\n        isReadOnly\n      } of modelFields) {\n        // omit readonly fields. cloud storage doesn't need them and won't take them!\n        if (isReadOnly) {\n          continue;\n        }\n        // omit owner fields if it's `null`. cloud storage doesn't allow it.\n        if (ownerFields.includes(name) && parsedData[name] === null) {\n          continue;\n        }\n        // model fields should be stripped out from the input\n        if (isModelFieldType(type)) {\n          // except for belongs to relations - we need to replace them with the correct foreign key(s)\n          if (isTargetNameAssociation(association) && association.connectionType === 'BELONGS_TO') {\n            const targetNames = extractTargetNamesFromSrc(association);\n            if (targetNames) {\n              // instead of including the connected model itself, we add its key(s) to the mutation input\n              for (const targetName of targetNames) {\n                mutationInput[targetName] = parsedData[targetName];\n              }\n            }\n          }\n          continue;\n        }\n        // scalar fields / non-model types\n        if (operation === TransformerMutationType.UPDATE) {\n          if (!parsedData.hasOwnProperty(name)) {\n            // for update mutations - strip out a field if it's unchanged\n            continue;\n          }\n        }\n        // all other fields are added to the input object\n        mutationInput[name] = parsedData[name];\n      }\n    }\n    // Build mutation variables input object\n    const input = {\n      ...mutationInput,\n      _version\n    };\n    const graphQLCondition = JSON.parse(condition);\n    const variables = {\n      input,\n      ...(operation === TransformerMutationType.CREATE ? {} : {\n        condition: Object.keys(graphQLCondition).length > 0 ? graphQLCondition : null\n      })\n    };\n    return [query, variables, graphQLCondition, opName, modelDefinition];\n  }\n  opTypeFromTransformerOperation(operation) {\n    switch (operation) {\n      case TransformerMutationType.CREATE:\n        return OpType.INSERT;\n      case TransformerMutationType.DELETE:\n        return OpType.DELETE;\n      case TransformerMutationType.UPDATE:\n        return OpType.UPDATE;\n      case TransformerMutationType.GET:\n        // Intentionally blank\n        break;\n      default:\n        throw new Error(\"Invalid operation \".concat(operation));\n    }\n    // because it makes TS happy ...\n    return undefined;\n  }\n  pause() {\n    this.processing = false;\n  }\n}\nconst MAX_RETRY_DELAY_MS = 5 * 60 * 1000;\nconst originalJitteredBackoff = jitteredBackoff(MAX_RETRY_DELAY_MS);\n/**\n * @private\n * Internal use of Amplify only.\n *\n * Wraps the jittered backoff calculation to retry Network Errors indefinitely.\n * Backs off according to original jittered retry logic until the original retry\n * logic hits its max. After this occurs, if the error is a Network Error, we\n * ignore the attempt count and return MAX_RETRY_DELAY_MS to retry forever (until\n * the request succeeds).\n *\n * @param attempt ignored\n * @param _args ignored\n * @param error tested to see if `.message` is 'Network Error'\n * @returns number | false :\n */\nconst safeJitteredBackoff = (attempt, _args, error) => {\n  const attemptResult = originalJitteredBackoff(attempt);\n  // If this is the last attempt and it is a network error, we retry indefinitively every 5 minutes\n  if (attemptResult === false && (error || {}).message === 'Network Error') {\n    return MAX_RETRY_DELAY_MS;\n  }\n  return attemptResult;\n};\nexport { MutationProcessor, safeJitteredBackoff };","map":{"version":3,"names":["MAX_ATTEMPTS","logger","ConsoleLogger","MutationProcessor","constructor","schema","storage","userClasses","outbox","modelInstanceCreator","MutationEvent","amplifyConfig","arguments","length","undefined","authModeStrategy","errorHandler","conflictHandler","amplifyContext","typeQuery","WeakMap","processing","runningProcesses","BackgroundProcessManager","InternalAPI","generateQueries","Object","values","namespaces","forEach","namespace","models","filter","_ref","syncable","model","createMutation","buildGraphQLOperation","updateMutation","deleteMutation","set","isReady","observer","start","observable","Observable","resume","error","addCleaner","removeObserver","pause","stop","close","open","_this$observer","_this$observer$comple","complete","call","isOpen","add","onTerminate","head","namespaceName","USER","peek","_this$observer2","_this$observer2$next","_this$observer3","operation","data","condition","modelConstructor","result","opName","modelDefinition","modelAuthModes","getModelAuthModes","defaultAuthMode","aws_appsync_authenticationType","modelName","operationAuthModes","toUpperCase","authModeAttempts","authModeRetry","debug","concat","response","jitteredRetry","recoverySuggestion","localModel","message","name","errorType","getMutationErrorType","process","ProcessName","sync","remoteModel","cause","e","runExclusive","dequeue","record","hasMore","next","mutationEvent","authMode","retry","query","variables","graphQLCondition","createQueryVariables","authToken","getTokenForCustomAuth","tryWith","attempt","opType","opTypeFromTransformerOperation","customUserAgentDetails","category","Category","DataStore","action","DataStoreAction","GraphQl","graphql","err","errors","originalError","code","NonRetryableError","Error","retryWith","DISCARD","input","attempts","warn","serverData","id","updatedMutation","createMutationInstanceFromModelOperation","relationships","save","errorInfo","mutate","safeJitteredBackoff","_modelDefinition$attr","_auth$properties","primaryKey","keys","auth","attributes","find","a","type","ownerFields","properties","rules","map","rule","ownerField","f","queriesTuples","get","_ref2","transformerMutationType","_version","parsedData","JSON","parse","deleteInput","pkField","ID","mutationInput","TransformerMutationType","DELETE","modelFields","fields","association","isReadOnly","includes","isModelFieldType","isTargetNameAssociation","connectionType","targetNames","extractTargetNamesFromSrc","targetName","UPDATE","hasOwnProperty","CREATE","OpType","INSERT","GET","MAX_RETRY_DELAY_MS","originalJitteredBackoff","jitteredBackoff","_args","attemptResult"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/sync/processors/mutation.ts"],"sourcesContent":["import { InternalAPI } from '@aws-amplify/api/internals';\nimport { Category, DataStoreAction, jitteredBackoff, NonRetryableError, retry, BackgroundProcessManager, } from '@aws-amplify/core/internals/utils';\nimport { Observable } from 'rxjs';\nimport { DISCARD, isModelFieldType, isTargetNameAssociation, OpType, ProcessName, } from '../../types';\nimport { extractTargetNamesFromSrc, USER, ID } from '../../util';\nimport { buildGraphQLOperation, createMutationInstanceFromModelOperation, getModelAuthModes, TransformerMutationType, getTokenForCustomAuth, } from '../utils';\nimport { getMutationErrorType } from './errorMaps';\nimport { ConsoleLogger } from '@aws-amplify/core';\nconst MAX_ATTEMPTS = 10;\nconst logger = new ConsoleLogger('DataStore');\nclass MutationProcessor {\n    constructor(schema, storage, userClasses, outbox, modelInstanceCreator, MutationEvent, amplifyConfig = {}, authModeStrategy, errorHandler, conflictHandler, amplifyContext) {\n        this.schema = schema;\n        this.storage = storage;\n        this.userClasses = userClasses;\n        this.outbox = outbox;\n        this.modelInstanceCreator = modelInstanceCreator;\n        this.MutationEvent = MutationEvent;\n        this.amplifyConfig = amplifyConfig;\n        this.authModeStrategy = authModeStrategy;\n        this.errorHandler = errorHandler;\n        this.conflictHandler = conflictHandler;\n        this.amplifyContext = amplifyContext;\n        this.typeQuery = new WeakMap();\n        this.processing = false;\n        this.runningProcesses = new BackgroundProcessManager();\n        this.amplifyContext.InternalAPI =\n            this.amplifyContext.InternalAPI || InternalAPI;\n        this.generateQueries();\n    }\n    generateQueries() {\n        Object.values(this.schema.namespaces).forEach(namespace => {\n            Object.values(namespace.models)\n                .filter(({ syncable }) => syncable)\n                .forEach(model => {\n                const [createMutation] = buildGraphQLOperation(namespace, model, 'CREATE');\n                const [updateMutation] = buildGraphQLOperation(namespace, model, 'UPDATE');\n                const [deleteMutation] = buildGraphQLOperation(namespace, model, 'DELETE');\n                this.typeQuery.set(model, [\n                    createMutation,\n                    updateMutation,\n                    deleteMutation,\n                ]);\n            });\n        });\n    }\n    isReady() {\n        return this.observer !== undefined;\n    }\n    start() {\n        this.runningProcesses = new BackgroundProcessManager();\n        const observable = new Observable(observer => {\n            this.observer = observer;\n            try {\n                this.resume();\n            }\n            catch (error) {\n                logger.error('mutations processor start error', error);\n                throw error;\n            }\n            return this.runningProcesses.addCleaner(async () => {\n                // The observer has unsubscribed and/or `stop()` has been called.\n                this.removeObserver();\n                this.pause();\n            });\n        });\n        return observable;\n    }\n    async stop() {\n        this.removeObserver();\n        await this.runningProcesses.close();\n        await this.runningProcesses.open();\n    }\n    removeObserver() {\n        this.observer?.complete?.();\n        this.observer = undefined;\n    }\n    async resume() {\n        if (this.runningProcesses.isOpen) {\n            await this.runningProcesses.add(async (onTerminate) => {\n                if (this.processing ||\n                    !this.isReady() ||\n                    !this.runningProcesses.isOpen) {\n                    return;\n                }\n                this.processing = true;\n                let head;\n                const namespaceName = USER;\n                // start to drain outbox\n                while (this.processing &&\n                    this.runningProcesses.isOpen &&\n                    (head = await this.outbox.peek(this.storage)) !== undefined) {\n                    const { model, operation, data, condition } = head;\n                    const modelConstructor = this.userClasses[model];\n                    let result = undefined;\n                    let opName = undefined;\n                    let modelDefinition = undefined;\n                    try {\n                        const modelAuthModes = await getModelAuthModes({\n                            authModeStrategy: this.authModeStrategy,\n                            defaultAuthMode: this.amplifyConfig.aws_appsync_authenticationType,\n                            modelName: model,\n                            schema: this.schema,\n                        });\n                        const operationAuthModes = modelAuthModes[operation.toUpperCase()];\n                        let authModeAttempts = 0;\n                        const authModeRetry = async () => {\n                            try {\n                                logger.debug(`Attempting mutation with authMode: ${operationAuthModes[authModeAttempts]}`);\n                                const response = await this.jitteredRetry(namespaceName, model, operation, data, condition, modelConstructor, this.MutationEvent, head, operationAuthModes[authModeAttempts], onTerminate);\n                                logger.debug(`Mutation sent successfully with authMode: ${operationAuthModes[authModeAttempts]}`);\n                                return response;\n                            }\n                            catch (error) {\n                                authModeAttempts++;\n                                if (authModeAttempts >= operationAuthModes.length) {\n                                    logger.debug(`Mutation failed with authMode: ${operationAuthModes[authModeAttempts - 1]}`);\n                                    try {\n                                        await this.errorHandler({\n                                            recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                                            localModel: null,\n                                            message: error.message,\n                                            model: modelConstructor.name,\n                                            operation: opName,\n                                            errorType: getMutationErrorType(error),\n                                            process: ProcessName.sync,\n                                            remoteModel: null,\n                                            cause: error,\n                                        });\n                                    }\n                                    catch (e) {\n                                        logger.error('Mutation error handler failed with:', e);\n                                    }\n                                    throw error;\n                                }\n                                logger.debug(`Mutation failed with authMode: ${operationAuthModes[authModeAttempts - 1]}. Retrying with authMode: ${operationAuthModes[authModeAttempts]}`);\n                                return await authModeRetry();\n                            }\n                        };\n                        [result, opName, modelDefinition] = await authModeRetry();\n                    }\n                    catch (error) {\n                        if (error.message === 'Offline' ||\n                            error.message === 'RetryMutation') {\n                            continue;\n                        }\n                    }\n                    if (result === undefined) {\n                        logger.debug('done retrying');\n                        await this.storage.runExclusive(async (storage) => {\n                            await this.outbox.dequeue(storage);\n                        });\n                        continue;\n                    }\n                    const record = result.data[opName];\n                    let hasMore = false;\n                    await this.storage.runExclusive(async (storage) => {\n                        // using runExclusive to prevent possible race condition\n                        // when another record gets enqueued between dequeue and peek\n                        await this.outbox.dequeue(storage, record, operation);\n                        hasMore = (await this.outbox.peek(storage)) !== undefined;\n                    });\n                    this.observer?.next?.({\n                        operation,\n                        modelDefinition,\n                        model: record,\n                        hasMore,\n                    });\n                }\n                // pauses itself\n                this.pause();\n            }, 'mutation resume loop');\n        }\n    }\n    async jitteredRetry(namespaceName, model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent, authMode, onTerminate) {\n        return await retry(async (model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent) => {\n            const [query, variables, graphQLCondition, opName, modelDefinition] = this.createQueryVariables(namespaceName, model, operation, data, condition);\n            const authToken = await getTokenForCustomAuth(authMode, this.amplifyConfig);\n            const tryWith = {\n                query,\n                variables,\n                authMode,\n                authToken,\n            };\n            let attempt = 0;\n            const opType = this.opTypeFromTransformerOperation(operation);\n            const customUserAgentDetails = {\n                category: Category.DataStore,\n                action: DataStoreAction.GraphQl,\n            };\n            do {\n                try {\n                    const result = (await this.amplifyContext.InternalAPI.graphql(tryWith, undefined, customUserAgentDetails));\n                    // Use `as any` because TypeScript doesn't seem to like passing tuples\n                    // through generic params.\n                    return [result, opName, modelDefinition];\n                }\n                catch (err) {\n                    if (err.errors && err.errors.length > 0) {\n                        const [error] = err.errors;\n                        const { originalError: { code = null } = {} } = error;\n                        if (error.errorType === 'Unauthorized') {\n                            throw new NonRetryableError('Unauthorized');\n                        }\n                        if (error.message === 'Network Error' ||\n                            code === 'ECONNABORTED' // refers to axios timeout error caused by device's bad network condition\n                        ) {\n                            if (!this.processing) {\n                                throw new NonRetryableError('Offline');\n                            }\n                            // TODO: Check errors on different env (react-native or other browsers)\n                            throw new Error('Network Error');\n                        }\n                        if (error.errorType === 'ConflictUnhandled') {\n                            // TODO: add on ConflictConditionalCheck error query last from server\n                            attempt++;\n                            let retryWith;\n                            if (attempt > MAX_ATTEMPTS) {\n                                retryWith = DISCARD;\n                            }\n                            else {\n                                try {\n                                    retryWith = await this.conflictHandler({\n                                        modelConstructor,\n                                        localModel: this.modelInstanceCreator(modelConstructor, variables.input),\n                                        remoteModel: this.modelInstanceCreator(modelConstructor, error.data),\n                                        operation: opType,\n                                        attempts: attempt,\n                                    });\n                                }\n                                catch (err) {\n                                    logger.warn('conflict trycatch', err);\n                                    continue;\n                                }\n                            }\n                            if (retryWith === DISCARD) {\n                                // Query latest from server and notify merger\n                                const [[, opName, query]] = buildGraphQLOperation(this.schema.namespaces[namespaceName], modelDefinition, 'GET');\n                                const authToken = await getTokenForCustomAuth(authMode, this.amplifyConfig);\n                                const serverData = await this.amplifyContext.InternalAPI.graphql({\n                                    query,\n                                    variables: { id: variables.input.id },\n                                    authMode,\n                                    authToken,\n                                }, undefined, customUserAgentDetails);\n                                // onTerminate cancel graphql()\n                                return [serverData, opName, modelDefinition];\n                            }\n                            const namespace = this.schema.namespaces[namespaceName];\n                            // convert retry with to tryWith\n                            const updatedMutation = createMutationInstanceFromModelOperation(namespace.relationships, modelDefinition, opType, modelConstructor, retryWith, graphQLCondition, MutationEvent, this.modelInstanceCreator, mutationEvent.id);\n                            await this.storage.save(updatedMutation);\n                            throw new NonRetryableError('RetryMutation');\n                        }\n                        else {\n                            try {\n                                this.errorHandler({\n                                    recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                                    localModel: variables.input,\n                                    message: error.message,\n                                    operation,\n                                    errorType: getMutationErrorType(error),\n                                    errorInfo: error.errorInfo,\n                                    process: ProcessName.mutate,\n                                    cause: error,\n                                    remoteModel: error.data\n                                        ? this.modelInstanceCreator(modelConstructor, error.data)\n                                        : null,\n                                });\n                            }\n                            catch (err) {\n                                logger.warn('Mutation error handler failed with:', err);\n                            }\n                            finally {\n                                // Return empty tuple, dequeues the mutation\n                                return error.data\n                                    ? [\n                                        { data: { [opName]: error.data } },\n                                        opName,\n                                        modelDefinition,\n                                    ]\n                                    : [];\n                            }\n                        }\n                    }\n                    else {\n                        // Catch-all for client-side errors that don't come back in the `GraphQLError` format.\n                        // These errors should not be retried.\n                        throw new NonRetryableError(err);\n                    }\n                }\n            } while (tryWith);\n        }, [\n            model,\n            operation,\n            data,\n            condition,\n            modelConstructor,\n            MutationEvent,\n            mutationEvent,\n        ], safeJitteredBackoff, onTerminate);\n    }\n    createQueryVariables(namespaceName, model, operation, data, condition) {\n        const modelDefinition = this.schema.namespaces[namespaceName].models[model];\n        const { primaryKey } = this.schema.namespaces[namespaceName].keys[model];\n        const auth = modelDefinition.attributes?.find(a => a.type === 'auth');\n        const ownerFields = auth?.properties?.rules\n            .map(rule => rule.ownerField)\n            .filter(f => f) || ['owner'];\n        const queriesTuples = this.typeQuery.get(modelDefinition);\n        const [, opName, query] = queriesTuples.find(([transformerMutationType]) => transformerMutationType === operation);\n        const { _version, ...parsedData } = JSON.parse(data);\n        // include all the fields that comprise a custom PK if one is specified\n        const deleteInput = {};\n        if (primaryKey && primaryKey.length) {\n            for (const pkField of primaryKey) {\n                deleteInput[pkField] = parsedData[pkField];\n            }\n        }\n        else {\n            deleteInput[ID] = parsedData.id;\n        }\n        let mutationInput;\n        if (operation === TransformerMutationType.DELETE) {\n            // For DELETE mutations, only the key(s) are included in the input\n            mutationInput = deleteInput;\n        }\n        else {\n            // Otherwise, we construct the mutation input with the following logic\n            mutationInput = {};\n            const modelFields = Object.values(modelDefinition.fields);\n            for (const { name, type, association, isReadOnly } of modelFields) {\n                // omit readonly fields. cloud storage doesn't need them and won't take them!\n                if (isReadOnly) {\n                    continue;\n                }\n                // omit owner fields if it's `null`. cloud storage doesn't allow it.\n                if (ownerFields.includes(name) && parsedData[name] === null) {\n                    continue;\n                }\n                // model fields should be stripped out from the input\n                if (isModelFieldType(type)) {\n                    // except for belongs to relations - we need to replace them with the correct foreign key(s)\n                    if (isTargetNameAssociation(association) &&\n                        association.connectionType === 'BELONGS_TO') {\n                        const targetNames = extractTargetNamesFromSrc(association);\n                        if (targetNames) {\n                            // instead of including the connected model itself, we add its key(s) to the mutation input\n                            for (const targetName of targetNames) {\n                                mutationInput[targetName] = parsedData[targetName];\n                            }\n                        }\n                    }\n                    continue;\n                }\n                // scalar fields / non-model types\n                if (operation === TransformerMutationType.UPDATE) {\n                    if (!parsedData.hasOwnProperty(name)) {\n                        // for update mutations - strip out a field if it's unchanged\n                        continue;\n                    }\n                }\n                // all other fields are added to the input object\n                mutationInput[name] = parsedData[name];\n            }\n        }\n        // Build mutation variables input object\n        const input = {\n            ...mutationInput,\n            _version,\n        };\n        const graphQLCondition = JSON.parse(condition);\n        const variables = {\n            input,\n            ...(operation === TransformerMutationType.CREATE\n                ? {}\n                : {\n                    condition: Object.keys(graphQLCondition).length > 0\n                        ? graphQLCondition\n                        : null,\n                }),\n        };\n        return [query, variables, graphQLCondition, opName, modelDefinition];\n    }\n    opTypeFromTransformerOperation(operation) {\n        switch (operation) {\n            case TransformerMutationType.CREATE:\n                return OpType.INSERT;\n            case TransformerMutationType.DELETE:\n                return OpType.DELETE;\n            case TransformerMutationType.UPDATE:\n                return OpType.UPDATE;\n            case TransformerMutationType.GET: // Intentionally blank\n                break;\n            default:\n                throw new Error(`Invalid operation ${operation}`);\n        }\n        // because it makes TS happy ...\n        return undefined;\n    }\n    pause() {\n        this.processing = false;\n    }\n}\nconst MAX_RETRY_DELAY_MS = 5 * 60 * 1000;\nconst originalJitteredBackoff = jitteredBackoff(MAX_RETRY_DELAY_MS);\n/**\n * @private\n * Internal use of Amplify only.\n *\n * Wraps the jittered backoff calculation to retry Network Errors indefinitely.\n * Backs off according to original jittered retry logic until the original retry\n * logic hits its max. After this occurs, if the error is a Network Error, we\n * ignore the attempt count and return MAX_RETRY_DELAY_MS to retry forever (until\n * the request succeeds).\n *\n * @param attempt ignored\n * @param _args ignored\n * @param error tested to see if `.message` is 'Network Error'\n * @returns number | false :\n */\nexport const safeJitteredBackoff = (attempt, _args, error) => {\n    const attemptResult = originalJitteredBackoff(attempt);\n    // If this is the last attempt and it is a network error, we retry indefinitively every 5 minutes\n    if (attemptResult === false &&\n        (error || {}).message === 'Network Error') {\n        return MAX_RETRY_DELAY_MS;\n    }\n    return attemptResult;\n};\nexport { MutationProcessor };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}