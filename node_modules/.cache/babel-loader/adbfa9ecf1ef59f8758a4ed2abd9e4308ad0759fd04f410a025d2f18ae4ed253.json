{"ast":null,"code":"import * as idb from 'idb';\nimport { OpType, QueryOne, isPredicateGroup, isPredicateObj } from '../../types.mjs';\nimport { getStorename, keysEqual, traverseModel, isPrivateMode, isSafariCompatabilityMode, validatePredicate, inMemoryPagination } from '../../util.mjs';\nimport { StorageAdapterBase } from './StorageAdapterBase.mjs';\nimport { ConsoleLogger } from '@aws-amplify/core';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('DataStore');\n/**\n * The point after which queries composed of multiple simple OR conditions\n * should scan-and-filter instead of individual queries for each condition.\n *\n * At some point, this should be configurable and/or dynamic based on table\n * size and possibly even on observed average seek latency. For now, it's\n * based on an manual \"binary search\" for the breakpoint as measured in the\n * unit test suite. This isn't necessarily optimal. But, it's at least derived\n * empirically, rather than theoretically and without any verification!\n *\n * REMEMBER! If you run more realistic benchmarks and update this value, update\n * this comment so the validity and accuracy of future query tuning exercises\n * can be compared to the methods used to derive the current value. E.g.,\n *\n * 1. In browser benchmark > unit test benchmark\n * 2. Multi-browser benchmark > single browser benchmark\n * 3. Benchmarks of various table sizes > static table size benchmark\n *\n * etc...\n *\n */\nconst MULTI_OR_CONDITION_SCAN_BREAKPOINT = 7;\n//\nconst DB_VERSION = 3;\nclass IndexedDBAdapter extends StorageAdapterBase {\n  constructor() {\n    super(...arguments);\n    this.safariCompatabilityMode = false;\n    /**\n     * Checks the given path against the browser's IndexedDB implementation for\n     * necessary compatibility transformations, applying those transforms if needed.\n     *\n     * @param `keyArr` strings to compatibilize for browser-indexeddb index operations\n     * @returns An array or string, depending on and given key,\n     * that is ensured to be compatible with the IndexedDB implementation's nuances.\n     */\n    this.canonicalKeyPath = keyArr => {\n      if (this.safariCompatabilityMode) {\n        return keyArr.length > 1 ? keyArr : keyArr[0];\n      }\n      return keyArr;\n    };\n    //#endregion\n  }\n  // checks are called by StorageAdapterBase class\n  async preSetUpChecks() {\n    await this.checkPrivate();\n    await this.setSafariCompatabilityMode();\n  }\n  async preOpCheck() {\n    await this.checkPrivate();\n  }\n  /**\n   * Initialize IndexedDB database\n   * Create new DB if one doesn't exist\n   * Upgrade outdated DB\n   *\n   * Called by `StorageAdapterBase.setUp()`\n   *\n   * @returns IDB Database instance\n   */\n  async initDb() {\n    return await idb.openDB(this.dbName, DB_VERSION, {\n      upgrade: async (db, oldVersion, newVersion, txn) => {\n        // create new database\n        if (oldVersion === 0) {\n          Object.keys(this.schema.namespaces).forEach(namespaceName => {\n            const namespace = this.schema.namespaces[namespaceName];\n            Object.keys(namespace.models).forEach(modelName => {\n              const storeName = getStorename(namespaceName, modelName);\n              this.createObjectStoreForModel(db, namespaceName, storeName, modelName);\n            });\n          });\n          return;\n        }\n        // migrate existing database to latest schema\n        if ((oldVersion === 1 || oldVersion === 2) && newVersion === 3) {\n          try {\n            for (const storeName of txn.objectStoreNames) {\n              const origStore = txn.objectStore(storeName);\n              // rename original store\n              const tmpName = \"tmp_\".concat(storeName);\n              origStore.name = tmpName;\n              const {\n                namespaceName,\n                modelName\n              } = this.getNamespaceAndModelFromStorename(storeName);\n              const modelInCurrentSchema = (modelName in this.schema.namespaces[namespaceName].models);\n              if (!modelInCurrentSchema) {\n                // delete original\n                db.deleteObjectStore(tmpName);\n                continue;\n              }\n              const newStore = this.createObjectStoreForModel(db, namespaceName, storeName, modelName);\n              let cursor = await origStore.openCursor();\n              let count = 0;\n              // Copy data from original to new\n              while (cursor && cursor.value) {\n                // we don't pass key, since they are all new entries in the new store\n                await newStore.put(cursor.value);\n                cursor = await cursor.continue();\n                count++;\n              }\n              // delete original\n              db.deleteObjectStore(tmpName);\n              logger.debug(\"\".concat(count, \" \").concat(storeName, \" records migrated\"));\n            }\n            // add new models created after IndexedDB, but before migration\n            // this case may happen when a user has not opened an app for\n            // some time and a new model is added during that time\n            Object.keys(this.schema.namespaces).forEach(namespaceName => {\n              const namespace = this.schema.namespaces[namespaceName];\n              const objectStoreNames = new Set(txn.objectStoreNames);\n              Object.keys(namespace.models).map(modelName => {\n                return [modelName, getStorename(namespaceName, modelName)];\n              }).filter(_ref => {\n                let [, storeName] = _ref;\n                return !objectStoreNames.has(storeName);\n              }).forEach(_ref2 => {\n                let [modelName, storeName] = _ref2;\n                this.createObjectStoreForModel(db, namespaceName, storeName, modelName);\n              });\n            });\n          } catch (error) {\n            logger.error('Error migrating IndexedDB data', error);\n            txn.abort();\n            throw error;\n          }\n          return;\n        }\n      }\n    });\n  }\n  async _get(storeOrStoreName, keyArr) {\n    let index;\n    if (typeof storeOrStoreName === 'string') {\n      const storeName = storeOrStoreName;\n      index = this.db.transaction(storeName, 'readonly').store.index('byPk');\n    } else {\n      const store = storeOrStoreName;\n      index = store.index('byPk');\n    }\n    const result = await index.get(this.canonicalKeyPath(keyArr));\n    return result;\n  }\n  async clear() {\n    var _this$db;\n    await this.checkPrivate();\n    (_this$db = this.db) === null || _this$db === void 0 || _this$db.close();\n    await idb.deleteDB(this.dbName);\n    this.db = undefined;\n    this.initPromise = undefined;\n  }\n  async save(model, condition) {\n    await this.checkPrivate();\n    const {\n      storeName,\n      set,\n      connectionStoreNames,\n      modelKeyValues\n    } = this.saveMetadata(model);\n    const tx = this.db.transaction([storeName, ...Array.from(set.values())], 'readwrite');\n    const store = tx.objectStore(storeName);\n    const fromDB = await this._get(store, modelKeyValues);\n    this.validateSaveCondition(condition, fromDB);\n    const result = [];\n    for await (const resItem of connectionStoreNames) {\n      const {\n        storeName,\n        item,\n        instance,\n        keys\n      } = resItem;\n      const store = tx.objectStore(storeName);\n      const itemKeyValues = keys.map(key => item[key]);\n      const fromDB = await this._get(store, itemKeyValues);\n      const opType = fromDB ? OpType.UPDATE : OpType.INSERT;\n      if (keysEqual(itemKeyValues, modelKeyValues) || opType === OpType.INSERT) {\n        const key = await store.index('byPk').getKey(this.canonicalKeyPath(itemKeyValues));\n        await store.put(item, key);\n        result.push([instance, opType]);\n      }\n    }\n    await tx.done;\n    return result;\n  }\n  async query(modelConstructor, predicate, pagination) {\n    await this.checkPrivate();\n    const {\n      storeName,\n      namespaceName,\n      queryByKey,\n      predicates,\n      hasSort,\n      hasPagination\n    } = this.queryMetadata(modelConstructor, predicate, pagination);\n    const records = await (async () => {\n      //\n      // NOTE: @svidgen explored removing this and letting query() take care of automatic\n      // index leveraging. This would eliminate some amount of very similar code.\n      // But, getAll is slightly slower than get()\n      //\n      // On Chrome:\n      //   ~700ms vs ~1175ms per 10k reads.\n      //\n      // You can (and should) check my work here:\n      // \thttps://gist.github.com/svidgen/74e55d573b19c3e5432b1b5bdf0f4d96\n      //\n      if (queryByKey) {\n        const record = await this.getByKey(storeName, queryByKey);\n        return record ? [record] : [];\n      }\n      if (predicates) {\n        const filtered = await this.filterOnPredicate(storeName, predicates);\n        return this.inMemoryPagination(filtered, pagination);\n      }\n      if (hasSort) {\n        const all = await this.getAll(storeName);\n        return this.inMemoryPagination(all, pagination);\n      }\n      if (hasPagination) {\n        return this.enginePagination(storeName, pagination);\n      }\n      return this.getAll(storeName);\n    })();\n    return await this.load(namespaceName, modelConstructor.name, records);\n  }\n  async queryOne(modelConstructor) {\n    let firstOrLast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : QueryOne.FIRST;\n    await this.checkPrivate();\n    const storeName = this.getStorenameForModel(modelConstructor);\n    const cursor = await this.db.transaction([storeName], 'readonly').objectStore(storeName).openCursor(undefined, firstOrLast === QueryOne.FIRST ? 'next' : 'prev');\n    const result = cursor ? cursor.value : undefined;\n    return result && this.modelInstanceCreator(modelConstructor, result);\n  }\n  async batchSave(modelConstructor, items) {\n    await this.checkPrivate();\n    if (items.length === 0) {\n      return [];\n    }\n    const modelName = modelConstructor.name;\n    const namespaceName = this.namespaceResolver(modelConstructor);\n    const storeName = this.getStorenameForModel(modelConstructor);\n    const result = [];\n    const txn = this.db.transaction(storeName, 'readwrite');\n    const store = txn.store;\n    for (const item of items) {\n      const model = this.modelInstanceCreator(modelConstructor, item);\n      const connectedModels = traverseModel(modelName, model, this.schema.namespaces[namespaceName], this.modelInstanceCreator, this.getModelConstructorByModelName);\n      const keyValues = this.getIndexKeyValuesFromModel(model);\n      const {\n        _deleted\n      } = item;\n      const index = store.index('byPk');\n      const key = await index.getKey(this.canonicalKeyPath(keyValues));\n      if (!_deleted) {\n        const {\n          instance\n        } = connectedModels.find(_ref3 => {\n          let {\n            instance\n          } = _ref3;\n          const instanceKeyValues = this.getIndexKeyValuesFromModel(instance);\n          return keysEqual(instanceKeyValues, keyValues);\n        });\n        result.push([instance, key ? OpType.UPDATE : OpType.INSERT]);\n        await store.put(instance, key);\n      } else {\n        result.push([item, OpType.DELETE]);\n        if (key) {\n          await store.delete(key);\n        }\n      }\n    }\n    await txn.done;\n    return result;\n  }\n  async deleteItem(deleteQueue) {\n    const connectionStoreNames = deleteQueue.map(_ref4 => {\n      let {\n        storeName\n      } = _ref4;\n      return storeName;\n    });\n    const tx = this.db.transaction([...connectionStoreNames], 'readwrite');\n    for await (const deleteItem of deleteQueue) {\n      const {\n        storeName,\n        items\n      } = deleteItem;\n      const store = tx.objectStore(storeName);\n      for await (const item of items) {\n        if (item) {\n          let key;\n          if (typeof item === 'object') {\n            const keyValues = this.getIndexKeyValuesFromModel(item);\n            key = await store.index('byPk').getKey(this.canonicalKeyPath(keyValues));\n          } else {\n            const itemKey = item.toString();\n            key = await store.index('byPk').getKey(itemKey);\n          }\n          if (key !== undefined) {\n            await store.delete(key);\n          }\n        }\n      }\n    }\n  }\n  //#region platform-specific helper methods\n  async checkPrivate() {\n    const isPrivate = await isPrivateMode().then(isPrivate => {\n      return isPrivate;\n    });\n    if (isPrivate) {\n      logger.error(\"IndexedDB not supported in this browser's private mode\");\n      return Promise.reject(\"IndexedDB not supported in this browser's private mode\");\n    } else {\n      return Promise.resolve();\n    }\n  }\n  /**\n   * Whether the browser's implementation of IndexedDB is coercing single-field\n   * indexes to a scalar key.\n   *\n   * If this returns `true`, we need to treat indexes containing a single field\n   * as scalars.\n   *\n   * See PR description for reference:\n   * https://github.com/aws-amplify/amplify-js/pull/10527\n   */\n  async setSafariCompatabilityMode() {\n    this.safariCompatabilityMode = await isSafariCompatabilityMode();\n    if (this.safariCompatabilityMode === true) {\n      logger.debug('IndexedDB Adapter is running in Safari Compatability Mode');\n    }\n  }\n  getNamespaceAndModelFromStorename(storeName) {\n    const [namespaceName, ...modelNameArr] = storeName.split('_');\n    return {\n      namespaceName,\n      modelName: modelNameArr.join('_')\n    };\n  }\n  createObjectStoreForModel(db, namespaceName, storeName, modelName) {\n    const store = db.createObjectStore(storeName, {\n      autoIncrement: true\n    });\n    const {\n      indexes\n    } = this.schema.namespaces[namespaceName].relationships[modelName];\n    indexes.forEach(_ref5 => {\n      let [idxName, keyPath, options] = _ref5;\n      store.createIndex(idxName, keyPath, options);\n    });\n    return store;\n  }\n  async getByKey(storeName, keyValue) {\n    return await this._get(storeName, keyValue);\n  }\n  async getAll(storeName) {\n    return await this.db.getAll(storeName);\n  }\n  /**\n   * Tries to generate an index fetcher for the given predicates. Assumes\n   * that the given predicate conditions are contained by an AND group and\n   * should therefore all match a single record.\n   *\n   * @param storeName The table to query.\n   * @param predicates The predicates to try to AND together.\n   * @param transaction\n   */\n  matchingIndexQueries(storeName, predicates, transaction) {\n    // could be expanded later to include `exec()` and a `cardinality` estimate?\n    const queries = [];\n    const predicateIndex = new Map();\n    for (const predicate of predicates) {\n      predicateIndex.set(String(predicate.field), predicate);\n    }\n    const store = transaction.objectStore(storeName);\n    for (const name of store.indexNames) {\n      const idx = store.index(name);\n      const keypath = Array.isArray(idx.keyPath) ? idx.keyPath : [idx.keyPath];\n      const matchingPredicateValues = [];\n      for (const field of keypath) {\n        const p = predicateIndex.get(field);\n        if (p && p.operand !== null && p.operand !== undefined) {\n          matchingPredicateValues.push(p.operand);\n        } else {\n          break;\n        }\n      }\n      // if we have a matching predicate field for each component of this index,\n      // we can build a query for it. otherwise, we can't.\n      if (matchingPredicateValues.length === keypath.length) {\n        // re-create a transaction, because the transaction used to fetch the\n        // indexes may no longer be active.\n        queries.push(() => this.db.transaction(storeName).objectStore(storeName).index(name).getAll(this.canonicalKeyPath(matchingPredicateValues)));\n      }\n    }\n    return queries;\n  }\n  async baseQueryIndex(storeName, predicates, transaction) {\n    let {\n      predicates: predicateObjs,\n      type\n    } = predicates;\n    // the predicate objects we care about tend to be nested at least\n    // one level down: `{and: {or: {and: { <the predicates we want> }}}}`\n    // so, we unpack and/or groups until we find a group with more than 1\n    // child OR a child that is not a group (and is therefore a predicate \"object\").\n    while (predicateObjs.length === 1 && isPredicateGroup(predicateObjs[0]) && predicateObjs[0].type !== 'not') {\n      type = predicateObjs[0].type;\n      predicateObjs = predicateObjs[0].predicates;\n    }\n    const fieldPredicates = predicateObjs.filter(p => isPredicateObj(p) && p.operator === 'eq');\n    // several sub-queries could occur here. explicitly start a txn here to avoid\n    // opening/closing multiple txns.\n    const txn = transaction || this.db.transaction(storeName);\n    let result = {};\n    // `or` conditions, if usable, need to generate multiple queries. this is unlike\n    // `and` conditions, which should just be combined.\n    if (type === 'or') {\n      /**\n       * Base queries for each child group.\n       *\n       * For each child group, if it's an AND condition that results in a single\n       * subordinate \"base query\", we can use it. if it's any more complicated\n       * than that, it's not a simple join condition we want to use.\n       */\n      const groupQueries = await Promise.all(predicateObjs.filter(o => isPredicateGroup(o) && o.type === 'and').map(o => this.baseQueryIndex(storeName, o, txn))).then(queries => queries.filter(q => q.indexedQueries.length === 1).map(i => i.indexedQueries));\n      /**\n       * Base queries for each simple child \"object\" (field condition).\n       */\n      const objectQueries = predicateObjs.filter(o => isPredicateObj(o)).map(o => this.matchingIndexQueries(storeName, [o], txn));\n      const indexedQueries = [...groupQueries, ...objectQueries].map(q => q[0]).filter(i => i);\n      // if, after hunting for base queries, we don't have exactly 1 base query\n      // for each child group + object, stop trying to optimize. we're not dealing\n      // with a simple query that fits the intended optimization path.\n      if (predicateObjs.length > indexedQueries.length) {\n        result = {\n          groupType: null,\n          indexedQueries: []\n        };\n      } else {\n        result = {\n          groupType: 'or',\n          indexedQueries\n        };\n      }\n    } else if (type === 'and') {\n      // our potential indexes or lacks thereof.\n      // note that we're only optimizing for `eq` right now.\n      result = {\n        groupType: type,\n        indexedQueries: this.matchingIndexQueries(storeName, fieldPredicates, txn)\n      };\n    } else {\n      result = {\n        groupType: null,\n        indexedQueries: []\n      };\n    }\n    // Explicitly wait for txns from index queries to complete before proceding.\n    // This helps ensure IndexedDB is in a stable, ready state. Else, subseqeuent\n    // qeuries can sometimes appear to deadlock (at least in FakeIndexedDB).\n    // (Unless we were *given* the transaction -- we'll assume the parent handles it.)\n    if (!transaction) await txn.done;\n    return result;\n  }\n  async filterOnPredicate(storeName, predicates) {\n    const {\n      predicates: predicateObjs,\n      type\n    } = predicates;\n    const {\n      groupType,\n      indexedQueries\n    } = await this.baseQueryIndex(storeName, predicates);\n    // where we'll accumulate candidate results, which will be filtered at the end.\n    let candidateResults;\n    // semi-naive implementation:\n    if (groupType === 'and' && indexedQueries.length > 0) {\n      // each condition must be satsified, we can form a base set with any\n      // ONE of those conditions and then filter.\n      candidateResults = await indexedQueries[0]();\n    } else if (groupType === 'or' && indexedQueries.length > 0 && indexedQueries.length <= MULTI_OR_CONDITION_SCAN_BREAKPOINT) {\n      // NOTE: each condition implies a potentially distinct set. we only benefit\n      // from using indexes here if EVERY condition uses an index. if any one\n      // index requires a table scan, we gain nothing from the indexes.\n      // NOTE: results must be DISTINCT-ified if we leverage indexes.\n      const distinctResults = new Map();\n      for (const query of indexedQueries) {\n        const resultGroup = await query();\n        for (const item of resultGroup) {\n          const distinctificationString = JSON.stringify(item);\n          distinctResults.set(distinctificationString, item);\n        }\n      }\n      // we could conceivably check for special conditions and return early here.\n      // but, this is simpler and has not yet had a measurable performance impact.\n      candidateResults = Array.from(distinctResults.values());\n    } else {\n      // nothing intelligent we can do with `not` groups unless or until we start\n      // smashing comparison operators against indexes -- at which point we could\n      // perform some reversal here.\n      candidateResults = await this.getAll(storeName);\n    }\n    const filtered = predicateObjs ? candidateResults.filter(m => validatePredicate(m, type, predicateObjs)) : candidateResults;\n    return filtered;\n  }\n  inMemoryPagination(records, pagination) {\n    return inMemoryPagination(records, pagination);\n  }\n  async enginePagination(storeName, pagination) {\n    let result;\n    if (pagination) {\n      const {\n        page = 0,\n        limit = 0\n      } = pagination;\n      const initialRecord = Math.max(0, page * limit) || 0;\n      let cursor = await this.db.transaction(storeName).objectStore(storeName).openCursor();\n      if (cursor && initialRecord > 0) {\n        await cursor.advance(initialRecord);\n      }\n      const pageResults = [];\n      const hasLimit = typeof limit === 'number' && limit > 0;\n      while (cursor && cursor.value) {\n        pageResults.push(cursor.value);\n        if (hasLimit && pageResults.length === limit) {\n          break;\n        }\n        cursor = await cursor.continue();\n      }\n      result = pageResults;\n    } else {\n      result = await this.db.getAll(storeName);\n    }\n    return result;\n  }\n}\nvar IndexedDBAdapter$1 = new IndexedDBAdapter();\nexport { IndexedDBAdapter$1 as default };","map":{"version":3,"names":["logger","ConsoleLogger","MULTI_OR_CONDITION_SCAN_BREAKPOINT","DB_VERSION","IndexedDBAdapter","StorageAdapterBase","constructor","arguments","safariCompatabilityMode","canonicalKeyPath","keyArr","length","preSetUpChecks","checkPrivate","setSafariCompatabilityMode","preOpCheck","initDb","idb","openDB","dbName","upgrade","db","oldVersion","newVersion","txn","Object","keys","schema","namespaces","forEach","namespaceName","namespace","models","modelName","storeName","getStorename","createObjectStoreForModel","objectStoreNames","origStore","objectStore","tmpName","concat","name","getNamespaceAndModelFromStorename","modelInCurrentSchema","deleteObjectStore","newStore","cursor","openCursor","count","value","put","continue","debug","Set","map","filter","_ref","has","_ref2","error","abort","_get","storeOrStoreName","index","transaction","store","result","get","clear","_this$db","close","deleteDB","undefined","initPromise","save","model","condition","set","connectionStoreNames","modelKeyValues","saveMetadata","tx","Array","from","values","fromDB","validateSaveCondition","resItem","item","instance","itemKeyValues","key","opType","OpType","UPDATE","INSERT","keysEqual","getKey","push","done","query","modelConstructor","predicate","pagination","queryByKey","predicates","hasSort","hasPagination","queryMetadata","records","record","getByKey","filtered","filterOnPredicate","inMemoryPagination","all","getAll","enginePagination","load","queryOne","firstOrLast","QueryOne","FIRST","getStorenameForModel","modelInstanceCreator","batchSave","items","namespaceResolver","connectedModels","traverseModel","getModelConstructorByModelName","keyValues","getIndexKeyValuesFromModel","_deleted","find","_ref3","instanceKeyValues","DELETE","delete","deleteItem","deleteQueue","_ref4","itemKey","toString","isPrivate","isPrivateMode","then","Promise","reject","resolve","isSafariCompatabilityMode","modelNameArr","split","join","createObjectStore","autoIncrement","indexes","relationships","_ref5","idxName","keyPath","options","createIndex","keyValue","matchingIndexQueries","queries","predicateIndex","Map","String","field","indexNames","idx","keypath","isArray","matchingPredicateValues","p","operand","baseQueryIndex","predicateObjs","type","isPredicateGroup","fieldPredicates","isPredicateObj","operator","groupQueries","o","q","indexedQueries","i","objectQueries","groupType","candidateResults","distinctResults","resultGroup","distinctificationString","JSON","stringify","m","validatePredicate","page","limit","initialRecord","Math","max","advance","pageResults","hasLimit","IndexedDBAdapter$1"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/storage/adapter/IndexedDBAdapter.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport * as idb from 'idb';\nimport { isPredicateObj, isPredicateGroup, OpType, QueryOne, } from '../../types';\nimport { isPrivateMode, traverseModel, validatePredicate, inMemoryPagination, keysEqual, getStorename, isSafariCompatabilityMode, } from '../../util';\nimport { StorageAdapterBase } from './StorageAdapterBase';\nimport { ConsoleLogger } from '@aws-amplify/core';\nconst logger = new ConsoleLogger('DataStore');\n/**\n * The point after which queries composed of multiple simple OR conditions\n * should scan-and-filter instead of individual queries for each condition.\n *\n * At some point, this should be configurable and/or dynamic based on table\n * size and possibly even on observed average seek latency. For now, it's\n * based on an manual \"binary search\" for the breakpoint as measured in the\n * unit test suite. This isn't necessarily optimal. But, it's at least derived\n * empirically, rather than theoretically and without any verification!\n *\n * REMEMBER! If you run more realistic benchmarks and update this value, update\n * this comment so the validity and accuracy of future query tuning exercises\n * can be compared to the methods used to derive the current value. E.g.,\n *\n * 1. In browser benchmark > unit test benchmark\n * 2. Multi-browser benchmark > single browser benchmark\n * 3. Benchmarks of various table sizes > static table size benchmark\n *\n * etc...\n *\n */\nconst MULTI_OR_CONDITION_SCAN_BREAKPOINT = 7;\n//\nconst DB_VERSION = 3;\nclass IndexedDBAdapter extends StorageAdapterBase {\n    constructor() {\n        super(...arguments);\n        this.safariCompatabilityMode = false;\n        /**\n         * Checks the given path against the browser's IndexedDB implementation for\n         * necessary compatibility transformations, applying those transforms if needed.\n         *\n         * @param `keyArr` strings to compatibilize for browser-indexeddb index operations\n         * @returns An array or string, depending on and given key,\n         * that is ensured to be compatible with the IndexedDB implementation's nuances.\n         */\n        this.canonicalKeyPath = (keyArr) => {\n            if (this.safariCompatabilityMode) {\n                return keyArr.length > 1 ? keyArr : keyArr[0];\n            }\n            return keyArr;\n        };\n        //#endregion\n    }\n    // checks are called by StorageAdapterBase class\n    async preSetUpChecks() {\n        await this.checkPrivate();\n        await this.setSafariCompatabilityMode();\n    }\n    async preOpCheck() {\n        await this.checkPrivate();\n    }\n    /**\n     * Initialize IndexedDB database\n     * Create new DB if one doesn't exist\n     * Upgrade outdated DB\n     *\n     * Called by `StorageAdapterBase.setUp()`\n     *\n     * @returns IDB Database instance\n     */\n    async initDb() {\n        return await idb.openDB(this.dbName, DB_VERSION, {\n            upgrade: async (db, oldVersion, newVersion, txn) => {\n                // create new database\n                if (oldVersion === 0) {\n                    Object.keys(this.schema.namespaces).forEach(namespaceName => {\n                        const namespace = this.schema.namespaces[namespaceName];\n                        Object.keys(namespace.models).forEach(modelName => {\n                            const storeName = getStorename(namespaceName, modelName);\n                            this.createObjectStoreForModel(db, namespaceName, storeName, modelName);\n                        });\n                    });\n                    return;\n                }\n                // migrate existing database to latest schema\n                if ((oldVersion === 1 || oldVersion === 2) && newVersion === 3) {\n                    try {\n                        for (const storeName of txn.objectStoreNames) {\n                            const origStore = txn.objectStore(storeName);\n                            // rename original store\n                            const tmpName = `tmp_${storeName}`;\n                            origStore.name = tmpName;\n                            const { namespaceName, modelName } = this.getNamespaceAndModelFromStorename(storeName);\n                            const modelInCurrentSchema = modelName in this.schema.namespaces[namespaceName].models;\n                            if (!modelInCurrentSchema) {\n                                // delete original\n                                db.deleteObjectStore(tmpName);\n                                continue;\n                            }\n                            const newStore = this.createObjectStoreForModel(db, namespaceName, storeName, modelName);\n                            let cursor = await origStore.openCursor();\n                            let count = 0;\n                            // Copy data from original to new\n                            while (cursor && cursor.value) {\n                                // we don't pass key, since they are all new entries in the new store\n                                await newStore.put(cursor.value);\n                                cursor = await cursor.continue();\n                                count++;\n                            }\n                            // delete original\n                            db.deleteObjectStore(tmpName);\n                            logger.debug(`${count} ${storeName} records migrated`);\n                        }\n                        // add new models created after IndexedDB, but before migration\n                        // this case may happen when a user has not opened an app for\n                        // some time and a new model is added during that time\n                        Object.keys(this.schema.namespaces).forEach(namespaceName => {\n                            const namespace = this.schema.namespaces[namespaceName];\n                            const objectStoreNames = new Set(txn.objectStoreNames);\n                            Object.keys(namespace.models)\n                                .map(modelName => {\n                                return [modelName, getStorename(namespaceName, modelName)];\n                            })\n                                .filter(([, storeName]) => !objectStoreNames.has(storeName))\n                                .forEach(([modelName, storeName]) => {\n                                this.createObjectStoreForModel(db, namespaceName, storeName, modelName);\n                            });\n                        });\n                    }\n                    catch (error) {\n                        logger.error('Error migrating IndexedDB data', error);\n                        txn.abort();\n                        throw error;\n                    }\n                    return;\n                }\n            },\n        });\n    }\n    async _get(storeOrStoreName, keyArr) {\n        let index;\n        if (typeof storeOrStoreName === 'string') {\n            const storeName = storeOrStoreName;\n            index = this.db.transaction(storeName, 'readonly').store.index('byPk');\n        }\n        else {\n            const store = storeOrStoreName;\n            index = store.index('byPk');\n        }\n        const result = await index.get(this.canonicalKeyPath(keyArr));\n        return result;\n    }\n    async clear() {\n        await this.checkPrivate();\n        this.db?.close();\n        await idb.deleteDB(this.dbName);\n        this.db = undefined;\n        this.initPromise = undefined;\n    }\n    async save(model, condition) {\n        await this.checkPrivate();\n        const { storeName, set, connectionStoreNames, modelKeyValues } = this.saveMetadata(model);\n        const tx = this.db.transaction([storeName, ...Array.from(set.values())], 'readwrite');\n        const store = tx.objectStore(storeName);\n        const fromDB = await this._get(store, modelKeyValues);\n        this.validateSaveCondition(condition, fromDB);\n        const result = [];\n        for await (const resItem of connectionStoreNames) {\n            const { storeName, item, instance, keys } = resItem;\n            const store = tx.objectStore(storeName);\n            const itemKeyValues = keys.map(key => item[key]);\n            const fromDB = await this._get(store, itemKeyValues);\n            const opType = fromDB ? OpType.UPDATE : OpType.INSERT;\n            if (keysEqual(itemKeyValues, modelKeyValues) ||\n                opType === OpType.INSERT) {\n                const key = await store\n                    .index('byPk')\n                    .getKey(this.canonicalKeyPath(itemKeyValues));\n                await store.put(item, key);\n                result.push([instance, opType]);\n            }\n        }\n        await tx.done;\n        return result;\n    }\n    async query(modelConstructor, predicate, pagination) {\n        await this.checkPrivate();\n        const { storeName, namespaceName, queryByKey, predicates, hasSort, hasPagination, } = this.queryMetadata(modelConstructor, predicate, pagination);\n        const records = (await (async () => {\n            //\n            // NOTE: @svidgen explored removing this and letting query() take care of automatic\n            // index leveraging. This would eliminate some amount of very similar code.\n            // But, getAll is slightly slower than get()\n            //\n            // On Chrome:\n            //   ~700ms vs ~1175ms per 10k reads.\n            //\n            // You can (and should) check my work here:\n            // \thttps://gist.github.com/svidgen/74e55d573b19c3e5432b1b5bdf0f4d96\n            //\n            if (queryByKey) {\n                const record = await this.getByKey(storeName, queryByKey);\n                return record ? [record] : [];\n            }\n            if (predicates) {\n                const filtered = await this.filterOnPredicate(storeName, predicates);\n                return this.inMemoryPagination(filtered, pagination);\n            }\n            if (hasSort) {\n                const all = await this.getAll(storeName);\n                return this.inMemoryPagination(all, pagination);\n            }\n            if (hasPagination) {\n                return this.enginePagination(storeName, pagination);\n            }\n            return this.getAll(storeName);\n        })());\n        return await this.load(namespaceName, modelConstructor.name, records);\n    }\n    async queryOne(modelConstructor, firstOrLast = QueryOne.FIRST) {\n        await this.checkPrivate();\n        const storeName = this.getStorenameForModel(modelConstructor);\n        const cursor = await this.db\n            .transaction([storeName], 'readonly')\n            .objectStore(storeName)\n            .openCursor(undefined, firstOrLast === QueryOne.FIRST ? 'next' : 'prev');\n        const result = cursor ? cursor.value : undefined;\n        return result && this.modelInstanceCreator(modelConstructor, result);\n    }\n    async batchSave(modelConstructor, items) {\n        await this.checkPrivate();\n        if (items.length === 0) {\n            return [];\n        }\n        const modelName = modelConstructor.name;\n        const namespaceName = this.namespaceResolver(modelConstructor);\n        const storeName = this.getStorenameForModel(modelConstructor);\n        const result = [];\n        const txn = this.db.transaction(storeName, 'readwrite');\n        const store = txn.store;\n        for (const item of items) {\n            const model = this.modelInstanceCreator(modelConstructor, item);\n            const connectedModels = traverseModel(modelName, model, this.schema.namespaces[namespaceName], this.modelInstanceCreator, this.getModelConstructorByModelName);\n            const keyValues = this.getIndexKeyValuesFromModel(model);\n            const { _deleted } = item;\n            const index = store.index('byPk');\n            const key = await index.getKey(this.canonicalKeyPath(keyValues));\n            if (!_deleted) {\n                const { instance } = connectedModels.find(({ instance }) => {\n                    const instanceKeyValues = this.getIndexKeyValuesFromModel(instance);\n                    return keysEqual(instanceKeyValues, keyValues);\n                });\n                result.push([\n                    instance,\n                    key ? OpType.UPDATE : OpType.INSERT,\n                ]);\n                await store.put(instance, key);\n            }\n            else {\n                result.push([item, OpType.DELETE]);\n                if (key) {\n                    await store.delete(key);\n                }\n            }\n        }\n        await txn.done;\n        return result;\n    }\n    async deleteItem(deleteQueue) {\n        const connectionStoreNames = deleteQueue.map(({ storeName }) => {\n            return storeName;\n        });\n        const tx = this.db.transaction([...connectionStoreNames], 'readwrite');\n        for await (const deleteItem of deleteQueue) {\n            const { storeName, items } = deleteItem;\n            const store = tx.objectStore(storeName);\n            for await (const item of items) {\n                if (item) {\n                    let key;\n                    if (typeof item === 'object') {\n                        const keyValues = this.getIndexKeyValuesFromModel(item);\n                        key = await store\n                            .index('byPk')\n                            .getKey(this.canonicalKeyPath(keyValues));\n                    }\n                    else {\n                        const itemKey = item.toString();\n                        key = await store.index('byPk').getKey(itemKey);\n                    }\n                    if (key !== undefined) {\n                        await store.delete(key);\n                    }\n                }\n            }\n        }\n    }\n    //#region platform-specific helper methods\n    async checkPrivate() {\n        const isPrivate = await isPrivateMode().then(isPrivate => {\n            return isPrivate;\n        });\n        if (isPrivate) {\n            logger.error(\"IndexedDB not supported in this browser's private mode\");\n            return Promise.reject(\"IndexedDB not supported in this browser's private mode\");\n        }\n        else {\n            return Promise.resolve();\n        }\n    }\n    /**\n     * Whether the browser's implementation of IndexedDB is coercing single-field\n     * indexes to a scalar key.\n     *\n     * If this returns `true`, we need to treat indexes containing a single field\n     * as scalars.\n     *\n     * See PR description for reference:\n     * https://github.com/aws-amplify/amplify-js/pull/10527\n     */\n    async setSafariCompatabilityMode() {\n        this.safariCompatabilityMode = await isSafariCompatabilityMode();\n        if (this.safariCompatabilityMode === true) {\n            logger.debug('IndexedDB Adapter is running in Safari Compatability Mode');\n        }\n    }\n    getNamespaceAndModelFromStorename(storeName) {\n        const [namespaceName, ...modelNameArr] = storeName.split('_');\n        return {\n            namespaceName,\n            modelName: modelNameArr.join('_'),\n        };\n    }\n    createObjectStoreForModel(db, namespaceName, storeName, modelName) {\n        const store = db.createObjectStore(storeName, {\n            autoIncrement: true,\n        });\n        const { indexes } = this.schema.namespaces[namespaceName].relationships[modelName];\n        indexes.forEach(([idxName, keyPath, options]) => {\n            store.createIndex(idxName, keyPath, options);\n        });\n        return store;\n    }\n    async getByKey(storeName, keyValue) {\n        return await this._get(storeName, keyValue);\n    }\n    async getAll(storeName) {\n        return await this.db.getAll(storeName);\n    }\n    /**\n     * Tries to generate an index fetcher for the given predicates. Assumes\n     * that the given predicate conditions are contained by an AND group and\n     * should therefore all match a single record.\n     *\n     * @param storeName The table to query.\n     * @param predicates The predicates to try to AND together.\n     * @param transaction\n     */\n    matchingIndexQueries(storeName, predicates, transaction) {\n        // could be expanded later to include `exec()` and a `cardinality` estimate?\n        const queries = [];\n        const predicateIndex = new Map();\n        for (const predicate of predicates) {\n            predicateIndex.set(String(predicate.field), predicate);\n        }\n        const store = transaction.objectStore(storeName);\n        for (const name of store.indexNames) {\n            const idx = store.index(name);\n            const keypath = Array.isArray(idx.keyPath) ? idx.keyPath : [idx.keyPath];\n            const matchingPredicateValues = [];\n            for (const field of keypath) {\n                const p = predicateIndex.get(field);\n                if (p && p.operand !== null && p.operand !== undefined) {\n                    matchingPredicateValues.push(p.operand);\n                }\n                else {\n                    break;\n                }\n            }\n            // if we have a matching predicate field for each component of this index,\n            // we can build a query for it. otherwise, we can't.\n            if (matchingPredicateValues.length === keypath.length) {\n                // re-create a transaction, because the transaction used to fetch the\n                // indexes may no longer be active.\n                queries.push(() => this.db\n                    .transaction(storeName)\n                    .objectStore(storeName)\n                    .index(name)\n                    .getAll(this.canonicalKeyPath(matchingPredicateValues)));\n            }\n        }\n        return queries;\n    }\n    async baseQueryIndex(storeName, predicates, transaction) {\n        let { predicates: predicateObjs, type } = predicates;\n        // the predicate objects we care about tend to be nested at least\n        // one level down: `{and: {or: {and: { <the predicates we want> }}}}`\n        // so, we unpack and/or groups until we find a group with more than 1\n        // child OR a child that is not a group (and is therefore a predicate \"object\").\n        while (predicateObjs.length === 1 &&\n            isPredicateGroup(predicateObjs[0]) &&\n            predicateObjs[0].type !== 'not') {\n            type = predicateObjs[0].type;\n            predicateObjs = predicateObjs[0].predicates;\n        }\n        const fieldPredicates = predicateObjs.filter(p => isPredicateObj(p) && p.operator === 'eq');\n        // several sub-queries could occur here. explicitly start a txn here to avoid\n        // opening/closing multiple txns.\n        const txn = transaction || this.db.transaction(storeName);\n        let result = {};\n        // `or` conditions, if usable, need to generate multiple queries. this is unlike\n        // `and` conditions, which should just be combined.\n        if (type === 'or') {\n            /**\n             * Base queries for each child group.\n             *\n             * For each child group, if it's an AND condition that results in a single\n             * subordinate \"base query\", we can use it. if it's any more complicated\n             * than that, it's not a simple join condition we want to use.\n             */\n            const groupQueries = await Promise.all(predicateObjs\n                .filter(o => isPredicateGroup(o) && o.type === 'and')\n                .map(o => this.baseQueryIndex(storeName, o, txn))).then(queries => queries\n                .filter(q => q.indexedQueries.length === 1)\n                .map(i => i.indexedQueries));\n            /**\n             * Base queries for each simple child \"object\" (field condition).\n             */\n            const objectQueries = predicateObjs\n                .filter(o => isPredicateObj(o))\n                .map(o => this.matchingIndexQueries(storeName, [o], txn));\n            const indexedQueries = [...groupQueries, ...objectQueries]\n                .map(q => q[0])\n                .filter(i => i);\n            // if, after hunting for base queries, we don't have exactly 1 base query\n            // for each child group + object, stop trying to optimize. we're not dealing\n            // with a simple query that fits the intended optimization path.\n            if (predicateObjs.length > indexedQueries.length) {\n                result = {\n                    groupType: null,\n                    indexedQueries: [],\n                };\n            }\n            else {\n                result = {\n                    groupType: 'or',\n                    indexedQueries,\n                };\n            }\n        }\n        else if (type === 'and') {\n            // our potential indexes or lacks thereof.\n            // note that we're only optimizing for `eq` right now.\n            result = {\n                groupType: type,\n                indexedQueries: this.matchingIndexQueries(storeName, fieldPredicates, txn),\n            };\n        }\n        else {\n            result = {\n                groupType: null,\n                indexedQueries: [],\n            };\n        }\n        // Explicitly wait for txns from index queries to complete before proceding.\n        // This helps ensure IndexedDB is in a stable, ready state. Else, subseqeuent\n        // qeuries can sometimes appear to deadlock (at least in FakeIndexedDB).\n        // (Unless we were *given* the transaction -- we'll assume the parent handles it.)\n        if (!transaction)\n            await txn.done;\n        return result;\n    }\n    async filterOnPredicate(storeName, predicates) {\n        const { predicates: predicateObjs, type } = predicates;\n        const { groupType, indexedQueries } = await this.baseQueryIndex(storeName, predicates);\n        // where we'll accumulate candidate results, which will be filtered at the end.\n        let candidateResults;\n        // semi-naive implementation:\n        if (groupType === 'and' && indexedQueries.length > 0) {\n            // each condition must be satsified, we can form a base set with any\n            // ONE of those conditions and then filter.\n            candidateResults = await indexedQueries[0]();\n        }\n        else if (groupType === 'or' &&\n            indexedQueries.length > 0 &&\n            indexedQueries.length <= MULTI_OR_CONDITION_SCAN_BREAKPOINT) {\n            // NOTE: each condition implies a potentially distinct set. we only benefit\n            // from using indexes here if EVERY condition uses an index. if any one\n            // index requires a table scan, we gain nothing from the indexes.\n            // NOTE: results must be DISTINCT-ified if we leverage indexes.\n            const distinctResults = new Map();\n            for (const query of indexedQueries) {\n                const resultGroup = await query();\n                for (const item of resultGroup) {\n                    const distinctificationString = JSON.stringify(item);\n                    distinctResults.set(distinctificationString, item);\n                }\n            }\n            // we could conceivably check for special conditions and return early here.\n            // but, this is simpler and has not yet had a measurable performance impact.\n            candidateResults = Array.from(distinctResults.values());\n        }\n        else {\n            // nothing intelligent we can do with `not` groups unless or until we start\n            // smashing comparison operators against indexes -- at which point we could\n            // perform some reversal here.\n            candidateResults = await this.getAll(storeName);\n        }\n        const filtered = predicateObjs\n            ? candidateResults.filter(m => validatePredicate(m, type, predicateObjs))\n            : candidateResults;\n        return filtered;\n    }\n    inMemoryPagination(records, pagination) {\n        return inMemoryPagination(records, pagination);\n    }\n    async enginePagination(storeName, pagination) {\n        let result;\n        if (pagination) {\n            const { page = 0, limit = 0 } = pagination;\n            const initialRecord = Math.max(0, page * limit) || 0;\n            let cursor = await this.db\n                .transaction(storeName)\n                .objectStore(storeName)\n                .openCursor();\n            if (cursor && initialRecord > 0) {\n                await cursor.advance(initialRecord);\n            }\n            const pageResults = [];\n            const hasLimit = typeof limit === 'number' && limit > 0;\n            while (cursor && cursor.value) {\n                pageResults.push(cursor.value);\n                if (hasLimit && pageResults.length === limit) {\n                    break;\n                }\n                cursor = await cursor.continue();\n            }\n            result = pageResults;\n        }\n        else {\n            result = await this.db.getAll(storeName);\n        }\n        return result;\n    }\n}\nexport default new IndexedDBAdapter();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}