{"ast":null,"code":"import { ModelPredicateCreator } from '../predicates/index.mjs';\nimport { QueryOne } from '../types.mjs';\nimport { SYNC, directedValueEquality, USER } from '../util.mjs';\nimport { TransformerMutationType, getIdentifierValue } from './utils.mjs';\n\n// TODO: Persist deleted ids\n// https://github.com/aws-amplify/amplify-js/blob/datastore-docs/packages/datastore/docs/sync-engine.md#outbox\nclass MutationEventOutbox {\n  constructor(schema, MutationEvent, modelInstanceCreator, ownSymbol) {\n    this.schema = schema;\n    this.MutationEvent = MutationEvent;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.ownSymbol = ownSymbol;\n  }\n  async enqueue(storage, mutationEvent) {\n    await storage.runExclusive(async s => {\n      const mutationEventModelDefinition = this.schema.namespaces[SYNC].models['MutationEvent'];\n      // `id` is the key for the record in the mutationEvent;\n      // `modelId` is the key for the actual record that was mutated\n      const predicate = ModelPredicateCreator.createFromAST(mutationEventModelDefinition, {\n        and: [{\n          modelId: {\n            eq: mutationEvent.modelId\n          }\n        }, {\n          id: {\n            ne: this.inProgressMutationEventId\n          }\n        }]\n      });\n      // Check if there are any other records with same id\n      const [first] = await s.query(this.MutationEvent, predicate);\n      // No other record with same modelId, so enqueue\n      if (first === undefined) {\n        await s.save(mutationEvent, undefined, this.ownSymbol);\n        return;\n      }\n      // There was an enqueued mutation for the modelId, so continue\n      const {\n        operation: incomingMutationType\n      } = mutationEvent;\n      if (first.operation === TransformerMutationType.CREATE) {\n        if (incomingMutationType === TransformerMutationType.DELETE) {\n          await s.delete(this.MutationEvent, predicate);\n        } else {\n          // first gets updated with the incoming mutation's data, condition intentionally skipped\n          // we need to merge the fields for a create and update mutation to prevent\n          // data loss, since update mutations only include changed fields\n          const merged = this.mergeUserFields(first, mutationEvent);\n          await s.save(this.MutationEvent.copyOf(first, draft => {\n            draft.data = merged.data;\n          }), undefined, this.ownSymbol);\n        }\n      } else {\n        const {\n          condition: incomingConditionJSON\n        } = mutationEvent;\n        const incomingCondition = JSON.parse(incomingConditionJSON);\n        let merged;\n        // If no condition\n        if (Object.keys(incomingCondition).length === 0) {\n          merged = this.mergeUserFields(first, mutationEvent);\n          // delete all for model\n          await s.delete(this.MutationEvent, predicate);\n        }\n        merged = merged || mutationEvent;\n        // Enqueue new one\n        await s.save(merged, undefined, this.ownSymbol);\n      }\n    });\n  }\n  async dequeue(storage, record, recordOp) {\n    const head = await this.peek(storage);\n    if (record) {\n      await this.syncOutboxVersionsOnDequeue(storage, record, head, recordOp);\n    }\n    if (head) {\n      await storage.delete(head);\n    }\n    this.inProgressMutationEventId = undefined;\n    return head;\n  }\n  /**\n   * Doing a peek() implies that the mutation goes \"inProgress\"\n   *\n   * @param storage\n   */\n  async peek(storage) {\n    const head = await storage.queryOne(this.MutationEvent, QueryOne.FIRST);\n    this.inProgressMutationEventId = head ? head.id : undefined;\n    return head;\n  }\n  async getForModel(storage, model, userModelDefinition) {\n    const mutationEventModelDefinition = this.schema.namespaces[SYNC].models.MutationEvent;\n    const modelId = getIdentifierValue(userModelDefinition, model);\n    const mutationEvents = await storage.query(this.MutationEvent, ModelPredicateCreator.createFromAST(mutationEventModelDefinition, {\n      and: {\n        modelId: {\n          eq: modelId\n        }\n      }\n    }));\n    return mutationEvents;\n  }\n  async getModelIds(storage) {\n    const mutationEvents = await storage.query(this.MutationEvent);\n    const result = new Set();\n    mutationEvents.forEach(({\n      modelId\n    }) => result.add(modelId));\n    return result;\n  }\n  // applies _version from the AppSync mutation response to other items\n  // in the mutation queue with the same id\n  // see https://github.com/aws-amplify/amplify-js/pull/7354 for more details\n  async syncOutboxVersionsOnDequeue(storage, record, head, recordOp) {\n    if (head?.operation !== recordOp) {\n      return;\n    }\n    const {\n      _version,\n      _lastChangedAt,\n      _deleted,\n      ..._incomingData\n    } = record;\n    const incomingData = this.removeTimestampFields(head.model, _incomingData);\n    const data = JSON.parse(head.data);\n    if (!data) {\n      return;\n    }\n    const {\n      _version: __version,\n      _lastChangedAt: __lastChangedAt,\n      _deleted: __deleted,\n      ..._outgoingData\n    } = data;\n    const outgoingData = this.removeTimestampFields(head.model, _outgoingData);\n    // Don't sync the version when the data in the response does not match the data\n    // in the request, i.e., when there's a handled conflict\n    //\n    // NOTE: `incomingData` contains all the fields in the record received from AppSync\n    // and `outgoingData` only contains updated fields sent to AppSync\n    // If all send data isn't matched in the returned data then the update was rejected\n    // by AppSync and we should not update the version on other outbox entries for this\n    // object\n    if (!directedValueEquality(outgoingData, incomingData, true)) {\n      return;\n    }\n    const mutationEventModelDefinition = this.schema.namespaces[SYNC].models['MutationEvent'];\n    const userModelDefinition = this.schema.namespaces['user'].models[head.model];\n    const recordId = getIdentifierValue(userModelDefinition, record);\n    const predicate = ModelPredicateCreator.createFromAST(mutationEventModelDefinition, {\n      and: [{\n        modelId: {\n          eq: recordId\n        }\n      }, {\n        id: {\n          ne: this.inProgressMutationEventId\n        }\n      }]\n    });\n    const outdatedMutations = await storage.query(this.MutationEvent, predicate);\n    if (!outdatedMutations.length) {\n      return;\n    }\n    const reconciledMutations = outdatedMutations.map(m => {\n      const oldData = JSON.parse(m.data);\n      const newData = {\n        ...oldData,\n        _version,\n        _lastChangedAt\n      };\n      return this.MutationEvent.copyOf(m, draft => {\n        draft.data = JSON.stringify(newData);\n      });\n    });\n    await storage.delete(this.MutationEvent, predicate);\n    await Promise.all(reconciledMutations.map(async m => await storage.save(m, undefined, this.ownSymbol)));\n  }\n  mergeUserFields(previous, current) {\n    const {\n      _version,\n      _lastChangedAt,\n      _deleted,\n      ...previousData\n    } = JSON.parse(previous.data);\n    const {\n      _version: __version,\n      _lastChangedAt: __lastChangedAt,\n      _deleted: __deleted,\n      ...currentData\n    } = JSON.parse(current.data);\n    const data = JSON.stringify({\n      _version,\n      _lastChangedAt,\n      _deleted,\n      ...previousData,\n      ...currentData\n    });\n    return this.modelInstanceCreator(this.MutationEvent, {\n      ...current,\n      data\n    });\n  }\n  /*\n  if a model is using custom timestamp fields\n  the custom field names will be stored in the model attributes\n   e.g.\n  \"attributes\": [\n  {\n          \"type\": \"model\",\n          \"properties\": {\n              \"timestamps\": {\n                  \"createdAt\": \"createdOn\",\n                  \"updatedAt\": \"updatedOn\"\n              }\n          }\n  }\n  ]\n  */\n  removeTimestampFields(model, record) {\n    const CREATED_AT_DEFAULT_KEY = 'createdAt';\n    const UPDATED_AT_DEFAULT_KEY = 'updatedAt';\n    let createdTimestampKey = CREATED_AT_DEFAULT_KEY;\n    let updatedTimestampKey = UPDATED_AT_DEFAULT_KEY;\n    const modelAttributes = this.schema.namespaces[USER].models[model].attributes?.find(attr => attr.type === 'model');\n    const timestampFieldsMap = modelAttributes?.properties?.timestamps;\n    if (timestampFieldsMap) {\n      createdTimestampKey = timestampFieldsMap[CREATED_AT_DEFAULT_KEY];\n      updatedTimestampKey = timestampFieldsMap[UPDATED_AT_DEFAULT_KEY];\n    }\n    delete record[createdTimestampKey];\n    delete record[updatedTimestampKey];\n    return record;\n  }\n}\nexport { MutationEventOutbox };","map":{"version":3,"names":["MutationEventOutbox","constructor","schema","MutationEvent","modelInstanceCreator","ownSymbol","enqueue","storage","mutationEvent","runExclusive","s","mutationEventModelDefinition","namespaces","SYNC","models","predicate","ModelPredicateCreator","createFromAST","and","modelId","eq","id","ne","inProgressMutationEventId","first","query","undefined","save","operation","incomingMutationType","TransformerMutationType","CREATE","DELETE","delete","merged","mergeUserFields","copyOf","draft","data","condition","incomingConditionJSON","incomingCondition","JSON","parse","Object","keys","length","dequeue","record","recordOp","head","peek","syncOutboxVersionsOnDequeue","queryOne","QueryOne","FIRST","getForModel","model","userModelDefinition","getIdentifierValue","mutationEvents","getModelIds","result","Set","forEach","add","_version","_lastChangedAt","_deleted","_incomingData","incomingData","removeTimestampFields","__version","__lastChangedAt","__deleted","_outgoingData","outgoingData","directedValueEquality","recordId","outdatedMutations","reconciledMutations","map","m","oldData","newData","stringify","Promise","all","previous","current","previousData","currentData","CREATED_AT_DEFAULT_KEY","UPDATED_AT_DEFAULT_KEY","createdTimestampKey","updatedTimestampKey","modelAttributes","USER","attributes","find","attr","type","timestampFieldsMap","properties","timestamps"],"sources":["/Users/raphaperso/Documents/Hub/amplify_test/notes/node_modules/@aws-amplify/datastore/src/sync/outbox.ts"],"sourcesContent":["import { ModelPredicateCreator } from '../predicates';\nimport { QueryOne, } from '../types';\nimport { USER, SYNC, directedValueEquality } from '../util';\nimport { getIdentifierValue, TransformerMutationType } from './utils';\n// TODO: Persist deleted ids\n// https://github.com/aws-amplify/amplify-js/blob/datastore-docs/packages/datastore/docs/sync-engine.md#outbox\nclass MutationEventOutbox {\n    constructor(schema, MutationEvent, modelInstanceCreator, ownSymbol) {\n        this.schema = schema;\n        this.MutationEvent = MutationEvent;\n        this.modelInstanceCreator = modelInstanceCreator;\n        this.ownSymbol = ownSymbol;\n    }\n    async enqueue(storage, mutationEvent) {\n        await storage.runExclusive(async (s) => {\n            const mutationEventModelDefinition = this.schema.namespaces[SYNC].models['MutationEvent'];\n            // `id` is the key for the record in the mutationEvent;\n            // `modelId` is the key for the actual record that was mutated\n            const predicate = ModelPredicateCreator.createFromAST(mutationEventModelDefinition, {\n                and: [\n                    { modelId: { eq: mutationEvent.modelId } },\n                    { id: { ne: this.inProgressMutationEventId } },\n                ],\n            });\n            // Check if there are any other records with same id\n            const [first] = await s.query(this.MutationEvent, predicate);\n            // No other record with same modelId, so enqueue\n            if (first === undefined) {\n                await s.save(mutationEvent, undefined, this.ownSymbol);\n                return;\n            }\n            // There was an enqueued mutation for the modelId, so continue\n            const { operation: incomingMutationType } = mutationEvent;\n            if (first.operation === TransformerMutationType.CREATE) {\n                if (incomingMutationType === TransformerMutationType.DELETE) {\n                    await s.delete(this.MutationEvent, predicate);\n                }\n                else {\n                    // first gets updated with the incoming mutation's data, condition intentionally skipped\n                    // we need to merge the fields for a create and update mutation to prevent\n                    // data loss, since update mutations only include changed fields\n                    const merged = this.mergeUserFields(first, mutationEvent);\n                    await s.save(this.MutationEvent.copyOf(first, draft => {\n                        draft.data = merged.data;\n                    }), undefined, this.ownSymbol);\n                }\n            }\n            else {\n                const { condition: incomingConditionJSON } = mutationEvent;\n                const incomingCondition = JSON.parse(incomingConditionJSON);\n                let merged;\n                // If no condition\n                if (Object.keys(incomingCondition).length === 0) {\n                    merged = this.mergeUserFields(first, mutationEvent);\n                    // delete all for model\n                    await s.delete(this.MutationEvent, predicate);\n                }\n                merged = merged || mutationEvent;\n                // Enqueue new one\n                await s.save(merged, undefined, this.ownSymbol);\n            }\n        });\n    }\n    async dequeue(storage, record, recordOp) {\n        const head = await this.peek(storage);\n        if (record) {\n            await this.syncOutboxVersionsOnDequeue(storage, record, head, recordOp);\n        }\n        if (head) {\n            await storage.delete(head);\n        }\n        this.inProgressMutationEventId = undefined;\n        return head;\n    }\n    /**\n     * Doing a peek() implies that the mutation goes \"inProgress\"\n     *\n     * @param storage\n     */\n    async peek(storage) {\n        const head = await storage.queryOne(this.MutationEvent, QueryOne.FIRST);\n        this.inProgressMutationEventId = head ? head.id : undefined;\n        return head;\n    }\n    async getForModel(storage, model, userModelDefinition) {\n        const mutationEventModelDefinition = this.schema.namespaces[SYNC].models.MutationEvent;\n        const modelId = getIdentifierValue(userModelDefinition, model);\n        const mutationEvents = await storage.query(this.MutationEvent, ModelPredicateCreator.createFromAST(mutationEventModelDefinition, {\n            and: { modelId: { eq: modelId } },\n        }));\n        return mutationEvents;\n    }\n    async getModelIds(storage) {\n        const mutationEvents = await storage.query(this.MutationEvent);\n        const result = new Set();\n        mutationEvents.forEach(({ modelId }) => result.add(modelId));\n        return result;\n    }\n    // applies _version from the AppSync mutation response to other items\n    // in the mutation queue with the same id\n    // see https://github.com/aws-amplify/amplify-js/pull/7354 for more details\n    async syncOutboxVersionsOnDequeue(storage, record, head, recordOp) {\n        if (head?.operation !== recordOp) {\n            return;\n        }\n        const { _version, _lastChangedAt, _deleted, ..._incomingData } = record;\n        const incomingData = this.removeTimestampFields(head.model, _incomingData);\n        const data = JSON.parse(head.data);\n        if (!data) {\n            return;\n        }\n        const { _version: __version, _lastChangedAt: __lastChangedAt, _deleted: __deleted, ..._outgoingData } = data;\n        const outgoingData = this.removeTimestampFields(head.model, _outgoingData);\n        // Don't sync the version when the data in the response does not match the data\n        // in the request, i.e., when there's a handled conflict\n        //\n        // NOTE: `incomingData` contains all the fields in the record received from AppSync\n        // and `outgoingData` only contains updated fields sent to AppSync\n        // If all send data isn't matched in the returned data then the update was rejected\n        // by AppSync and we should not update the version on other outbox entries for this\n        // object\n        if (!directedValueEquality(outgoingData, incomingData, true)) {\n            return;\n        }\n        const mutationEventModelDefinition = this.schema.namespaces[SYNC].models['MutationEvent'];\n        const userModelDefinition = this.schema.namespaces['user'].models[head.model];\n        const recordId = getIdentifierValue(userModelDefinition, record);\n        const predicate = ModelPredicateCreator.createFromAST(mutationEventModelDefinition, {\n            and: [\n                { modelId: { eq: recordId } },\n                { id: { ne: this.inProgressMutationEventId } },\n            ],\n        });\n        const outdatedMutations = await storage.query(this.MutationEvent, predicate);\n        if (!outdatedMutations.length) {\n            return;\n        }\n        const reconciledMutations = outdatedMutations.map(m => {\n            const oldData = JSON.parse(m.data);\n            const newData = { ...oldData, _version, _lastChangedAt };\n            return this.MutationEvent.copyOf(m, draft => {\n                draft.data = JSON.stringify(newData);\n            });\n        });\n        await storage.delete(this.MutationEvent, predicate);\n        await Promise.all(reconciledMutations.map(async (m) => await storage.save(m, undefined, this.ownSymbol)));\n    }\n    mergeUserFields(previous, current) {\n        const { _version, _lastChangedAt, _deleted, ...previousData } = JSON.parse(previous.data);\n        const { _version: __version, _lastChangedAt: __lastChangedAt, _deleted: __deleted, ...currentData } = JSON.parse(current.data);\n        const data = JSON.stringify({\n            _version,\n            _lastChangedAt,\n            _deleted,\n            ...previousData,\n            ...currentData,\n        });\n        return this.modelInstanceCreator(this.MutationEvent, {\n            ...current,\n            data,\n        });\n    }\n    /*\n    if a model is using custom timestamp fields\n    the custom field names will be stored in the model attributes\n\n    e.g.\n    \"attributes\": [\n    {\n            \"type\": \"model\",\n            \"properties\": {\n                \"timestamps\": {\n                    \"createdAt\": \"createdOn\",\n                    \"updatedAt\": \"updatedOn\"\n                }\n            }\n    }\n    ]\n    */\n    removeTimestampFields(model, record) {\n        const CREATED_AT_DEFAULT_KEY = 'createdAt';\n        const UPDATED_AT_DEFAULT_KEY = 'updatedAt';\n        let createdTimestampKey = CREATED_AT_DEFAULT_KEY;\n        let updatedTimestampKey = UPDATED_AT_DEFAULT_KEY;\n        const modelAttributes = this.schema.namespaces[USER].models[model].attributes?.find(attr => attr.type === 'model');\n        const timestampFieldsMap = modelAttributes?.properties?.timestamps;\n        if (timestampFieldsMap) {\n            createdTimestampKey = timestampFieldsMap[CREATED_AT_DEFAULT_KEY];\n            updatedTimestampKey = timestampFieldsMap[UPDATED_AT_DEFAULT_KEY];\n        }\n        delete record[createdTimestampKey];\n        delete record[updatedTimestampKey];\n        return record;\n    }\n}\nexport { MutationEventOutbox };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}